"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // src/shared/logger.js
  var Logger, logger;
  var init_logger = __esm({
    "src/shared/logger.js"() {
      "use strict";
      Logger = class {
        constructor(context = "Hoverboard") {
          this.context = context;
          this.logLevel = this.getLogLevel();
        }
        // IMPL-LOG_LEVEL_CONFIG: Environment-based log level determination
        // SPECIFICATION: Production builds should minimize console output for performance
        // IMPLEMENTATION DECISION: Debug logs in development, warnings+ in production
        getLogLevel() {
          if (typeof process === "undefined" || !process.env) {
            return "debug";
          }
          return false ? "warn" : "debug";
        }
        // IMPL-LOGGER_CONTEXT_LEVELS: Log level filtering logic
        // IMPLEMENTATION DECISION: Numeric level comparison for efficient filtering
        shouldLog(level) {
          const levels = { debug: 0, info: 1, warn: 2, error: 3 };
          return levels[level] >= levels[this.logLevel];
        }
        // IMPL-LOGGER_CONTEXT_LEVELS: Consistent message formatting with metadata
        // SPECIFICATION: Include timestamp, context, and level for log analysis
        // IMPLEMENTATION DECISION: ISO timestamp format for precise timing and parsing
        formatMessage(level, message, ...args) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const prefix = `[${timestamp}] [${this.context}] [${level.toUpperCase()}]`;
          return [prefix, message, ...args];
        }
        // IMPL-LOGGER_CONTEXT_LEVELS: Debug level logging - Development information
        // IMPLEMENTATION DECISION: Use console.log for debug to distinguish from info
        debug(message, ...args) {
          if (this.shouldLog("debug")) {
            console.log(...this.formatMessage("debug", message, ...args));
          }
        }
        // IMPL-LOGGER_CONTEXT_LEVELS: Info level logging - General information
        // IMPLEMENTATION DECISION: Use console.info for semantic clarity
        info(message, ...args) {
          if (this.shouldLog("info")) {
            console.info(...this.formatMessage("info", message, ...args));
          }
        }
        // IMPL-LOGGER_CONTEXT_LEVELS: Warning level logging - Non-critical issues
        // IMPLEMENTATION DECISION: Use console.warn for proper browser developer tools integration
        warn(message, ...args) {
          if (this.shouldLog("warn")) {
            console.warn(...this.formatMessage("warn", message, ...args));
          }
        }
        // IMPL-LOGGER_CONTEXT_LEVELS: Error level logging - Critical issues
        // IMPLEMENTATION DECISION: Use console.error for proper error tracking and debugging
        error(message, ...args) {
          if (this.shouldLog("error")) {
            console.error(...this.formatMessage("error", message, ...args));
          }
        }
        // IMPL-LOGGER_LEGACY: Legacy compatibility methods
        // SPECIFICATION: Maintain backward compatibility during gradual migration
        // IMPLEMENTATION DECISION: Map legacy log calls to debug level
        log(context, ...args) {
          this.debug(`[${context}]`, ...args);
        }
      };
      logger = new Logger();
    }
  });

  // src/shared/safari-shim.js
  function initializeBrowserAPI() {
    console.log("[SAFARI-EXT-SHIM-001] Initializing browser API abstraction");
    if (typeof chrome !== "undefined") {
      browser = chrome;
      console.log("[SAFARI-EXT-SHIM-001] Using Chrome API");
      if (logger && logger.debug) {
        logger.debug("[SAFARI-EXT-SHIM-001] Using Chrome API");
      }
      return;
    }
    try {
      if (typeof window !== "undefined" && window.browser) {
        browser = window.browser;
        console.log("[SAFARI-EXT-SHIM-001] Using webextension-polyfill");
        if (logger && logger.debug) {
          logger.debug("[SAFARI-EXT-SHIM-001] Using webextension-polyfill");
        }
        return;
      }
    } catch (polyfillError) {
      console.warn("[SAFARI-EXT-SHIM-001] webextension-polyfill failed:", polyfillError.message);
    }
    browser = createMinimalBrowserAPI();
    console.warn("[SAFARI-EXT-SHIM-001] No browser API available, using minimal mock");
    if (logger && logger.warn) {
      logger.warn("[SAFARI-EXT-SHIM-001] No browser API available, using minimal mock");
    }
  }
  async function retryOperation(operation, operationName, maxRetries = retryConfig.maxRetries) {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`[SAFARI-EXT-SHIM-001] ${operationName} attempt ${attempt}/${maxRetries}`);
        return await operation();
      } catch (error48) {
        lastError = error48;
        console.warn(`[SAFARI-EXT-SHIM-001] ${operationName} attempt ${attempt} failed:`, error48.message);
        if (attempt < maxRetries) {
          const delay = Math.min(
            retryConfig.baseDelay * Math.pow(retryConfig.backoffMultiplier, attempt - 1),
            retryConfig.maxDelay
          );
          console.log(`[SAFARI-EXT-SHIM-001] Retrying ${operationName} in ${delay}ms`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
    console.error(`[SAFARI-EXT-SHIM-001] ${operationName} failed after ${maxRetries} attempts:`, lastError);
    throw lastError;
  }
  function createMinimalBrowserAPI() {
    console.log("[SAFARI-EXT-SHIM-001] Creating minimal browser API mock");
    return {
      runtime: {
        id: "mock-extension-id",
        getManifest: () => ({ version: "1.0.0" }),
        sendMessage: () => Promise.resolve(),
        onMessage: { addListener: () => {
        } },
        onInstalled: { addListener: () => {
        } }
      },
      storage: {
        sync: {
          get: () => Promise.resolve({}),
          set: () => Promise.resolve(),
          remove: () => Promise.resolve()
        },
        local: {
          get: () => Promise.resolve({}),
          set: () => Promise.resolve(),
          remove: () => Promise.resolve()
        }
      },
      tabs: {
        query: () => Promise.resolve([]),
        sendMessage: () => Promise.resolve()
      }
    };
  }
  var browser, retryConfig, storageQuotaConfig, quotaCache, storageQueue, storageQueueTimeout, storageQuotaUtils, safariEnhancements, platformUtils;
  var init_safari_shim = __esm({
    "src/shared/safari-shim.js"() {
      "use strict";
      init_logger();
      initializeBrowserAPI();
      retryConfig = {
        maxRetries: 3,
        baseDelay: 100,
        maxDelay: 1e3,
        backoffMultiplier: 2
      };
      storageQuotaConfig = {
        warningThreshold: 80,
        // Percentage threshold for warnings
        criticalThreshold: 95,
        // Percentage threshold for critical warnings
        cleanupThreshold: 90,
        // Percentage threshold for automatic cleanup
        maxRetries: 3,
        cacheTimeout: 3e4,
        // 30 seconds cache timeout
        batchSize: 10,
        // Number of operations to batch
        compressionThreshold: 1024,
        // Minimum size for compression (1KB)
        fallbackStrategies: ["local", "memory", "none"]
      };
      quotaCache = {
        data: null,
        timestamp: 0,
        isValid: () => {
          return quotaCache.data && Date.now() - quotaCache.timestamp < storageQuotaConfig.cacheTimeout;
        }
      };
      storageQueue = [];
      storageQueueTimeout = null;
      storageQuotaUtils = {
        // [SAFARI-EXT-STORAGE-001] Get platform-specific quota configuration
        getQuotaConfig: () => {
          const platform = platformUtils.getPlatform();
          const platformConfig = platformUtils.getPlatformConfig();
          return {
            ...storageQuotaConfig,
            warningThreshold: platformConfig.storageQuotaWarning || storageQuotaConfig.warningThreshold,
            criticalThreshold: platformConfig.storageQuotaCritical || storageQuotaConfig.criticalThreshold,
            cleanupThreshold: platformConfig.storageQuotaCleanup || storageQuotaConfig.cleanupThreshold,
            maxRetries: platformConfig.maxRetries || storageQuotaConfig.maxRetries,
            cacheTimeout: platformConfig.storageCacheTimeout || storageQuotaConfig.cacheTimeout,
            batchSize: platformConfig.storageBatchSize || storageQuotaConfig.batchSize,
            enableBatching: platformConfig.enableStorageBatching !== false,
            enableCompression: platformConfig.enableStorageCompression !== false
          };
        },
        // [SAFARI-EXT-STORAGE-001] Enhanced quota usage monitoring with caching
        getQuotaUsage: async (forceRefresh = false) => {
          console.log("[SAFARI-EXT-STORAGE-001] Getting storage quota usage (forceRefresh:", forceRefresh, ")");
          if (!forceRefresh && quotaCache.isValid()) {
            console.log("[SAFARI-EXT-STORAGE-001] Using cached quota data:", quotaCache.data);
            return quotaCache.data;
          }
          try {
            if ("storage" in navigator && "estimate" in navigator.storage) {
              const estimate = await navigator.storage.estimate();
              const quotaUsage = {
                used: estimate.usage || 0,
                quota: estimate.quota || 0,
                usagePercent: estimate.quota ? estimate.usage / estimate.quota * 100 : 0,
                available: estimate.quota ? estimate.quota - estimate.usage : 0,
                timestamp: Date.now()
              };
              quotaCache.data = quotaUsage;
              quotaCache.timestamp = Date.now();
              console.log("[SAFARI-EXT-STORAGE-001] Storage quota usage:", quotaUsage);
              await storageQuotaUtils.monitorQuotaUsage(quotaUsage);
              return quotaUsage;
            }
            console.warn("[SAFARI-EXT-STORAGE-001] Storage API not available, returning default values");
            const defaultUsage = { used: 0, quota: 0, usagePercent: 0, available: 0, timestamp: Date.now() };
            quotaCache.data = defaultUsage;
            quotaCache.timestamp = Date.now();
            return defaultUsage;
          } catch (error48) {
            console.error("[SAFARI-EXT-STORAGE-001] Storage quota check failed:", error48);
            if (logger && logger.error) {
              logger.error("[SAFARI-EXT-STORAGE-001] Storage quota check failed:", error48);
            }
            const fallbackUsage = { used: 0, quota: 0, usagePercent: 0, available: 0, timestamp: Date.now() };
            quotaCache.data = fallbackUsage;
            quotaCache.timestamp = Date.now();
            return fallbackUsage;
          }
        },
        // [SAFARI-EXT-STORAGE-001] Enhanced quota monitoring with predictive warnings
        monitorQuotaUsage: async (quotaUsage) => {
          const config2 = storageQuotaUtils.getQuotaConfig();
          if (quotaUsage.usagePercent >= config2.criticalThreshold) {
            const criticalWarning = `[SAFARI-EXT-STORAGE-001] CRITICAL: Storage quota usage at ${quotaUsage.usagePercent.toFixed(1)}%`;
            console.error(criticalWarning);
            if (logger && logger.error) {
              logger.error(criticalWarning);
            }
            await storageQuotaUtils.triggerAutomaticCleanup();
          } else if (quotaUsage.usagePercent >= config2.warningThreshold) {
            const warning = `[SAFARI-EXT-STORAGE-001] Storage quota usage high: ${quotaUsage.usagePercent.toFixed(1)}%`;
            console.warn(warning);
            if (logger && logger.warn) {
              logger.warn(warning);
            }
            if (quotaUsage.usagePercent >= config2.cleanupThreshold) {
              const predictiveWarning = "[SAFARI-EXT-STORAGE-001] Approaching critical threshold, consider cleanup";
              console.warn(predictiveWarning);
              if (logger && logger.warn) {
                logger.warn(predictiveWarning);
              }
            }
          }
        },
        // [SAFARI-EXT-STORAGE-001] Automatic cleanup for storage quota management
        triggerAutomaticCleanup: async () => {
          console.log("[SAFARI-EXT-STORAGE-001] Triggering automatic storage cleanup");
          try {
            const storageData = await browser.storage.sync.get(null);
            const cleanupCandidates = [];
            for (const [key, value] of Object.entries(storageData)) {
              const dataSize = JSON.stringify(value).length;
              const dataAge = value.timestamp ? Date.now() - value.timestamp : 0;
              if (dataSize > storageQuotaConfig.compressionThreshold || dataAge > 7 * 24 * 60 * 60 * 1e3) {
                cleanupCandidates.push({ key, size: dataSize, age: dataAge });
              }
            }
            cleanupCandidates.sort((a, b) => b.size - a.size || b.age - a.age);
            const config2 = storageQuotaUtils.getQuotaConfig();
            let removedCount = 0;
            for (const candidate of cleanupCandidates) {
              if (removedCount >= 5) break;
              try {
                await browser.storage.sync.remove(candidate.key);
                console.log(`[SAFARI-EXT-STORAGE-001] Cleaned up storage key: ${candidate.key} (${candidate.size} bytes)`);
                removedCount++;
              } catch (error48) {
                console.error(`[SAFARI-EXT-STORAGE-001] Failed to cleanup ${candidate.key}:`, error48);
              }
            }
            if (removedCount > 0) {
              console.log(`[SAFARI-EXT-STORAGE-001] Automatic cleanup completed: removed ${removedCount} items`);
              quotaCache.data = null;
              await storageQuotaUtils.getQuotaUsage(true);
            }
          } catch (error48) {
            console.error("[SAFARI-EXT-STORAGE-001] Automatic cleanup failed:", error48);
            if (logger && logger.error) {
              logger.error("[SAFARI-EXT-STORAGE-001] Automatic cleanup failed:", error48);
            }
          }
        },
        // [SAFARI-EXT-STORAGE-001] Graceful degradation for storage failures
        handleStorageFailure: async (error48, operation, fallbackData = null) => {
          console.error(`[SAFARI-EXT-STORAGE-001] Storage operation failed: ${operation}`, error48);
          if (logger && logger.error) {
            logger.error(`[SAFARI-EXT-STORAGE-001] Storage operation failed: ${operation}`, error48);
          }
          const config2 = storageQuotaUtils.getQuotaConfig();
          for (const strategy of config2.fallbackStrategies) {
            try {
              switch (strategy) {
                case "local":
                  console.log("[SAFARI-EXT-STORAGE-001] Trying local storage fallback");
                  if (operation === "get") {
                    return await browser.storage.local.get(fallbackData);
                  } else if (operation === "set") {
                    return await browser.storage.local.set(fallbackData);
                  }
                  break;
                case "memory":
                  console.log("[SAFARI-EXT-STORAGE-001] Using memory fallback");
                  return fallbackData;
                case "none":
                  console.log("[SAFARI-EXT-STORAGE-001] No fallback available, throwing error");
                  throw error48;
              }
            } catch (fallbackError) {
              console.warn(`[SAFARI-EXT-STORAGE-001] Fallback strategy '${strategy}' failed:`, fallbackError);
              continue;
            }
          }
          throw error48;
        },
        // [SAFARI-EXT-STORAGE-001] Batch storage operations for performance
        queueStorageOperation: (operation) => {
          storageQueue.push(operation);
          if (storageQueue.length >= storageQuotaConfig.batchSize) {
            storageQuotaUtils.processStorageQueue();
          } else if (!storageQueueTimeout) {
            storageQueueTimeout = setTimeout(() => {
              storageQuotaUtils.processStorageQueue();
            }, 100);
          }
        },
        // [SAFARI-EXT-STORAGE-001] Process batched storage operations
        processStorageQueue: async () => {
          if (storageQueue.length === 0) return;
          const operations = [...storageQueue];
          storageQueue = [];
          storageQueueTimeout = null;
          console.log(`[SAFARI-EXT-STORAGE-001] Processing ${operations.length} batched storage operations`);
          try {
            const getOps = operations.filter((op) => op.type === "get");
            const setOps = operations.filter((op) => op.type === "set");
            const removeOps = operations.filter((op) => op.type === "remove");
            const results = [];
            if (getOps.length > 0) {
              const keys = getOps.flatMap((op) => op.keys || []);
              const result = await browser.storage.sync.get(keys);
              results.push(...getOps.map((op) => ({ ...op, result })));
            }
            if (setOps.length > 0) {
              const data = Object.assign({}, ...setOps.map((op) => op.data));
              const result = await browser.storage.sync.set(data);
              results.push(...setOps.map((op) => ({ ...op, result })));
            }
            if (removeOps.length > 0) {
              const keys = removeOps.flatMap((op) => op.keys || []);
              const result = await browser.storage.sync.remove(keys);
              results.push(...removeOps.map((op) => ({ ...op, result })));
            }
            console.log(`[SAFARI-EXT-STORAGE-001] Successfully processed ${operations.length} batched operations`);
            await storageQuotaUtils.getQuotaUsage(true);
          } catch (error48) {
            console.error("[SAFARI-EXT-STORAGE-001] Batch storage operations failed:", error48);
            if (logger && logger.error) {
              logger.error("[SAFARI-EXT-STORAGE-001] Batch storage operations failed:", error48);
            }
            for (const operation of operations) {
              try {
                await retryOperation(async () => {
                  if (operation.type === "get") {
                    return await browser.storage.sync.get(operation.keys);
                  } else if (operation.type === "set") {
                    return await browser.storage.sync.set(operation.data);
                  } else if (operation.type === "remove") {
                    return await browser.storage.sync.remove(operation.keys);
                  }
                }, `individual ${operation.type} operation`);
              } catch (individualError) {
                console.error("[SAFARI-EXT-STORAGE-001] Individual operation failed:", individualError);
              }
            }
          }
        }
      };
      safariEnhancements = {
        // Safari storage quota management
        storage: {
          ...browser.storage,
          // [SAFARI-EXT-STORAGE-001] Enhanced Safari storage quota management
          getQuotaUsage: storageQuotaUtils.getQuotaUsage,
          // [SAFARI-EXT-STORAGE-001] Enhanced Safari-optimized storage operations
          sync: {
            ...browser.storage.sync,
            // Safari sync storage with enhanced quota management and retry logic
            get: async (keys) => {
              console.log("[SAFARI-EXT-STORAGE-001] Getting sync storage:", keys);
              return retryOperation(async () => {
                try {
                  const result = await browser.storage.sync.get(keys);
                  console.log("[SAFARI-EXT-STORAGE-001] Sync storage get successful:", result);
                  await storageQuotaUtils.getQuotaUsage();
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-STORAGE-001] Sync storage get failed:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-STORAGE-001] Sync storage get failed:", error48);
                  }
                  return await storageQuotaUtils.handleStorageFailure(error48, "get", keys);
                }
              }, "sync storage get");
            },
            // Enhanced set operation with retry logic and graceful degradation
            set: async (data) => {
              console.log("[SAFARI-EXT-STORAGE-001] Setting sync storage:", data);
              return retryOperation(async () => {
                try {
                  const result = await browser.storage.sync.set(data);
                  console.log("[SAFARI-EXT-STORAGE-001] Sync storage set successful");
                  await storageQuotaUtils.getQuotaUsage();
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-STORAGE-001] Sync storage set failed:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-STORAGE-001] Sync storage set failed:", error48);
                  }
                  return await storageQuotaUtils.handleStorageFailure(error48, "set", data);
                }
              }, "sync storage set");
            },
            // [SAFARI-EXT-STORAGE-001] Enhanced remove operation with graceful degradation
            remove: async (keys) => {
              console.log("[SAFARI-EXT-STORAGE-001] Removing sync storage keys:", keys);
              return retryOperation(async () => {
                try {
                  const result = await browser.storage.sync.remove(keys);
                  console.log("[SAFARI-EXT-STORAGE-001] Sync storage remove successful");
                  await storageQuotaUtils.getQuotaUsage();
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-STORAGE-001] Sync storage remove failed:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-STORAGE-001] Sync storage remove failed:", error48);
                  }
                  return await storageQuotaUtils.handleStorageFailure(error48, "remove", keys);
                }
              }, "sync storage remove");
            }
          },
          // [SAFARI-EXT-STORAGE-001] Enhanced local storage with quota management
          local: {
            ...browser.storage.local,
            get: async (keys) => {
              console.log("[SAFARI-EXT-STORAGE-001] Getting local storage:", keys);
              return retryOperation(async () => {
                try {
                  const result = await browser.storage.local.get(keys);
                  console.log("[SAFARI-EXT-STORAGE-001] Local storage get successful:", result);
                  await storageQuotaUtils.getQuotaUsage();
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-STORAGE-001] Local storage get failed:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-STORAGE-001] Local storage get failed:", error48);
                  }
                  return await storageQuotaUtils.handleStorageFailure(error48, "get", keys);
                }
              }, "local storage get");
            },
            set: async (data) => {
              console.log("[SAFARI-EXT-STORAGE-001] Setting local storage:", data);
              return retryOperation(async () => {
                try {
                  const result = await browser.storage.local.set(data);
                  console.log("[SAFARI-EXT-STORAGE-001] Local storage set successful");
                  await storageQuotaUtils.getQuotaUsage();
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-STORAGE-001] Local storage set failed:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-STORAGE-001] Local storage set failed:", error48);
                  }
                  return await storageQuotaUtils.handleStorageFailure(error48, "set", data);
                }
              }, "local storage set");
            },
            remove: async (keys) => {
              console.log("[SAFARI-EXT-STORAGE-001] Removing local storage keys:", keys);
              return retryOperation(async () => {
                try {
                  const result = await browser.storage.local.remove(keys);
                  console.log("[SAFARI-EXT-STORAGE-001] Local storage remove successful");
                  await storageQuotaUtils.getQuotaUsage();
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-STORAGE-001] Local storage remove failed:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-STORAGE-001] Local storage remove failed:", error48);
                  }
                  return await storageQuotaUtils.handleStorageFailure(error48, "remove", keys);
                }
              }, "local storage remove");
            }
          }
        },
        // Enhanced Safari message passing optimizations
        runtime: {
          ...browser.runtime,
          // [SAFARI-EXT-MESSAGING-001] Enhanced Safari-optimized message passing
          sendMessage: async (message) => {
            console.log("[SAFARI-EXT-MESSAGING-001] Sending message:", message);
            return retryOperation(async () => {
              try {
                const enhancedMessage = {
                  ...message,
                  timestamp: Date.now(),
                  version: browser.runtime.getManifest().version
                };
                if (typeof safari !== "undefined") {
                  enhancedMessage.platform = "safari";
                  console.log("[SAFARI-EXT-MESSAGING-001] Safari platform detected, adding platform info");
                }
                if (logger && logger.debug) {
                  logger.debug("[SAFARI-EXT-MESSAGING-001] Sending message:", enhancedMessage);
                }
                return new Promise((resolve, reject) => {
                  chrome.runtime.sendMessage(enhancedMessage, (response) => {
                    if (chrome.runtime.lastError) {
                      const error48 = new Error(chrome.runtime.lastError.message);
                      console.error("[SAFARI-EXT-MESSAGING-001] Message send failed:", error48.message);
                      if (logger && logger.error) {
                        logger.error("[SAFARI-EXT-MESSAGING-001] Message send failed:", error48);
                      }
                      reject(error48);
                    } else {
                      console.log("[SAFARI-EXT-MESSAGING-001] Message sent successfully:", response);
                      resolve(response);
                    }
                  });
                });
              } catch (error48) {
                console.error("[SAFARI-EXT-MESSAGING-001] Message send failed:", error48.message);
                if (logger && logger.error) {
                  logger.error("[SAFARI-EXT-MESSAGING-001] Message send failed:", error48);
                }
                throw error48;
              }
            }, "runtime sendMessage");
          },
          // [SAFARI-EXT-MESSAGING-001] Enhanced Safari message listener with error handling
          onMessage: {
            ...browser.runtime.onMessage,
            addListener: (callback) => {
              console.log("[SAFARI-EXT-MESSAGING-001] Adding message listener");
              const wrappedCallback = (message, sender, sendResponse) => {
                try {
                  console.log("[SAFARI-EXT-MESSAGING-001] Received message:", message);
                  if (logger && logger.debug) {
                    logger.debug("[SAFARI-EXT-MESSAGING-001] Received message:", message);
                  }
                  const result = callback(message, sender, sendResponse);
                  if (result && typeof result.then === "function") {
                    result.then((response) => {
                      console.log("[SAFARI-EXT-MESSAGING-001] Async response:", response);
                      if (logger && logger.debug) {
                        logger.debug("[SAFARI-EXT-MESSAGING-001] Async response:", response);
                      }
                    }).catch((error48) => {
                      console.error("[SAFARI-EXT-MESSAGING-001] Message handler error:", error48);
                      if (logger && logger.error) {
                        logger.error("[SAFARI-EXT-MESSAGING-001] Message handler error:", error48);
                      }
                    });
                  }
                  return result;
                } catch (error48) {
                  console.error("[SAFARI-EXT-MESSAGING-001] Message handler error:", error48);
                  if (logger && logger.error) {
                    logger.error("[SAFARI-EXT-MESSAGING-001] Message handler error:", error48);
                  }
                  throw error48;
                }
              };
              return chrome.runtime.onMessage.addListener(wrappedCallback);
            }
          }
        },
        // Enhanced Safari tabs API enhancements
        tabs: {
          ...browser.tabs,
          // [SAFARI-EXT-CONTENT-001] Enhanced Safari-optimized tab querying
          query: async (queryInfo) => {
            console.log("[SAFARI-EXT-CONTENT-001] Querying tabs:", queryInfo);
            return retryOperation(async () => {
              try {
                const tabs = await browser.tabs.query(queryInfo);
                console.log("[SAFARI-EXT-CONTENT-001] Tab query successful, found tabs:", tabs.length);
                if (typeof safari !== "undefined") {
                  const filteredTabs = tabs.filter((tab) => !tab.url.startsWith("safari-extension://"));
                  console.log("[SAFARI-EXT-CONTENT-001] Filtered tabs:", { original: tabs.length, filtered: filteredTabs.length });
                  if (logger && logger.debug) {
                    logger.debug("[SAFARI-EXT-CONTENT-001] Filtered tabs:", { original: tabs.length, filtered: filteredTabs.length });
                  }
                  return filteredTabs;
                }
                return tabs;
              } catch (error48) {
                console.error("[SAFARI-EXT-CONTENT-001] Tab query failed:", error48.message);
                if (logger && logger.error) {
                  logger.error("[SAFARI-EXT-CONTENT-001] Tab query failed:", error48);
                }
                throw error48;
              }
            }, "tabs query");
          },
          // [SAFARI-EXT-MESSAGING-001] Enhanced Safari-optimized tab message sending
          sendMessage: async (tabId, message) => {
            console.log("[SAFARI-EXT-MESSAGING-001] Sending message to tab:", { tabId, message });
            return retryOperation(async () => {
              try {
                if (logger && logger.debug) {
                  logger.debug("[SAFARI-EXT-MESSAGING-001] Sending message to tab:", { tabId, message });
                }
                return new Promise((resolve, reject) => {
                  chrome.tabs.sendMessage(tabId, message, (response) => {
                    if (chrome.runtime.lastError) {
                      const error48 = new Error(chrome.runtime.lastError.message);
                      console.error("[SAFARI-EXT-MESSAGING-001] Tab message send failed:", error48.message);
                      reject(error48);
                    } else {
                      console.log("[SAFARI-EXT-MESSAGING-001] Tab message sent successfully:", response);
                      resolve(response);
                    }
                  });
                });
              } catch (error48) {
                console.error("[SAFARI-EXT-MESSAGING-001] Tab message send failed:", error48.message);
                if (logger && logger.error) {
                  logger.error("[SAFARI-EXT-MESSAGING-001] Tab message send failed:", error48);
                }
                throw error48;
              }
            }, "tabs sendMessage");
          }
        }
      };
      platformUtils = {
        isSafari: () => {
          const isSafari = typeof safari !== "undefined";
          console.log("[SAFARI-EXT-SHIM-001] Safari detection:", isSafari);
          return isSafari;
        },
        isChrome: () => {
          const isChrome = typeof chrome !== "undefined" && !platformUtils.isSafari();
          console.log("[SAFARI-EXT-SHIM-001] Chrome detection:", isChrome);
          return isChrome;
        },
        isFirefox: () => {
          const isFirefox = typeof browser !== "undefined" && browser.runtime.getBrowserInfo;
          console.log("[SAFARI-EXT-SHIM-001] Firefox detection:", isFirefox);
          return isFirefox;
        },
        // [SAFARI-EXT-SHIM-001] Get current platform for feature detection
        getPlatform: () => {
          if (platformUtils.isSafari()) return "safari";
          if (platformUtils.isChrome()) return "chrome";
          if (platformUtils.isFirefox()) return "firefox";
          return "unknown";
        },
        // [SAFARI-EXT-SHIM-001] Enhanced feature support detection
        supportsFeature: (feature) => {
          const platform = platformUtils.getPlatform();
          console.log(`[SAFARI-EXT-SHIM-001] Checking feature support: ${feature} on ${platform}`);
          const featureSupport = {
            backdropFilter: {
              safari: true,
              chrome: true,
              firefox: false
            },
            webkitBackdropFilter: {
              safari: true,
              chrome: false,
              firefox: false
            },
            visualViewport: {
              safari: true,
              chrome: true,
              firefox: false
            },
            // [SAFARI-EXT-SHIM-001] Add Safari-specific features
            safariExtensions: {
              safari: true,
              chrome: false,
              firefox: false
            },
            storageQuota: {
              safari: true,
              chrome: true,
              firefox: true
            },
            messageRetry: {
              safari: true,
              chrome: true,
              firefox: true
            },
            // [SAFARI-EXT-SHIM-001] Enhanced runtime feature detection
            runtimeFeatureDetection: {
              safari: true,
              chrome: true,
              firefox: true
            },
            performanceMonitoring: {
              safari: true,
              chrome: true,
              firefox: true
            },
            accessibilityFeatures: {
              safari: true,
              chrome: true,
              firefox: true
            },
            securityFeatures: {
              safari: true,
              chrome: true,
              firefox: true
            }
          };
          const isSupported = featureSupport[feature]?.[platform] || false;
          console.log(`[SAFARI-EXT-SHIM-001] Feature ${feature} supported on ${platform}:`, isSupported);
          return isSupported;
        },
        // [SAFARI-EXT-SHIM-001] Runtime feature detection for dynamic capabilities
        detectRuntimeFeatures: () => {
          const platform = platformUtils.getPlatform();
          console.log("[SAFARI-EXT-SHIM-001] Detecting runtime features for platform:", platform);
          const runtimeFeatures = {
            // [SAFARI-EXT-SHIM-001] Storage capabilities
            storage: {
              sync: typeof browser?.storage?.sync !== "undefined",
              local: typeof browser?.storage?.local !== "undefined",
              quota: typeof navigator?.storage?.estimate === "function",
              compression: platform === "safari" || platform === "firefox"
            },
            // [SAFARI-EXT-SHIM-001] Messaging capabilities
            messaging: {
              runtime: typeof browser?.runtime?.sendMessage === "function",
              tabs: typeof browser?.tabs?.sendMessage === "function",
              retry: true,
              // All platforms support retry via our implementation
              timeout: true
              // All platforms support timeout via our implementation
            },
            // [SAFARI-EXT-SHIM-001] UI capabilities
            ui: {
              backdropFilter: CSS.supports("backdrop-filter", "blur(10px)"),
              webkitBackdropFilter: CSS.supports("-webkit-backdrop-filter", "blur(10px)"),
              visualViewport: typeof window?.visualViewport !== "undefined",
              cssGrid: CSS.supports("display", "grid"),
              cssFlexbox: CSS.supports("display", "flex")
            },
            // [SAFARI-EXT-SHIM-001] Performance capabilities
            performance: {
              performanceObserver: typeof PerformanceObserver !== "undefined",
              performanceMark: typeof performance?.mark === "function",
              performanceMeasure: typeof performance?.measure === "function",
              requestIdleCallback: typeof requestIdleCallback === "function"
            },
            // [SAFARI-EXT-SHIM-001] Security capabilities
            security: {
              crypto: typeof crypto?.getRandomValues === "function",
              subtle: typeof crypto?.subtle !== "undefined",
              secureContext: window?.isSecureContext || false
            }
          };
          console.log("[SAFARI-EXT-SHIM-001] Runtime features detected:", runtimeFeatures);
          return runtimeFeatures;
        },
        // [SAFARI-EXT-SHIM-001] Performance monitoring utilities
        getPerformanceMetrics: () => {
          const platform = platformUtils.getPlatform();
          console.log("[SAFARI-EXT-SHIM-001] Getting performance metrics for platform:", platform);
          const metrics = {
            platform,
            timestamp: Date.now(),
            memory: {
              used: performance?.memory?.usedJSHeapSize || 0,
              total: performance?.memory?.totalJSHeapSize || 0,
              limit: performance?.memory?.jsHeapSizeLimit || 0
            },
            timing: {
              navigationStart: performance?.timing?.navigationStart || 0,
              loadEventEnd: performance?.timing?.loadEventEnd || 0,
              domContentLoaded: performance?.timing?.domContentLoadedEventEnd || 0
            },
            // [SAFARI-EXT-SHIM-001] Platform-specific performance indicators
            platformSpecific: {
              safari: platform === "safari" ? {
                extensionAPIAvailable: typeof safari?.extension !== "undefined",
                globalPageAvailable: typeof safari?.extension?.globalPage !== "undefined"
              } : {},
              chrome: platform === "chrome" ? {
                runtimeAPIAvailable: typeof chrome?.runtime !== "undefined",
                storageAPIAvailable: typeof chrome?.storage !== "undefined"
              } : {},
              firefox: platform === "firefox" ? {
                browserAPIAvailable: typeof browser?.runtime !== "undefined",
                webextensionPolyfill: typeof browser?.runtime?.getBrowserInfo === "function"
              } : {}
            }
          };
          console.log("[SAFARI-EXT-SHIM-001] Performance metrics:", metrics);
          return metrics;
        },
        // [SAFARI-EXT-SHIM-001] Accessibility feature detection
        detectAccessibilityFeatures: () => {
          const platform = platformUtils.getPlatform();
          console.log("[SAFARI-EXT-SHIM-001] Detecting accessibility features for platform:", platform);
          const accessibilityFeatures = {
            // [SAFARI-EXT-SHIM-001] Screen reader support
            screenReader: {
              aria: typeof window?.document?.createElement === "function",
              liveRegions: CSS.supports("aria-live", "polite"),
              focusManagement: typeof window?.document?.activeElement !== "undefined"
            },
            // [SAFARI-EXT-SHIM-001] High contrast support
            highContrast: {
              prefersContrast: window?.matchMedia?.("(prefers-contrast: high)")?.matches || false,
              forcedColors: window?.matchMedia?.("(forced-colors: active)")?.matches || false
            },
            // [SAFARI-EXT-SHIM-001] Reduced motion support
            reducedMotion: {
              prefersReducedMotion: window?.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches || false
            },
            // [SAFARI-EXT-SHIM-001] Platform-specific accessibility
            platformSpecific: {
              safari: platform === "safari" ? {
                voiceOver: navigator?.userAgent?.includes("Mac OS X") || false,
                safariAccessibility: true
              } : {},
              chrome: platform === "chrome" ? {
                chromeVox: false,
                // Would need specific detection
                chromeAccessibility: true
              } : {},
              firefox: platform === "firefox" ? {
                nvda: false,
                // Would need specific detection
                firefoxAccessibility: true
              } : {}
            }
          };
          console.log("[SAFARI-EXT-SHIM-001] Accessibility features detected:", accessibilityFeatures);
          return accessibilityFeatures;
        },
        // [SAFARI-EXT-SHIM-001] Security feature detection
        detectSecurityFeatures: () => {
          const platform = platformUtils.getPlatform();
          console.log("[SAFARI-EXT-SHIM-001] Detecting security features for platform:", platform);
          const securityFeatures = {
            // [SAFARI-EXT-SHIM-001] Crypto capabilities
            crypto: {
              getRandomValues: typeof crypto?.getRandomValues === "function",
              subtle: typeof crypto?.subtle !== "undefined",
              randomUUID: typeof crypto?.randomUUID === "function"
            },
            // [SAFARI-EXT-SHIM-001] Security context
            context: {
              secureContext: window?.isSecureContext || false,
              https: window?.location?.protocol === "https:",
              localhost: window?.location?.hostname === "localhost"
            },
            // [SAFARI-EXT-SHIM-001] Content Security Policy
            csp: {
              supportsCSP: typeof window?.document?.querySelector === "function"
              // Note: CSP detection would require more sophisticated analysis
            },
            // [SAFARI-EXT-SHIM-001] Platform-specific security
            platformSpecific: {
              safari: platform === "safari" ? {
                safariSecurity: true,
                appSandbox: true
              } : {},
              chrome: platform === "chrome" ? {
                chromeSecurity: true,
                extensionSandbox: true
              } : {},
              firefox: platform === "firefox" ? {
                firefoxSecurity: true,
                webextensionSandbox: true
              } : {}
            }
          };
          console.log("[SAFARI-EXT-SHIM-001] Security features detected:", securityFeatures);
          return securityFeatures;
        },
        // [SAFARI-EXT-SHIM-001] Get platform-specific configuration
        getPlatformConfig: () => {
          const platform = platformUtils.getPlatform();
          console.log("[SAFARI-EXT-SHIM-001] Getting platform config for:", platform);
          const platformConfigs = {
            safari: {
              maxRetries: 3,
              baseDelay: 150,
              maxDelay: 1500,
              storageQuotaWarning: 80,
              storageQuotaCritical: 95,
              storageQuotaCleanup: 90,
              enableTabFiltering: true,
              enableStorageBatching: true,
              enableStorageCompression: true,
              storageCacheTimeout: 3e4,
              storageBatchSize: 10,
              // [SAFARI-EXT-SHIM-001] Enhanced Safari-specific optimizations
              enableRuntimeFeatureDetection: true,
              enablePerformanceMonitoring: true,
              enableAccessibilityFeatures: true,
              enableSecurityFeatures: true,
              performanceMonitoringInterval: 3e4,
              // 30 seconds
              accessibilityCheckInterval: 6e4,
              // 1 minute
              securityCheckInterval: 3e5
              // 5 minutes
            },
            chrome: {
              maxRetries: 2,
              baseDelay: 100,
              maxDelay: 1e3,
              storageQuotaWarning: 90,
              storageQuotaCritical: 98,
              storageQuotaCleanup: 95,
              enableTabFiltering: false,
              enableStorageBatching: true,
              enableStorageCompression: false,
              storageCacheTimeout: 3e4,
              storageBatchSize: 15,
              // [SAFARI-EXT-SHIM-001] Enhanced Chrome-specific optimizations
              enableRuntimeFeatureDetection: true,
              enablePerformanceMonitoring: true,
              enableAccessibilityFeatures: true,
              enableSecurityFeatures: true,
              performanceMonitoringInterval: 45e3,
              // 45 seconds
              accessibilityCheckInterval: 9e4,
              // 1.5 minutes
              securityCheckInterval: 6e5
              // 10 minutes
            },
            firefox: {
              maxRetries: 3,
              baseDelay: 200,
              maxDelay: 2e3,
              storageQuotaWarning: 85,
              storageQuotaCritical: 95,
              storageQuotaCleanup: 90,
              enableTabFiltering: false,
              enableStorageBatching: true,
              enableStorageCompression: true,
              storageCacheTimeout: 45e3,
              storageBatchSize: 8,
              // [SAFARI-EXT-SHIM-001] Enhanced Firefox-specific optimizations
              enableRuntimeFeatureDetection: true,
              enablePerformanceMonitoring: true,
              enableAccessibilityFeatures: true,
              enableSecurityFeatures: true,
              performanceMonitoringInterval: 6e4,
              // 1 minute
              accessibilityCheckInterval: 12e4,
              // 2 minutes
              securityCheckInterval: 9e5
              // 15 minutes
            }
          };
          return platformConfigs[platform] || platformConfigs.chrome;
        },
        // [SAFARI-EXT-SHIM-001] Comprehensive platform analysis
        analyzePlatform: () => {
          const platform = platformUtils.getPlatform();
          console.log("[SAFARI-EXT-SHIM-001] Performing comprehensive platform analysis for:", platform);
          const analysis = {
            platform,
            timestamp: Date.now(),
            config: platformUtils.getPlatformConfig(),
            runtimeFeatures: platformUtils.detectRuntimeFeatures(),
            performanceMetrics: platformUtils.getPerformanceMetrics(),
            accessibilityFeatures: platformUtils.detectAccessibilityFeatures(),
            securityFeatures: platformUtils.detectSecurityFeatures(),
            // [SAFARI-EXT-SHIM-001] Platform-specific recommendations
            recommendations: {
              safari: platform === "safari" ? {
                enableCompression: true,
                useTabFiltering: true,
                monitorStorageQuota: true,
                enableAccessibility: true
              } : {},
              chrome: platform === "chrome" ? {
                enableCompression: false,
                useTabFiltering: false,
                monitorStorageQuota: true,
                enableAccessibility: true
              } : {},
              firefox: platform === "firefox" ? {
                enableCompression: true,
                useTabFiltering: false,
                monitorStorageQuota: true,
                enableAccessibility: true
              } : {}
            }
          };
          console.log("[SAFARI-EXT-SHIM-001] Platform analysis completed:", analysis);
          return analysis;
        }
      };
    }
  });

  // src/shared/utils.js
  function debugLog2(component, message, ...args) {
    if (DEBUG_CONFIG.enabled) {
      const prefix = `${DEBUG_CONFIG.prefix} [${component}]`;
      if (args.length > 0) {
        console.log(prefix, message, ...args);
      } else {
        console.log(prefix, message);
      }
    }
  }
  function debugError(component, message, ...args) {
    if (DEBUG_CONFIG.enabled) {
      const prefix = `${DEBUG_CONFIG.prefix} [${component}]`;
      if (args.length > 0) {
        console.error(prefix, message, ...args);
      } else {
        console.error(prefix, message);
      }
    }
  }
  function debugWarn(component, message, ...args) {
    if (DEBUG_CONFIG.enabled) {
      const prefix = `${DEBUG_CONFIG.prefix} [${component}]`;
      if (args.length > 0) {
        console.warn(prefix, message, ...args);
      } else {
        console.warn(prefix, message);
      }
    }
  }
  var DEBUG_CONFIG;
  var init_utils = __esm({
    "src/shared/utils.js"() {
      "use strict";
      init_logger();
      init_safari_shim();
      DEBUG_CONFIG = {
        enabled: true,
        // Set to false to disable all debug output
        prefix: "[HOVERBOARD-DEBUG]"
      };
    }
  });

  // node_modules/zod/v4/core/core.js
  // @__NO_SIDE_EFFECTS__
  function $constructor(name, initializer3, params) {
    function init(inst, def) {
      if (!inst._zod) {
        Object.defineProperty(inst, "_zod", {
          value: {
            def,
            constr: _,
            traits: /* @__PURE__ */ new Set()
          },
          enumerable: false
        });
      }
      if (inst._zod.traits.has(name)) {
        return;
      }
      inst._zod.traits.add(name);
      initializer3(inst, def);
      const proto = _.prototype;
      const keys = Object.keys(proto);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        if (!(k in inst)) {
          inst[k] = proto[k].bind(inst);
        }
      }
    }
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name });
    function _(def) {
      var _a2;
      const inst = params?.Parent ? new Definition() : this;
      init(inst, def);
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      for (const fn of inst._zod.deferred) {
        fn();
      }
      return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
      value: (inst) => {
        if (params?.Parent && inst instanceof params.Parent)
          return true;
        return inst?._zod?.traits?.has(name);
      }
    });
    Object.defineProperty(_, "name", { value: name });
    return _;
  }
  function config(newConfig) {
    if (newConfig)
      Object.assign(globalConfig, newConfig);
    return globalConfig;
  }
  var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
  var init_core = __esm({
    "node_modules/zod/v4/core/core.js"() {
      NEVER = Object.freeze({
        status: "aborted"
      });
      $brand = /* @__PURE__ */ Symbol("zod_brand");
      $ZodAsyncError = class extends Error {
        constructor() {
          super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
        }
      };
      $ZodEncodeError = class extends Error {
        constructor(name) {
          super(`Encountered unidirectional transform during encode: ${name}`);
          this.name = "ZodEncodeError";
        }
      };
      globalConfig = {};
    }
  });

  // node_modules/zod/v4/core/util.js
  var util_exports = {};
  __export(util_exports, {
    BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
    Class: () => Class,
    NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
    aborted: () => aborted,
    allowsEval: () => allowsEval,
    assert: () => assert,
    assertEqual: () => assertEqual,
    assertIs: () => assertIs,
    assertNever: () => assertNever,
    assertNotEqual: () => assertNotEqual,
    assignProp: () => assignProp,
    base64ToUint8Array: () => base64ToUint8Array,
    base64urlToUint8Array: () => base64urlToUint8Array,
    cached: () => cached,
    captureStackTrace: () => captureStackTrace,
    cleanEnum: () => cleanEnum,
    cleanRegex: () => cleanRegex,
    clone: () => clone,
    cloneDef: () => cloneDef,
    createTransparentProxy: () => createTransparentProxy,
    defineLazy: () => defineLazy,
    esc: () => esc,
    escapeRegex: () => escapeRegex,
    extend: () => extend,
    finalizeIssue: () => finalizeIssue,
    floatSafeRemainder: () => floatSafeRemainder,
    getElementAtPath: () => getElementAtPath,
    getEnumValues: () => getEnumValues,
    getLengthableOrigin: () => getLengthableOrigin,
    getParsedType: () => getParsedType,
    getSizableOrigin: () => getSizableOrigin,
    hexToUint8Array: () => hexToUint8Array,
    isObject: () => isObject,
    isPlainObject: () => isPlainObject,
    issue: () => issue,
    joinValues: () => joinValues,
    jsonStringifyReplacer: () => jsonStringifyReplacer,
    merge: () => merge,
    mergeDefs: () => mergeDefs,
    normalizeParams: () => normalizeParams,
    nullish: () => nullish,
    numKeys: () => numKeys,
    objectClone: () => objectClone,
    omit: () => omit,
    optionalKeys: () => optionalKeys,
    parsedType: () => parsedType,
    partial: () => partial,
    pick: () => pick,
    prefixIssues: () => prefixIssues,
    primitiveTypes: () => primitiveTypes,
    promiseAllObject: () => promiseAllObject,
    propertyKeyTypes: () => propertyKeyTypes,
    randomString: () => randomString,
    required: () => required,
    safeExtend: () => safeExtend,
    shallowClone: () => shallowClone,
    slugify: () => slugify,
    stringifyPrimitive: () => stringifyPrimitive,
    uint8ArrayToBase64: () => uint8ArrayToBase64,
    uint8ArrayToBase64url: () => uint8ArrayToBase64url,
    uint8ArrayToHex: () => uint8ArrayToHex,
    unwrapMessage: () => unwrapMessage
  });
  function assertEqual(val) {
    return val;
  }
  function assertNotEqual(val) {
    return val;
  }
  function assertIs(_arg) {
  }
  function assertNever(_x) {
    throw new Error("Unexpected value in exhaustive check");
  }
  function assert(_) {
  }
  function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
    return values;
  }
  function joinValues(array2, separator = "|") {
    return array2.map((val) => stringifyPrimitive(val)).join(separator);
  }
  function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  }
  function cached(getter) {
    const set2 = false;
    return {
      get value() {
        if (!set2) {
          const value = getter();
          Object.defineProperty(this, "value", { value });
          return value;
        }
        throw new Error("cached value already set");
      }
    };
  }
  function nullish(input) {
    return input === null || input === void 0;
  }
  function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
      const match = stepString.match(/\d?e-(\d?)/);
      if (match?.[1]) {
        stepDecCount = Number.parseInt(match[1]);
      }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  function defineLazy(object2, key, getter) {
    let value = void 0;
    Object.defineProperty(object2, key, {
      get() {
        if (value === EVALUATING) {
          return void 0;
        }
        if (value === void 0) {
          value = EVALUATING;
          value = getter();
        }
        return value;
      },
      set(v) {
        Object.defineProperty(object2, key, {
          value: v
          // configurable: true,
        });
      },
      configurable: true
    });
  }
  function objectClone(obj) {
    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
  }
  function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
  }
  function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
      const descriptors = Object.getOwnPropertyDescriptors(def);
      Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
  }
  function cloneDef(schema) {
    return mergeDefs(schema._zod.def);
  }
  function getElementAtPath(obj, path) {
    if (!path)
      return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
  }
  function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
      const resolvedObj = {};
      for (let i = 0; i < keys.length; i++) {
        resolvedObj[keys[i]] = results[i];
      }
      return resolvedObj;
    });
  }
  function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
      str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
  }
  function esc(str) {
    return JSON.stringify(str);
  }
  function slugify(input) {
    return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
  }
  function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
  }
  function isPlainObject(o) {
    if (isObject(o) === false)
      return false;
    const ctor = o.constructor;
    if (ctor === void 0)
      return true;
    if (typeof ctor !== "function")
      return true;
    const prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  function shallowClone(o) {
    if (isPlainObject(o))
      return { ...o };
    if (Array.isArray(o))
      return [...o];
    return o;
  }
  function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        keyCount++;
      }
    }
    return keyCount;
  }
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
      cl._zod.parent = inst;
    return cl;
  }
  function normalizeParams(_params) {
    const params = _params;
    if (!params)
      return {};
    if (typeof params === "string")
      return { error: () => params };
    if (params?.message !== void 0) {
      if (params?.error !== void 0)
        throw new Error("Cannot specify both `message` and `error` params");
      params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
      return { ...params, error: () => params.error };
    return params;
  }
  function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
      get(_, prop, receiver) {
        target ?? (target = getter());
        return Reflect.get(target, prop, receiver);
      },
      set(_, prop, value, receiver) {
        target ?? (target = getter());
        return Reflect.set(target, prop, value, receiver);
      },
      has(_, prop) {
        target ?? (target = getter());
        return Reflect.has(target, prop);
      },
      deleteProperty(_, prop) {
        target ?? (target = getter());
        return Reflect.deleteProperty(target, prop);
      },
      ownKeys(_) {
        target ?? (target = getter());
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(_, prop) {
        target ?? (target = getter());
        return Reflect.getOwnPropertyDescriptor(target, prop);
      },
      defineProperty(_, prop, descriptor) {
        target ?? (target = getter());
        return Reflect.defineProperty(target, prop, descriptor);
      }
    });
  }
  function stringifyPrimitive(value) {
    if (typeof value === "bigint")
      return value.toString() + "n";
    if (typeof value === "string")
      return `"${value}"`;
    return `${value}`;
  }
  function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
      return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
  }
  function pick(schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".pick() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = {};
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          newShape[key] = currDef.shape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function omit(schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".omit() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = { ...schema._zod.def.shape };
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          delete newShape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function extend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      const existingShape = schema._zod.def.shape;
      for (const key in shape) {
        if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
          throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
        }
      }
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      }
    });
    return clone(schema, def);
  }
  function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      }
    });
    return clone(schema, def);
  }
  function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
      get shape() {
        const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
        assignProp(this, "shape", _shape);
        return _shape;
      },
      get catchall() {
        return b._zod.def.catchall;
      },
      checks: []
      // delete existing checks
    });
    return clone(a, def);
  }
  function partial(Class2, schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".partial() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in oldShape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        } else {
          for (const key in oldShape) {
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function required(Class2, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in shape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        } else {
          for (const key in oldShape) {
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      }
    });
    return clone(schema, def);
  }
  function aborted(x, startIndex = 0) {
    if (x.aborted === true)
      return true;
    for (let i = startIndex; i < x.issues.length; i++) {
      if (x.issues[i]?.continue !== true) {
        return true;
      }
    }
    return false;
  }
  function prefixIssues(path, issues) {
    return issues.map((iss) => {
      var _a2;
      (_a2 = iss).path ?? (_a2.path = []);
      iss.path.unshift(path);
      return iss;
    });
  }
  function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
  }
  function finalizeIssue(iss, ctx, config2) {
    const full = { ...iss, path: iss.path ?? [] };
    if (!iss.message) {
      const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
      full.message = message;
    }
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
      delete full.input;
    }
    return full;
  }
  function getSizableOrigin(input) {
    if (input instanceof Set)
      return "set";
    if (input instanceof Map)
      return "map";
    if (input instanceof File)
      return "file";
    return "unknown";
  }
  function getLengthableOrigin(input) {
    if (Array.isArray(input))
      return "array";
    if (typeof input === "string")
      return "string";
    return "unknown";
  }
  function parsedType(data) {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "nan" : "number";
      }
      case "object": {
        if (data === null) {
          return "null";
        }
        if (Array.isArray(data)) {
          return "array";
        }
        const obj = data;
        if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
          return obj.constructor.name;
        }
      }
    }
    return t;
  }
  function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
      return {
        message: iss,
        code: "custom",
        input,
        inst
      };
    }
    return { ...iss };
  }
  function cleanEnum(obj) {
    return Object.entries(obj).filter(([k, _]) => {
      return Number.isNaN(Number.parseInt(k, 10));
    }).map((el) => el[1]);
  }
  function base64ToUint8Array(base643) {
    const binaryString = atob(base643);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
  function uint8ArrayToBase64(bytes) {
    let binaryString = "";
    for (let i = 0; i < bytes.length; i++) {
      binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
  }
  function base64urlToUint8Array(base64url3) {
    const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
    const padding = "=".repeat((4 - base643.length % 4) % 4);
    return base64ToUint8Array(base643 + padding);
  }
  function uint8ArrayToBase64url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function hexToUint8Array(hex3) {
    const cleanHex = hex3.replace(/^0x/, "");
    if (cleanHex.length % 2 !== 0) {
      throw new Error("Invalid hex string length");
    }
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
      bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
    }
    return bytes;
  }
  function uint8ArrayToHex(bytes) {
    return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  var EVALUATING, captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
  var init_util = __esm({
    "node_modules/zod/v4/core/util.js"() {
      EVALUATING = /* @__PURE__ */ Symbol("evaluating");
      captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
      };
      allowsEval = cached(() => {
        if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
          return false;
        }
        try {
          const F = Function;
          new F("");
          return true;
        } catch (_) {
          return false;
        }
      });
      getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return "undefined";
          case "string":
            return "string";
          case "number":
            return Number.isNaN(data) ? "nan" : "number";
          case "boolean":
            return "boolean";
          case "function":
            return "function";
          case "bigint":
            return "bigint";
          case "symbol":
            return "symbol";
          case "object":
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return "promise";
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return "map";
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return "set";
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return "date";
            }
            if (typeof File !== "undefined" && data instanceof File) {
              return "file";
            }
            return "object";
          default:
            throw new Error(`Unknown data type: ${t}`);
        }
      };
      propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
      primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
      NUMBER_FORMAT_RANGES = {
        safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
        int32: [-2147483648, 2147483647],
        uint32: [0, 4294967295],
        float32: [-34028234663852886e22, 34028234663852886e22],
        float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
      };
      BIGINT_FORMAT_RANGES = {
        int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
        uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
      };
      Class = class {
        constructor(..._args) {
        }
      };
    }
  });

  // node_modules/zod/v4/core/errors.js
  function flattenError(error48, mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error48.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  function formatError(error48, mapper = (issue2) => issue2.message) {
    const fieldErrors = { _errors: [] };
    const processError = (error49) => {
      for (const issue2 of error49.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues });
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues });
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(error48);
    return fieldErrors;
  }
  function treeifyError(error48, mapper = (issue2) => issue2.message) {
    const result = { errors: [] };
    const processError = (error49, path = []) => {
      var _a2, _b;
      for (const issue2 of error49.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }, issue2.path));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues }, issue2.path);
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues }, issue2.path);
        } else {
          const fullpath = [...path, ...issue2.path];
          if (fullpath.length === 0) {
            result.errors.push(mapper(issue2));
            continue;
          }
          let curr = result;
          let i = 0;
          while (i < fullpath.length) {
            const el = fullpath[i];
            const terminal = i === fullpath.length - 1;
            if (typeof el === "string") {
              curr.properties ?? (curr.properties = {});
              (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
              curr = curr.properties[el];
            } else {
              curr.items ?? (curr.items = []);
              (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
              curr = curr.items[el];
            }
            if (terminal) {
              curr.errors.push(mapper(issue2));
            }
            i++;
          }
        }
      }
    };
    processError(error48);
    return result;
  }
  function toDotPath(_path) {
    const segs = [];
    const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
    for (const seg of path) {
      if (typeof seg === "number")
        segs.push(`[${seg}]`);
      else if (typeof seg === "symbol")
        segs.push(`[${JSON.stringify(String(seg))}]`);
      else if (/[^\w$]/.test(seg))
        segs.push(`[${JSON.stringify(seg)}]`);
      else {
        if (segs.length)
          segs.push(".");
        segs.push(seg);
      }
    }
    return segs.join("");
  }
  function prettifyError(error48) {
    const lines = [];
    const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
    for (const issue2 of issues) {
      lines.push(`\u2716 ${issue2.message}`);
      if (issue2.path?.length)
        lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
    }
    return lines.join("\n");
  }
  var initializer, $ZodError, $ZodRealError;
  var init_errors = __esm({
    "node_modules/zod/v4/core/errors.js"() {
      init_core();
      init_util();
      initializer = (inst, def) => {
        inst.name = "$ZodError";
        Object.defineProperty(inst, "_zod", {
          value: inst._zod,
          enumerable: false
        });
        Object.defineProperty(inst, "issues", {
          value: def,
          enumerable: false
        });
        inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
        Object.defineProperty(inst, "toString", {
          value: () => inst.message,
          enumerable: false
        });
      };
      $ZodError = $constructor("$ZodError", initializer);
      $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
    }
  });

  // node_modules/zod/v4/core/parse.js
  var _parse, parse, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync, _encode, encode, _decode, decode, _encodeAsync, encodeAsync, _decodeAsync, decodeAsync, _safeEncode, safeEncode, _safeDecode, safeDecode, _safeEncodeAsync, safeEncodeAsync, _safeDecodeAsync, safeDecodeAsync;
  var init_parse = __esm({
    "node_modules/zod/v4/core/parse.js"() {
      init_core();
      init_errors();
      init_util();
      _parse = (_Err) => (schema, value, _ctx, _params) => {
        const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
        const result = schema._zod.run({ value, issues: [] }, ctx);
        if (result instanceof Promise) {
          throw new $ZodAsyncError();
        }
        if (result.issues.length) {
          const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
          captureStackTrace(e, _params?.callee);
          throw e;
        }
        return result.value;
      };
      parse = /* @__PURE__ */ _parse($ZodRealError);
      _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
        const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
        let result = schema._zod.run({ value, issues: [] }, ctx);
        if (result instanceof Promise)
          result = await result;
        if (result.issues.length) {
          const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
          captureStackTrace(e, params?.callee);
          throw e;
        }
        return result.value;
      };
      parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
      _safeParse = (_Err) => (schema, value, _ctx) => {
        const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
        const result = schema._zod.run({ value, issues: [] }, ctx);
        if (result instanceof Promise) {
          throw new $ZodAsyncError();
        }
        return result.issues.length ? {
          success: false,
          error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
        } : { success: true, data: result.value };
      };
      safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
      _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
        const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
        let result = schema._zod.run({ value, issues: [] }, ctx);
        if (result instanceof Promise)
          result = await result;
        return result.issues.length ? {
          success: false,
          error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
        } : { success: true, data: result.value };
      };
      safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
      _encode = (_Err) => (schema, value, _ctx) => {
        const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
        return _parse(_Err)(schema, value, ctx);
      };
      encode = /* @__PURE__ */ _encode($ZodRealError);
      _decode = (_Err) => (schema, value, _ctx) => {
        return _parse(_Err)(schema, value, _ctx);
      };
      decode = /* @__PURE__ */ _decode($ZodRealError);
      _encodeAsync = (_Err) => async (schema, value, _ctx) => {
        const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
        return _parseAsync(_Err)(schema, value, ctx);
      };
      encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
      _decodeAsync = (_Err) => async (schema, value, _ctx) => {
        return _parseAsync(_Err)(schema, value, _ctx);
      };
      decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
      _safeEncode = (_Err) => (schema, value, _ctx) => {
        const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
        return _safeParse(_Err)(schema, value, ctx);
      };
      safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
      _safeDecode = (_Err) => (schema, value, _ctx) => {
        return _safeParse(_Err)(schema, value, _ctx);
      };
      safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
      _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
        const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
        return _safeParseAsync(_Err)(schema, value, ctx);
      };
      safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
      _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
        return _safeParseAsync(_Err)(schema, value, _ctx);
      };
      safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
    }
  });

  // node_modules/zod/v4/core/regexes.js
  var regexes_exports = {};
  __export(regexes_exports, {
    base64: () => base64,
    base64url: () => base64url,
    bigint: () => bigint,
    boolean: () => boolean,
    browserEmail: () => browserEmail,
    cidrv4: () => cidrv4,
    cidrv6: () => cidrv6,
    cuid: () => cuid,
    cuid2: () => cuid2,
    date: () => date,
    datetime: () => datetime,
    domain: () => domain,
    duration: () => duration,
    e164: () => e164,
    email: () => email,
    emoji: () => emoji,
    extendedDuration: () => extendedDuration,
    guid: () => guid,
    hex: () => hex,
    hostname: () => hostname,
    html5Email: () => html5Email,
    idnEmail: () => idnEmail,
    integer: () => integer,
    ipv4: () => ipv4,
    ipv6: () => ipv6,
    ksuid: () => ksuid,
    lowercase: () => lowercase,
    mac: () => mac,
    md5_base64: () => md5_base64,
    md5_base64url: () => md5_base64url,
    md5_hex: () => md5_hex,
    nanoid: () => nanoid,
    null: () => _null,
    number: () => number,
    rfc5322Email: () => rfc5322Email,
    sha1_base64: () => sha1_base64,
    sha1_base64url: () => sha1_base64url,
    sha1_hex: () => sha1_hex,
    sha256_base64: () => sha256_base64,
    sha256_base64url: () => sha256_base64url,
    sha256_hex: () => sha256_hex,
    sha384_base64: () => sha384_base64,
    sha384_base64url: () => sha384_base64url,
    sha384_hex: () => sha384_hex,
    sha512_base64: () => sha512_base64,
    sha512_base64url: () => sha512_base64url,
    sha512_hex: () => sha512_hex,
    string: () => string,
    time: () => time,
    ulid: () => ulid,
    undefined: () => _undefined,
    unicodeEmail: () => unicodeEmail,
    uppercase: () => uppercase,
    uuid: () => uuid,
    uuid4: () => uuid4,
    uuid6: () => uuid6,
    uuid7: () => uuid7,
    xid: () => xid
  });
  function emoji() {
    return new RegExp(_emoji, "u");
  }
  function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
  }
  function time(args) {
    return new RegExp(`^${timeSource(args)}$`);
  }
  function datetime(args) {
    const time3 = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
      opts.push("");
    if (args.offset)
      opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex = `${time3}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
  }
  function fixedBase64(bodyLength, padding) {
    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
  }
  function fixedBase64url(length) {
    return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
  }
  var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji, ipv4, ipv6, mac, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource, date, string, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
  var init_regexes = __esm({
    "node_modules/zod/v4/core/regexes.js"() {
      init_util();
      cuid = /^[cC][^\s-]{8,}$/;
      cuid2 = /^[0-9a-z]+$/;
      ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
      xid = /^[0-9a-vA-V]{20}$/;
      ksuid = /^[A-Za-z0-9]{27}$/;
      nanoid = /^[a-zA-Z0-9_-]{21}$/;
      duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
      extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
      guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
      uuid = (version2) => {
        if (!version2)
          return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
        return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
      };
      uuid4 = /* @__PURE__ */ uuid(4);
      uuid6 = /* @__PURE__ */ uuid(6);
      uuid7 = /* @__PURE__ */ uuid(7);
      email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
      html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
      rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
      idnEmail = unicodeEmail;
      browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
      _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
      ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
      ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
      mac = (delimiter) => {
        const escapedDelim = escapeRegex(delimiter ?? ":");
        return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
      };
      cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
      cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
      base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
      base64url = /^[A-Za-z0-9_-]*$/;
      hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
      domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
      e164 = /^\+[1-9]\d{6,14}$/;
      dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
      date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
      string = (params) => {
        const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
        return new RegExp(`^${regex}$`);
      };
      bigint = /^-?\d+n?$/;
      integer = /^-?\d+$/;
      number = /^-?\d+(?:\.\d+)?$/;
      boolean = /^(?:true|false)$/i;
      _null = /^null$/i;
      _undefined = /^undefined$/i;
      lowercase = /^[^A-Z]*$/;
      uppercase = /^[^a-z]*$/;
      hex = /^[0-9a-fA-F]*$/;
      md5_hex = /^[0-9a-fA-F]{32}$/;
      md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
      md5_base64url = /* @__PURE__ */ fixedBase64url(22);
      sha1_hex = /^[0-9a-fA-F]{40}$/;
      sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
      sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
      sha256_hex = /^[0-9a-fA-F]{64}$/;
      sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
      sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
      sha384_hex = /^[0-9a-fA-F]{96}$/;
      sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
      sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
      sha512_hex = /^[0-9a-fA-F]{128}$/;
      sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
      sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
    }
  });

  // node_modules/zod/v4/core/checks.js
  function handleCheckPropertyResult(result, payload, property) {
    if (result.issues.length) {
      payload.issues.push(...prefixIssues(property, result.issues));
    }
  }
  var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
  var init_checks = __esm({
    "node_modules/zod/v4/core/checks.js"() {
      init_core();
      init_regexes();
      init_util();
      $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
        var _a2;
        inst._zod ?? (inst._zod = {});
        inst._zod.def = def;
        (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
      });
      numericOriginMap = {
        number: "number",
        bigint: "bigint",
        object: "date"
      };
      $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
        $ZodCheck.init(inst, def);
        const origin = numericOriginMap[typeof def.value];
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
          if (def.value < curr) {
            if (def.inclusive)
              bag.maximum = def.value;
            else
              bag.exclusiveMaximum = def.value;
          }
        });
        inst._zod.check = (payload) => {
          if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
            return;
          }
          payload.issues.push({
            origin,
            code: "too_big",
            maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
        $ZodCheck.init(inst, def);
        const origin = numericOriginMap[typeof def.value];
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
          if (def.value > curr) {
            if (def.inclusive)
              bag.minimum = def.value;
            else
              bag.exclusiveMinimum = def.value;
          }
        });
        inst._zod.check = (payload) => {
          if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
            return;
          }
          payload.issues.push({
            origin,
            code: "too_small",
            minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
        $ZodCheck.init(inst, def);
        inst._zod.onattach.push((inst2) => {
          var _a2;
          (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
        });
        inst._zod.check = (payload) => {
          if (typeof payload.value !== typeof def.value)
            throw new Error("Cannot mix number and bigint in multiple_of check.");
          const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
          if (isMultiple)
            return;
          payload.issues.push({
            origin: typeof payload.value,
            code: "not_multiple_of",
            divisor: def.value,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
        $ZodCheck.init(inst, def);
        def.format = def.format || "float64";
        const isInt = def.format?.includes("int");
        const origin = isInt ? "int" : "number";
        const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.format = def.format;
          bag.minimum = minimum;
          bag.maximum = maximum;
          if (isInt)
            bag.pattern = integer;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          if (isInt) {
            if (!Number.isInteger(input)) {
              payload.issues.push({
                expected: origin,
                format: def.format,
                code: "invalid_type",
                continue: false,
                input,
                inst
              });
              return;
            }
            if (!Number.isSafeInteger(input)) {
              if (input > 0) {
                payload.issues.push({
                  input,
                  code: "too_big",
                  maximum: Number.MAX_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst,
                  origin,
                  inclusive: true,
                  continue: !def.abort
                });
              } else {
                payload.issues.push({
                  input,
                  code: "too_small",
                  minimum: Number.MIN_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst,
                  origin,
                  inclusive: true,
                  continue: !def.abort
                });
              }
              return;
            }
          }
          if (input < minimum) {
            payload.issues.push({
              origin: "number",
              input,
              code: "too_small",
              minimum,
              inclusive: true,
              inst,
              continue: !def.abort
            });
          }
          if (input > maximum) {
            payload.issues.push({
              origin: "number",
              input,
              code: "too_big",
              maximum,
              inclusive: true,
              inst,
              continue: !def.abort
            });
          }
        };
      });
      $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
        $ZodCheck.init(inst, def);
        const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.format = def.format;
          bag.minimum = minimum;
          bag.maximum = maximum;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          if (input < minimum) {
            payload.issues.push({
              origin: "bigint",
              input,
              code: "too_small",
              minimum,
              inclusive: true,
              inst,
              continue: !def.abort
            });
          }
          if (input > maximum) {
            payload.issues.push({
              origin: "bigint",
              input,
              code: "too_big",
              maximum,
              inclusive: true,
              inst,
              continue: !def.abort
            });
          }
        };
      });
      $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
        var _a2;
        $ZodCheck.init(inst, def);
        (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
          const val = payload.value;
          return !nullish(val) && val.size !== void 0;
        });
        inst._zod.onattach.push((inst2) => {
          const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
          if (def.maximum < curr)
            inst2._zod.bag.maximum = def.maximum;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          const size = input.size;
          if (size <= def.maximum)
            return;
          payload.issues.push({
            origin: getSizableOrigin(input),
            code: "too_big",
            maximum: def.maximum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
        var _a2;
        $ZodCheck.init(inst, def);
        (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
          const val = payload.value;
          return !nullish(val) && val.size !== void 0;
        });
        inst._zod.onattach.push((inst2) => {
          const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
          if (def.minimum > curr)
            inst2._zod.bag.minimum = def.minimum;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          const size = input.size;
          if (size >= def.minimum)
            return;
          payload.issues.push({
            origin: getSizableOrigin(input),
            code: "too_small",
            minimum: def.minimum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
        var _a2;
        $ZodCheck.init(inst, def);
        (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
          const val = payload.value;
          return !nullish(val) && val.size !== void 0;
        });
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.minimum = def.size;
          bag.maximum = def.size;
          bag.size = def.size;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          const size = input.size;
          if (size === def.size)
            return;
          const tooBig = size > def.size;
          payload.issues.push({
            origin: getSizableOrigin(input),
            ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
            inclusive: true,
            exact: true,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
        var _a2;
        $ZodCheck.init(inst, def);
        (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
          const val = payload.value;
          return !nullish(val) && val.length !== void 0;
        });
        inst._zod.onattach.push((inst2) => {
          const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
          if (def.maximum < curr)
            inst2._zod.bag.maximum = def.maximum;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          const length = input.length;
          if (length <= def.maximum)
            return;
          const origin = getLengthableOrigin(input);
          payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.maximum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
        var _a2;
        $ZodCheck.init(inst, def);
        (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
          const val = payload.value;
          return !nullish(val) && val.length !== void 0;
        });
        inst._zod.onattach.push((inst2) => {
          const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
          if (def.minimum > curr)
            inst2._zod.bag.minimum = def.minimum;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          const length = input.length;
          if (length >= def.minimum)
            return;
          const origin = getLengthableOrigin(input);
          payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.minimum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
        var _a2;
        $ZodCheck.init(inst, def);
        (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
          const val = payload.value;
          return !nullish(val) && val.length !== void 0;
        });
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.minimum = def.length;
          bag.maximum = def.length;
          bag.length = def.length;
        });
        inst._zod.check = (payload) => {
          const input = payload.value;
          const length = input.length;
          if (length === def.length)
            return;
          const origin = getLengthableOrigin(input);
          const tooBig = length > def.length;
          payload.issues.push({
            origin,
            ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
            inclusive: true,
            exact: true,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
        var _a2, _b;
        $ZodCheck.init(inst, def);
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.format = def.format;
          if (def.pattern) {
            bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
            bag.patterns.add(def.pattern);
          }
        });
        if (def.pattern)
          (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
            def.pattern.lastIndex = 0;
            if (def.pattern.test(payload.value))
              return;
            payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: def.format,
              input: payload.value,
              ...def.pattern ? { pattern: def.pattern.toString() } : {},
              inst,
              continue: !def.abort
            });
          });
        else
          (_b = inst._zod).check ?? (_b.check = () => {
          });
      });
      $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
        $ZodCheckStringFormat.init(inst, def);
        inst._zod.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "regex",
            input: payload.value,
            pattern: def.pattern.toString(),
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
        def.pattern ?? (def.pattern = lowercase);
        $ZodCheckStringFormat.init(inst, def);
      });
      $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
        def.pattern ?? (def.pattern = uppercase);
        $ZodCheckStringFormat.init(inst, def);
      });
      $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
        $ZodCheck.init(inst, def);
        const escapedRegex = escapeRegex(def.includes);
        const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
        def.pattern = pattern;
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(pattern);
        });
        inst._zod.check = (payload) => {
          if (payload.value.includes(def.includes, def.position))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: def.includes,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
        $ZodCheck.init(inst, def);
        const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
        def.pattern ?? (def.pattern = pattern);
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(pattern);
        });
        inst._zod.check = (payload) => {
          if (payload.value.startsWith(def.prefix))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: def.prefix,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
        $ZodCheck.init(inst, def);
        const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
        def.pattern ?? (def.pattern = pattern);
        inst._zod.onattach.push((inst2) => {
          const bag = inst2._zod.bag;
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(pattern);
        });
        inst._zod.check = (payload) => {
          if (payload.value.endsWith(def.suffix))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: def.suffix,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
        $ZodCheck.init(inst, def);
        inst._zod.check = (payload) => {
          const result = def.schema._zod.run({
            value: payload.value[def.property],
            issues: []
          }, {});
          if (result instanceof Promise) {
            return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
          }
          handleCheckPropertyResult(result, payload, def.property);
          return;
        };
      });
      $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
        $ZodCheck.init(inst, def);
        const mimeSet = new Set(def.mime);
        inst._zod.onattach.push((inst2) => {
          inst2._zod.bag.mime = def.mime;
        });
        inst._zod.check = (payload) => {
          if (mimeSet.has(payload.value.type))
            return;
          payload.issues.push({
            code: "invalid_value",
            values: def.mime,
            input: payload.value.type,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
        $ZodCheck.init(inst, def);
        inst._zod.check = (payload) => {
          payload.value = def.tx(payload.value);
        };
      });
    }
  });

  // node_modules/zod/v4/core/doc.js
  var Doc;
  var init_doc = __esm({
    "node_modules/zod/v4/core/doc.js"() {
      Doc = class {
        constructor(args = []) {
          this.content = [];
          this.indent = 0;
          if (this)
            this.args = args;
        }
        indented(fn) {
          this.indent += 1;
          fn(this);
          this.indent -= 1;
        }
        write(arg) {
          if (typeof arg === "function") {
            arg(this, { execution: "sync" });
            arg(this, { execution: "async" });
            return;
          }
          const content = arg;
          const lines = content.split("\n").filter((x) => x);
          const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
          const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
          for (const line of dedented) {
            this.content.push(line);
          }
        }
        compile() {
          const F = Function;
          const args = this?.args;
          const content = this?.content ?? [``];
          const lines = [...content.map((x) => `  ${x}`)];
          return new F(...args, lines.join("\n"));
        }
      };
    }
  });

  // node_modules/zod/v4/core/versions.js
  var version;
  var init_versions = __esm({
    "node_modules/zod/v4/core/versions.js"() {
      version = {
        major: 4,
        minor: 3,
        patch: 6
      };
    }
  });

  // node_modules/zod/v4/core/schemas.js
  function isValidBase64(data) {
    if (data === "")
      return true;
    if (data.length % 4 !== 0)
      return false;
    try {
      atob(data);
      return true;
    } catch {
      return false;
    }
  }
  function isValidBase64URL(data) {
    if (!base64url.test(data))
      return false;
    const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
    const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
    return isValidBase64(padded);
  }
  function isValidJWT(token, algorithm = null) {
    try {
      const tokensParts = token.split(".");
      if (tokensParts.length !== 3)
        return false;
      const [header] = tokensParts;
      if (!header)
        return false;
      const parsedHeader = JSON.parse(atob(header));
      if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
        return false;
      if (!parsedHeader.alg)
        return false;
      if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function handleArrayResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  function handlePropertyResult(result, final, key, input, isOptionalOut) {
    if (result.issues.length) {
      if (isOptionalOut && !(key in input)) {
        return;
      }
      final.issues.push(...prefixIssues(key, result.issues));
    }
    if (result.value === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      }
    } else {
      final.value[key] = result.value;
    }
  }
  function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      ...def,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  }
  function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    const isOptionalOut = _catchall.optout === "optional";
    for (const key in input) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  }
  function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
      if (result.issues.length === 0) {
        final.value = result.value;
        return final;
      }
    }
    const nonaborted = results.filter((r) => !aborted(r));
    if (nonaborted.length === 1) {
      final.value = nonaborted[0].value;
      return nonaborted[0];
    }
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
    return final;
  }
  function handleExclusiveUnionResults(results, final, inst, ctx) {
    const successes = results.filter((r) => r.issues.length === 0);
    if (successes.length === 1) {
      final.value = successes[0].value;
      return final;
    }
    if (successes.length === 0) {
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      });
    } else {
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: [],
        inclusive: false
      });
    }
    return final;
  }
  function mergeValues(a, b) {
    if (a === b) {
      return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
      return { valid: true, data: a };
    }
    if (isPlainObject(a) && isPlainObject(b)) {
      const bKeys = Object.keys(b);
      const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
          };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return { valid: false, mergeErrorPath: [] };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
          };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
  }
  function handleIntersectionResults(result, left, right) {
    const unrecKeys = /* @__PURE__ */ new Map();
    let unrecIssue;
    for (const iss of left.issues) {
      if (iss.code === "unrecognized_keys") {
        unrecIssue ?? (unrecIssue = iss);
        for (const k of iss.keys) {
          if (!unrecKeys.has(k))
            unrecKeys.set(k, {});
          unrecKeys.get(k).l = true;
        }
      } else {
        result.issues.push(iss);
      }
    }
    for (const iss of right.issues) {
      if (iss.code === "unrecognized_keys") {
        for (const k of iss.keys) {
          if (!unrecKeys.has(k))
            unrecKeys.set(k, {});
          unrecKeys.get(k).r = true;
        }
      } else {
        result.issues.push(iss);
      }
    }
    const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
    if (bothKeys.length && unrecIssue) {
      result.issues.push({ ...unrecIssue, keys: bothKeys });
    }
    if (aborted(result))
      return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
      throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
  }
  function handleTupleResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
    if (keyResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, keyResult.issues));
      } else {
        final.issues.push({
          code: "invalid_key",
          origin: "map",
          input,
          inst,
          issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    if (valueResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, valueResult.issues));
      } else {
        final.issues.push({
          origin: "map",
          code: "invalid_element",
          input,
          inst,
          key,
          issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    final.value.set(keyResult.value, valueResult.value);
  }
  function handleSetResult(result, final) {
    if (result.issues.length) {
      final.issues.push(...result.issues);
    }
    final.value.add(result.value);
  }
  function handleOptionalResult(result, input) {
    if (result.issues.length && input === void 0) {
      return { issues: [], value: void 0 };
    }
    return result;
  }
  function handleDefaultResult(payload, def) {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return payload;
  }
  function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === void 0) {
      payload.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: payload.value,
        inst
      });
    }
    return payload;
  }
  function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
  }
  function handleCodecAResult(result, def, ctx) {
    if (result.issues.length) {
      result.aborted = true;
      return result;
    }
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const transformed = def.transform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
      }
      return handleCodecTxResult(result, transformed, def.out, ctx);
    } else {
      const transformed = def.reverseTransform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
      }
      return handleCodecTxResult(result, transformed, def.in, ctx);
    }
  }
  function handleCodecTxResult(left, value, nextSchema, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return nextSchema._zod.run({ value, issues: left.issues }, ctx);
  }
  function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
  }
  function handleRefineResult(result, payload, input, inst) {
    if (!result) {
      const _iss = {
        code: "custom",
        input,
        inst,
        // incorporates params.error into issue reporting
        path: [...inst._zod.def.path ?? []],
        // incorporates params.error into issue reporting
        continue: !inst._zod.def.abort
        // params: inst._zod.def.params,
      };
      if (inst._zod.def.params)
        _iss.params = inst._zod.def.params;
      payload.issues.push(issue(_iss));
    }
  }
  var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodXor, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodExactOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
  var init_schemas = __esm({
    "node_modules/zod/v4/core/schemas.js"() {
      init_checks();
      init_core();
      init_doc();
      init_parse();
      init_regexes();
      init_util();
      init_versions();
      init_util();
      $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
        var _a2;
        inst ?? (inst = {});
        inst._zod.def = def;
        inst._zod.bag = inst._zod.bag || {};
        inst._zod.version = version;
        const checks = [...inst._zod.def.checks ?? []];
        if (inst._zod.traits.has("$ZodCheck")) {
          checks.unshift(inst);
        }
        for (const ch of checks) {
          for (const fn of ch._zod.onattach) {
            fn(inst);
          }
        }
        if (checks.length === 0) {
          (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
          inst._zod.deferred?.push(() => {
            inst._zod.run = inst._zod.parse;
          });
        } else {
          const runChecks = (payload, checks2, ctx) => {
            let isAborted = aborted(payload);
            let asyncResult;
            for (const ch of checks2) {
              if (ch._zod.def.when) {
                const shouldRun = ch._zod.def.when(payload);
                if (!shouldRun)
                  continue;
              } else if (isAborted) {
                continue;
              }
              const currLen = payload.issues.length;
              const _ = ch._zod.check(payload);
              if (_ instanceof Promise && ctx?.async === false) {
                throw new $ZodAsyncError();
              }
              if (asyncResult || _ instanceof Promise) {
                asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                  await _;
                  const nextLen = payload.issues.length;
                  if (nextLen === currLen)
                    return;
                  if (!isAborted)
                    isAborted = aborted(payload, currLen);
                });
              } else {
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  continue;
                if (!isAborted)
                  isAborted = aborted(payload, currLen);
              }
            }
            if (asyncResult) {
              return asyncResult.then(() => {
                return payload;
              });
            }
            return payload;
          };
          const handleCanaryResult = (canary, payload, ctx) => {
            if (aborted(canary)) {
              canary.aborted = true;
              return canary;
            }
            const checkResult = runChecks(payload, checks, ctx);
            if (checkResult instanceof Promise) {
              if (ctx.async === false)
                throw new $ZodAsyncError();
              return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
            }
            return inst._zod.parse(checkResult, ctx);
          };
          inst._zod.run = (payload, ctx) => {
            if (ctx.skipChecks) {
              return inst._zod.parse(payload, ctx);
            }
            if (ctx.direction === "backward") {
              const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
              if (canary instanceof Promise) {
                return canary.then((canary2) => {
                  return handleCanaryResult(canary2, payload, ctx);
                });
              }
              return handleCanaryResult(canary, payload, ctx);
            }
            const result = inst._zod.parse(payload, ctx);
            if (result instanceof Promise) {
              if (ctx.async === false)
                throw new $ZodAsyncError();
              return result.then((result2) => runChecks(result2, checks, ctx));
            }
            return runChecks(result, checks, ctx);
          };
        }
        defineLazy(inst, "~standard", () => ({
          validate: (value) => {
            try {
              const r = safeParse(inst, value);
              return r.success ? { value: r.data } : { issues: r.error?.issues };
            } catch (_) {
              return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
            }
          },
          vendor: "zod",
          version: 1
        }));
      });
      $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
        inst._zod.parse = (payload, _) => {
          if (def.coerce)
            try {
              payload.value = String(payload.value);
            } catch (_2) {
            }
          if (typeof payload.value === "string")
            return payload;
          payload.issues.push({
            expected: "string",
            code: "invalid_type",
            input: payload.value,
            inst
          });
          return payload;
        };
      });
      $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
        $ZodCheckStringFormat.init(inst, def);
        $ZodString.init(inst, def);
      });
      $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
        def.pattern ?? (def.pattern = guid);
        $ZodStringFormat.init(inst, def);
      });
      $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
        if (def.version) {
          const versionMap = {
            v1: 1,
            v2: 2,
            v3: 3,
            v4: 4,
            v5: 5,
            v6: 6,
            v7: 7,
            v8: 8
          };
          const v = versionMap[def.version];
          if (v === void 0)
            throw new Error(`Invalid UUID version: "${def.version}"`);
          def.pattern ?? (def.pattern = uuid(v));
        } else
          def.pattern ?? (def.pattern = uuid());
        $ZodStringFormat.init(inst, def);
      });
      $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
        def.pattern ?? (def.pattern = email);
        $ZodStringFormat.init(inst, def);
      });
      $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
        $ZodStringFormat.init(inst, def);
        inst._zod.check = (payload) => {
          try {
            const trimmed = payload.value.trim();
            const url2 = new URL(trimmed);
            if (def.hostname) {
              def.hostname.lastIndex = 0;
              if (!def.hostname.test(url2.hostname)) {
                payload.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid hostname",
                  pattern: def.hostname.source,
                  input: payload.value,
                  inst,
                  continue: !def.abort
                });
              }
            }
            if (def.protocol) {
              def.protocol.lastIndex = 0;
              if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
                payload.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid protocol",
                  pattern: def.protocol.source,
                  input: payload.value,
                  inst,
                  continue: !def.abort
                });
              }
            }
            if (def.normalize) {
              payload.value = url2.href;
            } else {
              payload.value = trimmed;
            }
            return;
          } catch (_) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        };
      });
      $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
        def.pattern ?? (def.pattern = emoji());
        $ZodStringFormat.init(inst, def);
      });
      $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
        def.pattern ?? (def.pattern = nanoid);
        $ZodStringFormat.init(inst, def);
      });
      $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
        def.pattern ?? (def.pattern = cuid);
        $ZodStringFormat.init(inst, def);
      });
      $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
        def.pattern ?? (def.pattern = cuid2);
        $ZodStringFormat.init(inst, def);
      });
      $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
        def.pattern ?? (def.pattern = ulid);
        $ZodStringFormat.init(inst, def);
      });
      $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
        def.pattern ?? (def.pattern = xid);
        $ZodStringFormat.init(inst, def);
      });
      $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
        def.pattern ?? (def.pattern = ksuid);
        $ZodStringFormat.init(inst, def);
      });
      $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
        def.pattern ?? (def.pattern = datetime(def));
        $ZodStringFormat.init(inst, def);
      });
      $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
        def.pattern ?? (def.pattern = date);
        $ZodStringFormat.init(inst, def);
      });
      $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
        def.pattern ?? (def.pattern = time(def));
        $ZodStringFormat.init(inst, def);
      });
      $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
        def.pattern ?? (def.pattern = duration);
        $ZodStringFormat.init(inst, def);
      });
      $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
        def.pattern ?? (def.pattern = ipv4);
        $ZodStringFormat.init(inst, def);
        inst._zod.bag.format = `ipv4`;
      });
      $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
        def.pattern ?? (def.pattern = ipv6);
        $ZodStringFormat.init(inst, def);
        inst._zod.bag.format = `ipv6`;
        inst._zod.check = (payload) => {
          try {
            new URL(`http://[${payload.value}]`);
          } catch {
            payload.issues.push({
              code: "invalid_format",
              format: "ipv6",
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        };
      });
      $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
        def.pattern ?? (def.pattern = mac(def.delimiter));
        $ZodStringFormat.init(inst, def);
        inst._zod.bag.format = `mac`;
      });
      $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
        def.pattern ?? (def.pattern = cidrv4);
        $ZodStringFormat.init(inst, def);
      });
      $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
        def.pattern ?? (def.pattern = cidrv6);
        $ZodStringFormat.init(inst, def);
        inst._zod.check = (payload) => {
          const parts = payload.value.split("/");
          try {
            if (parts.length !== 2)
              throw new Error();
            const [address, prefix] = parts;
            if (!prefix)
              throw new Error();
            const prefixNum = Number(prefix);
            if (`${prefixNum}` !== prefix)
              throw new Error();
            if (prefixNum < 0 || prefixNum > 128)
              throw new Error();
            new URL(`http://[${address}]`);
          } catch {
            payload.issues.push({
              code: "invalid_format",
              format: "cidrv6",
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        };
      });
      $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
        def.pattern ?? (def.pattern = base64);
        $ZodStringFormat.init(inst, def);
        inst._zod.bag.contentEncoding = "base64";
        inst._zod.check = (payload) => {
          if (isValidBase64(payload.value))
            return;
          payload.issues.push({
            code: "invalid_format",
            format: "base64",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
        def.pattern ?? (def.pattern = base64url);
        $ZodStringFormat.init(inst, def);
        inst._zod.bag.contentEncoding = "base64url";
        inst._zod.check = (payload) => {
          if (isValidBase64URL(payload.value))
            return;
          payload.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
        def.pattern ?? (def.pattern = e164);
        $ZodStringFormat.init(inst, def);
      });
      $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
        $ZodStringFormat.init(inst, def);
        inst._zod.check = (payload) => {
          if (isValidJWT(payload.value, def.alg))
            return;
          payload.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
        $ZodStringFormat.init(inst, def);
        inst._zod.check = (payload) => {
          if (def.fn(payload.value))
            return;
          payload.issues.push({
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        };
      });
      $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.pattern = inst._zod.bag.pattern ?? number;
        inst._zod.parse = (payload, _ctx) => {
          if (def.coerce)
            try {
              payload.value = Number(payload.value);
            } catch (_) {
            }
          const input = payload.value;
          if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
            return payload;
          }
          const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
          payload.issues.push({
            expected: "number",
            code: "invalid_type",
            input,
            inst,
            ...received ? { received } : {}
          });
          return payload;
        };
      });
      $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
        $ZodCheckNumberFormat.init(inst, def);
        $ZodNumber.init(inst, def);
      });
      $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.pattern = boolean;
        inst._zod.parse = (payload, _ctx) => {
          if (def.coerce)
            try {
              payload.value = Boolean(payload.value);
            } catch (_) {
            }
          const input = payload.value;
          if (typeof input === "boolean")
            return payload;
          payload.issues.push({
            expected: "boolean",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        };
      });
      $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.pattern = bigint;
        inst._zod.parse = (payload, _ctx) => {
          if (def.coerce)
            try {
              payload.value = BigInt(payload.value);
            } catch (_) {
            }
          if (typeof payload.value === "bigint")
            return payload;
          payload.issues.push({
            expected: "bigint",
            code: "invalid_type",
            input: payload.value,
            inst
          });
          return payload;
        };
      });
      $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
        $ZodCheckBigIntFormat.init(inst, def);
        $ZodBigInt.init(inst, def);
      });
      $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (typeof input === "symbol")
            return payload;
          payload.issues.push({
            expected: "symbol",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        };
      });
      $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.pattern = _undefined;
        inst._zod.values = /* @__PURE__ */ new Set([void 0]);
        inst._zod.optin = "optional";
        inst._zod.optout = "optional";
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (typeof input === "undefined")
            return payload;
          payload.issues.push({
            expected: "undefined",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        };
      });
      $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.pattern = _null;
        inst._zod.values = /* @__PURE__ */ new Set([null]);
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (input === null)
            return payload;
          payload.issues.push({
            expected: "null",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        };
      });
      $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload) => payload;
      });
      $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload) => payload;
      });
      $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _ctx) => {
          payload.issues.push({
            expected: "never",
            code: "invalid_type",
            input: payload.value,
            inst
          });
          return payload;
        };
      });
      $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (typeof input === "undefined")
            return payload;
          payload.issues.push({
            expected: "void",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        };
      });
      $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _ctx) => {
          if (def.coerce) {
            try {
              payload.value = new Date(payload.value);
            } catch (_err) {
            }
          }
          const input = payload.value;
          const isDate = input instanceof Date;
          const isValidDate = isDate && !Number.isNaN(input.getTime());
          if (isValidDate)
            return payload;
          payload.issues.push({
            expected: "date",
            code: "invalid_type",
            input,
            ...isDate ? { received: "Invalid Date" } : {},
            inst
          });
          return payload;
        };
      });
      $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!Array.isArray(input)) {
            payload.issues.push({
              expected: "array",
              code: "invalid_type",
              input,
              inst
            });
            return payload;
          }
          payload.value = Array(input.length);
          const proms = [];
          for (let i = 0; i < input.length; i++) {
            const item = input[i];
            const result = def.element._zod.run({
              value: item,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
            } else {
              handleArrayResult(result, payload, i);
            }
          }
          if (proms.length) {
            return Promise.all(proms).then(() => payload);
          }
          return payload;
        };
      });
      $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
        $ZodType.init(inst, def);
        const desc = Object.getOwnPropertyDescriptor(def, "shape");
        if (!desc?.get) {
          const sh = def.shape;
          Object.defineProperty(def, "shape", {
            get: () => {
              const newSh = { ...sh };
              Object.defineProperty(def, "shape", {
                value: newSh
              });
              return newSh;
            }
          });
        }
        const _normalized = cached(() => normalizeDef(def));
        defineLazy(inst._zod, "propValues", () => {
          const shape = def.shape;
          const propValues = {};
          for (const key in shape) {
            const field = shape[key]._zod;
            if (field.values) {
              propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
              for (const v of field.values)
                propValues[key].add(v);
            }
          }
          return propValues;
        });
        const isObject2 = isObject;
        const catchall = def.catchall;
        let value;
        inst._zod.parse = (payload, ctx) => {
          value ?? (value = _normalized.value);
          const input = payload.value;
          if (!isObject2(input)) {
            payload.issues.push({
              expected: "object",
              code: "invalid_type",
              input,
              inst
            });
            return payload;
          }
          payload.value = {};
          const proms = [];
          const shape = value.shape;
          for (const key of value.keys) {
            const el = shape[key];
            const isOptionalOut = el._zod.optout === "optional";
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            if (r instanceof Promise) {
              proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
            } else {
              handlePropertyResult(r, payload, key, input, isOptionalOut);
            }
          }
          if (!catchall) {
            return proms.length ? Promise.all(proms).then(() => payload) : payload;
          }
          return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
        };
      });
      $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
        $ZodObject.init(inst, def);
        const superParse = inst._zod.parse;
        const _normalized = cached(() => normalizeDef(def));
        const generateFastpass = (shape) => {
          const doc = new Doc(["shape", "payload", "ctx"]);
          const normalized = _normalized.value;
          const parseStr = (key) => {
            const k = esc(key);
            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
          };
          doc.write(`const input = payload.value;`);
          const ids = /* @__PURE__ */ Object.create(null);
          let counter = 0;
          for (const key of normalized.keys) {
            ids[key] = `key_${counter++}`;
          }
          doc.write(`const newResult = {};`);
          for (const key of normalized.keys) {
            const id = ids[key];
            const k = esc(key);
            const schema = shape[key];
            const isOptionalOut = schema?._zod?.optout === "optional";
            doc.write(`const ${id} = ${parseStr(key)};`);
            if (isOptionalOut) {
              doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
            } else {
              doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
            }
          }
          doc.write(`payload.value = newResult;`);
          doc.write(`return payload;`);
          const fn = doc.compile();
          return (payload, ctx) => fn(shape, payload, ctx);
        };
        let fastpass;
        const isObject2 = isObject;
        const jit = !globalConfig.jitless;
        const allowsEval2 = allowsEval;
        const fastEnabled = jit && allowsEval2.value;
        const catchall = def.catchall;
        let value;
        inst._zod.parse = (payload, ctx) => {
          value ?? (value = _normalized.value);
          const input = payload.value;
          if (!isObject2(input)) {
            payload.issues.push({
              expected: "object",
              code: "invalid_type",
              input,
              inst
            });
            return payload;
          }
          if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
            if (!fastpass)
              fastpass = generateFastpass(def.shape);
            payload = fastpass(payload, ctx);
            if (!catchall)
              return payload;
            return handleCatchall([], input, payload, ctx, value, inst);
          }
          return superParse(payload, ctx);
        };
      });
      $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
        defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
        defineLazy(inst._zod, "values", () => {
          if (def.options.every((o) => o._zod.values)) {
            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
          }
          return void 0;
        });
        defineLazy(inst._zod, "pattern", () => {
          if (def.options.every((o) => o._zod.pattern)) {
            const patterns = def.options.map((o) => o._zod.pattern);
            return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
          }
          return void 0;
        });
        const single = def.options.length === 1;
        const first = def.options[0]._zod.run;
        inst._zod.parse = (payload, ctx) => {
          if (single) {
            return first(payload, ctx);
          }
          let async = false;
          const results = [];
          for (const option of def.options) {
            const result = option._zod.run({
              value: payload.value,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              results.push(result);
              async = true;
            } else {
              if (result.issues.length === 0)
                return result;
              results.push(result);
            }
          }
          if (!async)
            return handleUnionResults(results, payload, inst, ctx);
          return Promise.all(results).then((results2) => {
            return handleUnionResults(results2, payload, inst, ctx);
          });
        };
      });
      $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
        $ZodUnion.init(inst, def);
        def.inclusive = false;
        const single = def.options.length === 1;
        const first = def.options[0]._zod.run;
        inst._zod.parse = (payload, ctx) => {
          if (single) {
            return first(payload, ctx);
          }
          let async = false;
          const results = [];
          for (const option of def.options) {
            const result = option._zod.run({
              value: payload.value,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              results.push(result);
              async = true;
            } else {
              results.push(result);
            }
          }
          if (!async)
            return handleExclusiveUnionResults(results, payload, inst, ctx);
          return Promise.all(results).then((results2) => {
            return handleExclusiveUnionResults(results2, payload, inst, ctx);
          });
        };
      });
      $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
        def.inclusive = false;
        $ZodUnion.init(inst, def);
        const _super = inst._zod.parse;
        defineLazy(inst._zod, "propValues", () => {
          const propValues = {};
          for (const option of def.options) {
            const pv = option._zod.propValues;
            if (!pv || Object.keys(pv).length === 0)
              throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
            for (const [k, v] of Object.entries(pv)) {
              if (!propValues[k])
                propValues[k] = /* @__PURE__ */ new Set();
              for (const val of v) {
                propValues[k].add(val);
              }
            }
          }
          return propValues;
        });
        const disc = cached(() => {
          const opts = def.options;
          const map2 = /* @__PURE__ */ new Map();
          for (const o of opts) {
            const values = o._zod.propValues?.[def.discriminator];
            if (!values || values.size === 0)
              throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
            for (const v of values) {
              if (map2.has(v)) {
                throw new Error(`Duplicate discriminator value "${String(v)}"`);
              }
              map2.set(v, o);
            }
          }
          return map2;
        });
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!isObject(input)) {
            payload.issues.push({
              code: "invalid_type",
              expected: "object",
              input,
              inst
            });
            return payload;
          }
          const opt = disc.value.get(input?.[def.discriminator]);
          if (opt) {
            return opt._zod.run(payload, ctx);
          }
          if (def.unionFallback) {
            return _super(payload, ctx);
          }
          payload.issues.push({
            code: "invalid_union",
            errors: [],
            note: "No matching discriminator",
            discriminator: def.discriminator,
            input,
            path: [def.discriminator],
            inst
          });
          return payload;
        };
      });
      $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          const left = def.left._zod.run({ value: input, issues: [] }, ctx);
          const right = def.right._zod.run({ value: input, issues: [] }, ctx);
          const async = left instanceof Promise || right instanceof Promise;
          if (async) {
            return Promise.all([left, right]).then(([left2, right2]) => {
              return handleIntersectionResults(payload, left2, right2);
            });
          }
          return handleIntersectionResults(payload, left, right);
        };
      });
      $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
        $ZodType.init(inst, def);
        const items = def.items;
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!Array.isArray(input)) {
            payload.issues.push({
              input,
              inst,
              expected: "tuple",
              code: "invalid_type"
            });
            return payload;
          }
          payload.value = [];
          const proms = [];
          const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
          const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
          if (!def.rest) {
            const tooBig = input.length > items.length;
            const tooSmall = input.length < optStart - 1;
            if (tooBig || tooSmall) {
              payload.issues.push({
                ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
                input,
                inst,
                origin: "array"
              });
              return payload;
            }
          }
          let i = -1;
          for (const item of items) {
            i++;
            if (i >= input.length) {
              if (i >= optStart)
                continue;
            }
            const result = item._zod.run({
              value: input[i],
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
          if (def.rest) {
            const rest = input.slice(items.length);
            for (const el of rest) {
              i++;
              const result = def.rest._zod.run({
                value: el,
                issues: []
              }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
              } else {
                handleTupleResult(result, payload, i);
              }
            }
          }
          if (proms.length)
            return Promise.all(proms).then(() => payload);
          return payload;
        };
      });
      $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!isPlainObject(input)) {
            payload.issues.push({
              expected: "record",
              code: "invalid_type",
              input,
              inst
            });
            return payload;
          }
          const proms = [];
          const values = def.keyType._zod.values;
          if (values) {
            payload.value = {};
            const recordKeys = /* @__PURE__ */ new Set();
            for (const key of values) {
              if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
                recordKeys.add(typeof key === "number" ? key.toString() : key);
                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                if (result instanceof Promise) {
                  proms.push(result.then((result2) => {
                    if (result2.issues.length) {
                      payload.issues.push(...prefixIssues(key, result2.issues));
                    }
                    payload.value[key] = result2.value;
                  }));
                } else {
                  if (result.issues.length) {
                    payload.issues.push(...prefixIssues(key, result.issues));
                  }
                  payload.value[key] = result.value;
                }
              }
            }
            let unrecognized;
            for (const key in input) {
              if (!recordKeys.has(key)) {
                unrecognized = unrecognized ?? [];
                unrecognized.push(key);
              }
            }
            if (unrecognized && unrecognized.length > 0) {
              payload.issues.push({
                code: "unrecognized_keys",
                input,
                inst,
                keys: unrecognized
              });
            }
          } else {
            payload.value = {};
            for (const key of Reflect.ownKeys(input)) {
              if (key === "__proto__")
                continue;
              let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
              if (keyResult instanceof Promise) {
                throw new Error("Async schemas not supported in object keys currently");
              }
              const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
              if (checkNumericKey) {
                const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
                if (retryResult instanceof Promise) {
                  throw new Error("Async schemas not supported in object keys currently");
                }
                if (retryResult.issues.length === 0) {
                  keyResult = retryResult;
                }
              }
              if (keyResult.issues.length) {
                if (def.mode === "loose") {
                  payload.value[key] = input[key];
                } else {
                  payload.issues.push({
                    code: "invalid_key",
                    origin: "record",
                    issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                    input: key,
                    path: [key],
                    inst
                  });
                }
                continue;
              }
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[keyResult.value] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[keyResult.value] = result.value;
              }
            }
          }
          if (proms.length) {
            return Promise.all(proms).then(() => payload);
          }
          return payload;
        };
      });
      $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!(input instanceof Map)) {
            payload.issues.push({
              expected: "map",
              code: "invalid_type",
              input,
              inst
            });
            return payload;
          }
          const proms = [];
          payload.value = /* @__PURE__ */ new Map();
          for (const [key, value] of input) {
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
            if (keyResult instanceof Promise || valueResult instanceof Promise) {
              proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
                handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
              }));
            } else {
              handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
            }
          }
          if (proms.length)
            return Promise.all(proms).then(() => payload);
          return payload;
        };
      });
      $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!(input instanceof Set)) {
            payload.issues.push({
              input,
              inst,
              expected: "set",
              code: "invalid_type"
            });
            return payload;
          }
          const proms = [];
          payload.value = /* @__PURE__ */ new Set();
          for (const item of input) {
            const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleSetResult(result2, payload)));
            } else
              handleSetResult(result, payload);
          }
          if (proms.length)
            return Promise.all(proms).then(() => payload);
          return payload;
        };
      });
      $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
        $ZodType.init(inst, def);
        const values = getEnumValues(def.entries);
        const valuesSet = new Set(values);
        inst._zod.values = valuesSet;
        inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (valuesSet.has(input)) {
            return payload;
          }
          payload.issues.push({
            code: "invalid_value",
            values,
            input,
            inst
          });
          return payload;
        };
      });
      $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
        $ZodType.init(inst, def);
        if (def.values.length === 0) {
          throw new Error("Cannot create literal schema with no valid values");
        }
        const values = new Set(def.values);
        inst._zod.values = values;
        inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (values.has(input)) {
            return payload;
          }
          payload.issues.push({
            code: "invalid_value",
            values: def.values,
            input,
            inst
          });
          return payload;
        };
      });
      $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (input instanceof File)
            return payload;
          payload.issues.push({
            expected: "file",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        };
      });
      $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            throw new $ZodEncodeError(inst.constructor.name);
          }
          const _out = def.transform(payload.value, payload);
          if (ctx.async) {
            const output = _out instanceof Promise ? _out : Promise.resolve(_out);
            return output.then((output2) => {
              payload.value = output2;
              return payload;
            });
          }
          if (_out instanceof Promise) {
            throw new $ZodAsyncError();
          }
          payload.value = _out;
          return payload;
        };
      });
      $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.optin = "optional";
        inst._zod.optout = "optional";
        defineLazy(inst._zod, "values", () => {
          return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
        });
        defineLazy(inst._zod, "pattern", () => {
          const pattern = def.innerType._zod.pattern;
          return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
        });
        inst._zod.parse = (payload, ctx) => {
          if (def.innerType._zod.optin === "optional") {
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise)
              return result.then((r) => handleOptionalResult(r, payload.value));
            return handleOptionalResult(result, payload.value);
          }
          if (payload.value === void 0) {
            return payload;
          }
          return def.innerType._zod.run(payload, ctx);
        };
      });
      $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
        $ZodOptional.init(inst, def);
        defineLazy(inst._zod, "values", () => def.innerType._zod.values);
        defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
        inst._zod.parse = (payload, ctx) => {
          return def.innerType._zod.run(payload, ctx);
        };
      });
      $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
        defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
        defineLazy(inst._zod, "pattern", () => {
          const pattern = def.innerType._zod.pattern;
          return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
        });
        defineLazy(inst._zod, "values", () => {
          return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
        });
        inst._zod.parse = (payload, ctx) => {
          if (payload.value === null)
            return payload;
          return def.innerType._zod.run(payload, ctx);
        };
      });
      $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.optin = "optional";
        defineLazy(inst._zod, "values", () => def.innerType._zod.values);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
          }
          if (payload.value === void 0) {
            payload.value = def.defaultValue;
            return payload;
          }
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
            return result.then((result2) => handleDefaultResult(result2, def));
          }
          return handleDefaultResult(result, def);
        };
      });
      $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.optin = "optional";
        defineLazy(inst._zod, "values", () => def.innerType._zod.values);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
          }
          if (payload.value === void 0) {
            payload.value = def.defaultValue;
          }
          return def.innerType._zod.run(payload, ctx);
        };
      });
      $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "values", () => {
          const v = def.innerType._zod.values;
          return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
        });
        inst._zod.parse = (payload, ctx) => {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
            return result.then((result2) => handleNonOptionalResult(result2, inst));
          }
          return handleNonOptionalResult(result, inst);
        };
      });
      $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            throw new $ZodEncodeError("ZodSuccess");
          }
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
            return result.then((result2) => {
              payload.value = result2.issues.length === 0;
              return payload;
            });
          }
          payload.value = result.issues.length === 0;
          return payload;
        };
      });
      $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
        defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
        defineLazy(inst._zod, "values", () => def.innerType._zod.values);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
          }
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
            return result.then((result2) => {
              payload.value = result2.value;
              if (result2.issues.length) {
                payload.value = def.catchValue({
                  ...payload,
                  error: {
                    issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                  },
                  input: payload.value
                });
                payload.issues = [];
              }
              return payload;
            });
          }
          payload.value = result.value;
          if (result.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        };
      });
      $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _ctx) => {
          if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
            payload.issues.push({
              input: payload.value,
              inst,
              expected: "nan",
              code: "invalid_type"
            });
            return payload;
          }
          return payload;
        };
      });
      $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "values", () => def.in._zod.values);
        defineLazy(inst._zod, "optin", () => def.in._zod.optin);
        defineLazy(inst._zod, "optout", () => def.out._zod.optout);
        defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            const right = def.out._zod.run(payload, ctx);
            if (right instanceof Promise) {
              return right.then((right2) => handlePipeResult(right2, def.in, ctx));
            }
            return handlePipeResult(right, def.in, ctx);
          }
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handlePipeResult(left2, def.out, ctx));
          }
          return handlePipeResult(left, def.out, ctx);
        };
      });
      $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "values", () => def.in._zod.values);
        defineLazy(inst._zod, "optin", () => def.in._zod.optin);
        defineLazy(inst._zod, "optout", () => def.out._zod.optout);
        defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
        inst._zod.parse = (payload, ctx) => {
          const direction = ctx.direction || "forward";
          if (direction === "forward") {
            const left = def.in._zod.run(payload, ctx);
            if (left instanceof Promise) {
              return left.then((left2) => handleCodecAResult(left2, def, ctx));
            }
            return handleCodecAResult(left, def, ctx);
          } else {
            const right = def.out._zod.run(payload, ctx);
            if (right instanceof Promise) {
              return right.then((right2) => handleCodecAResult(right2, def, ctx));
            }
            return handleCodecAResult(right, def, ctx);
          }
        };
      });
      $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
        defineLazy(inst._zod, "values", () => def.innerType._zod.values);
        defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
        defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
        inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
          }
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
            return result.then(handleReadonlyResult);
          }
          return handleReadonlyResult(result);
        };
      });
      $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
        $ZodType.init(inst, def);
        const regexParts = [];
        for (const part of def.parts) {
          if (typeof part === "object" && part !== null) {
            if (!part._zod.pattern) {
              throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
            }
            const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
            if (!source)
              throw new Error(`Invalid template literal part: ${part._zod.traits}`);
            const start = source.startsWith("^") ? 1 : 0;
            const end = source.endsWith("$") ? source.length - 1 : source.length;
            regexParts.push(source.slice(start, end));
          } else if (part === null || primitiveTypes.has(typeof part)) {
            regexParts.push(escapeRegex(`${part}`));
          } else {
            throw new Error(`Invalid template literal part: ${part}`);
          }
        }
        inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
        inst._zod.parse = (payload, _ctx) => {
          if (typeof payload.value !== "string") {
            payload.issues.push({
              input: payload.value,
              inst,
              expected: "string",
              code: "invalid_type"
            });
            return payload;
          }
          inst._zod.pattern.lastIndex = 0;
          if (!inst._zod.pattern.test(payload.value)) {
            payload.issues.push({
              input: payload.value,
              inst,
              code: "invalid_format",
              format: def.format ?? "template_literal",
              pattern: inst._zod.pattern.source
            });
            return payload;
          }
          return payload;
        };
      });
      $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
        $ZodType.init(inst, def);
        inst._def = def;
        inst._zod.def = def;
        inst.implement = (func) => {
          if (typeof func !== "function") {
            throw new Error("implement() must be called with a function");
          }
          return function(...args) {
            const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
            const result = Reflect.apply(func, this, parsedArgs);
            if (inst._def.output) {
              return parse(inst._def.output, result);
            }
            return result;
          };
        };
        inst.implementAsync = (func) => {
          if (typeof func !== "function") {
            throw new Error("implementAsync() must be called with a function");
          }
          return async function(...args) {
            const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
            const result = await Reflect.apply(func, this, parsedArgs);
            if (inst._def.output) {
              return await parseAsync(inst._def.output, result);
            }
            return result;
          };
        };
        inst._zod.parse = (payload, _ctx) => {
          if (typeof payload.value !== "function") {
            payload.issues.push({
              code: "invalid_type",
              expected: "function",
              input: payload.value,
              inst
            });
            return payload;
          }
          const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
          if (hasPromiseOutput) {
            payload.value = inst.implementAsync(payload.value);
          } else {
            payload.value = inst.implement(payload.value);
          }
          return payload;
        };
        inst.input = (...args) => {
          const F = inst.constructor;
          if (Array.isArray(args[0])) {
            return new F({
              type: "function",
              input: new $ZodTuple({
                type: "tuple",
                items: args[0],
                rest: args[1]
              }),
              output: inst._def.output
            });
          }
          return new F({
            type: "function",
            input: args[0],
            output: inst._def.output
          });
        };
        inst.output = (output) => {
          const F = inst.constructor;
          return new F({
            type: "function",
            input: inst._def.input,
            output
          });
        };
        return inst;
      });
      $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, ctx) => {
          return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
        };
      });
      $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
        $ZodType.init(inst, def);
        defineLazy(inst._zod, "innerType", () => def.getter());
        defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
        defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
        defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
        defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
        inst._zod.parse = (payload, ctx) => {
          const inner = inst._zod.innerType;
          return inner._zod.run(payload, ctx);
        };
      });
      $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
        $ZodCheck.init(inst, def);
        $ZodType.init(inst, def);
        inst._zod.parse = (payload, _) => {
          return payload;
        };
        inst._zod.check = (payload) => {
          const input = payload.value;
          const r = def.fn(input);
          if (r instanceof Promise) {
            return r.then((r2) => handleRefineResult(r2, payload, input, inst));
          }
          handleRefineResult(r, payload, input, inst);
          return;
        };
      });
    }
  });

  // node_modules/zod/v4/locales/ar.js
  function ar_default() {
    return {
      localeError: error()
    };
  }
  var error;
  var init_ar = __esm({
    "node_modules/zod/v4/locales/ar.js"() {
      init_util();
      error = () => {
        const Sizable = {
          string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
          file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
          array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
          set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0645\u062F\u062E\u0644",
          email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
          url: "\u0631\u0627\u0628\u0637",
          emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
          date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
          time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
          duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
          ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
          ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
          cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
          cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
          base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
          base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
          json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
          e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
          jwt: "JWT",
          template_literal: "\u0645\u062F\u062E\u0644"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
              }
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
              return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
              return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
              if (_issue.format === "ends_with")
                return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
            }
            case "not_multiple_of":
              return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
            case "invalid_key":
              return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
            case "invalid_union":
              return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
            case "invalid_element":
              return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
            default:
              return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/az.js
  function az_default() {
    return {
      localeError: error2()
    };
  }
  var error2;
  var init_az = __esm({
    "node_modules/zod/v4/locales/az.js"() {
      init_util();
      error2 = () => {
        const Sizable = {
          string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
          file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
          array: { unit: "element", verb: "olmal\u0131d\u0131r" },
          set: { unit: "element", verb: "olmal\u0131d\u0131r" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "email address",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datetime",
          date: "ISO date",
          time: "ISO time",
          duration: "ISO duration",
          ipv4: "IPv4 address",
          ipv6: "IPv6 address",
          cidrv4: "IPv4 range",
          cidrv6: "IPv6 range",
          base64: "base64-encoded string",
          base64url: "base64url-encoded string",
          json_string: "JSON string",
          e164: "E.164 number",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
              }
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
              return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
              if (_issue.format === "ends_with")
                return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
              if (_issue.format === "includes")
                return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
              if (_issue.format === "regex")
                return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
              return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
            case "unrecognized_keys":
              return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
            case "invalid_union":
              return "Yanl\u0131\u015F d\u0259y\u0259r";
            case "invalid_element":
              return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
            default:
              return `Yanl\u0131\u015F d\u0259y\u0259r`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/be.js
  function getBelarusianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  function be_default() {
    return {
      localeError: error3()
    };
  }
  var error3;
  var init_be = __esm({
    "node_modules/zod/v4/locales/be.js"() {
      init_util();
      error3 = () => {
        const Sizable = {
          string: {
            unit: {
              one: "\u0441\u0456\u043C\u0432\u0430\u043B",
              few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
              many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
            },
            verb: "\u043C\u0435\u0446\u044C"
          },
          array: {
            unit: {
              one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
              few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
              many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
            },
            verb: "\u043C\u0435\u0446\u044C"
          },
          set: {
            unit: {
              one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
              few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
              many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
            },
            verb: "\u043C\u0435\u0446\u044C"
          },
          file: {
            unit: {
              one: "\u0431\u0430\u0439\u0442",
              few: "\u0431\u0430\u0439\u0442\u044B",
              many: "\u0431\u0430\u0439\u0442\u0430\u045E"
            },
            verb: "\u043C\u0435\u0446\u044C"
          }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0443\u0432\u043E\u0434",
          email: "email \u0430\u0434\u0440\u0430\u0441",
          url: "URL",
          emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
          date: "ISO \u0434\u0430\u0442\u0430",
          time: "ISO \u0447\u0430\u0441",
          duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
          ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
          ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
          cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
          cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
          base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
          base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
          json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
          e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
          jwt: "JWT",
          template_literal: "\u0443\u0432\u043E\u0434"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u043B\u0456\u043A",
          array: "\u043C\u0430\u0441\u0456\u045E"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
              }
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                const maxValue = Number(issue2.maximum);
                const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
              }
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                const minValue = Number(issue2.minimum);
                const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
              }
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
            case "invalid_union":
              return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
            case "invalid_element":
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
            default:
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/bg.js
  function bg_default() {
    return {
      localeError: error4()
    };
  }
  var error4;
  var init_bg = __esm({
    "node_modules/zod/v4/locales/bg.js"() {
      init_util();
      error4 = () => {
        const Sizable = {
          string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
          file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
          array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
          set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0432\u0445\u043E\u0434",
          email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
          url: "URL",
          emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
          date: "ISO \u0434\u0430\u0442\u0430",
          time: "ISO \u0432\u0440\u0435\u043C\u0435",
          duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
          ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
          ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
          cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
          cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
          base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
          base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
          json_string: "JSON \u043D\u0438\u0437",
          e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
          jwt: "JWT",
          template_literal: "\u0432\u0445\u043E\u0434"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0447\u0438\u0441\u043B\u043E",
          array: "\u043C\u0430\u0441\u0438\u0432"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
              }
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
              let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
              if (_issue.format === "emoji")
                invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
              if (_issue.format === "datetime")
                invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
              if (_issue.format === "date")
                invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
              if (_issue.format === "time")
                invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
              if (_issue.format === "duration")
                invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
              return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
            case "invalid_union":
              return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
            case "invalid_element":
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
            default:
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ca.js
  function ca_default() {
    return {
      localeError: error5()
    };
  }
  var error5;
  var init_ca = __esm({
    "node_modules/zod/v4/locales/ca.js"() {
      init_util();
      error5 = () => {
        const Sizable = {
          string: { unit: "car\xE0cters", verb: "contenir" },
          file: { unit: "bytes", verb: "contenir" },
          array: { unit: "elements", verb: "contenir" },
          set: { unit: "elements", verb: "contenir" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "entrada",
          email: "adre\xE7a electr\xF2nica",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data i hora ISO",
          date: "data ISO",
          time: "hora ISO",
          duration: "durada ISO",
          ipv4: "adre\xE7a IPv4",
          ipv6: "adre\xE7a IPv6",
          cidrv4: "rang IPv4",
          cidrv6: "rang IPv6",
          base64: "cadena codificada en base64",
          base64url: "cadena codificada en base64url",
          json_string: "cadena JSON",
          e164: "n\xFAmero E.164",
          jwt: "JWT",
          template_literal: "entrada"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
              }
              return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
              return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
              return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
              return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Clau inv\xE0lida a ${issue2.origin}`;
            case "invalid_union":
              return "Entrada inv\xE0lida";
            // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
            case "invalid_element":
              return `Element inv\xE0lid a ${issue2.origin}`;
            default:
              return `Entrada inv\xE0lida`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/cs.js
  function cs_default() {
    return {
      localeError: error6()
    };
  }
  var error6;
  var init_cs = __esm({
    "node_modules/zod/v4/locales/cs.js"() {
      init_util();
      error6 = () => {
        const Sizable = {
          string: { unit: "znak\u016F", verb: "m\xEDt" },
          file: { unit: "bajt\u016F", verb: "m\xEDt" },
          array: { unit: "prvk\u016F", verb: "m\xEDt" },
          set: { unit: "prvk\u016F", verb: "m\xEDt" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "regul\xE1rn\xED v\xFDraz",
          email: "e-mailov\xE1 adresa",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "datum a \u010Das ve form\xE1tu ISO",
          date: "datum ve form\xE1tu ISO",
          time: "\u010Das ve form\xE1tu ISO",
          duration: "doba trv\xE1n\xED ISO",
          ipv4: "IPv4 adresa",
          ipv6: "IPv6 adresa",
          cidrv4: "rozsah IPv4",
          cidrv6: "rozsah IPv6",
          base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
          base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
          json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
          e164: "\u010D\xEDslo E.164",
          jwt: "JWT",
          template_literal: "vstup"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u010D\xEDslo",
          string: "\u0159et\u011Bzec",
          function: "funkce",
          array: "pole"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
              }
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
              return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
              }
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
              }
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
              return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
            case "invalid_union":
              return "Neplatn\xFD vstup";
            case "invalid_element":
              return `Neplatn\xE1 hodnota v ${issue2.origin}`;
            default:
              return `Neplatn\xFD vstup`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/da.js
  function da_default() {
    return {
      localeError: error7()
    };
  }
  var error7;
  var init_da = __esm({
    "node_modules/zod/v4/locales/da.js"() {
      init_util();
      error7 = () => {
        const Sizable = {
          string: { unit: "tegn", verb: "havde" },
          file: { unit: "bytes", verb: "havde" },
          array: { unit: "elementer", verb: "indeholdt" },
          set: { unit: "elementer", verb: "indeholdt" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "e-mailadresse",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO dato- og klokkesl\xE6t",
          date: "ISO-dato",
          time: "ISO-klokkesl\xE6t",
          duration: "ISO-varighed",
          ipv4: "IPv4-omr\xE5de",
          ipv6: "IPv6-omr\xE5de",
          cidrv4: "IPv4-spektrum",
          cidrv6: "IPv6-spektrum",
          base64: "base64-kodet streng",
          base64url: "base64url-kodet streng",
          json_string: "JSON-streng",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN",
          string: "streng",
          number: "tal",
          boolean: "boolean",
          array: "liste",
          object: "objekt",
          set: "s\xE6t",
          file: "fil"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
              }
              return `Ugyldigt input: forventede ${expected}, fik ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
              return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              if (sizing)
                return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
              return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              if (sizing) {
                return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
              return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
            case "unrecognized_keys":
              return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Ugyldig n\xF8gle i ${issue2.origin}`;
            case "invalid_union":
              return "Ugyldigt input: matcher ingen af de tilladte typer";
            case "invalid_element":
              return `Ugyldig v\xE6rdi i ${issue2.origin}`;
            default:
              return `Ugyldigt input`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/de.js
  function de_default() {
    return {
      localeError: error8()
    };
  }
  var error8;
  var init_de = __esm({
    "node_modules/zod/v4/locales/de.js"() {
      init_util();
      error8 = () => {
        const Sizable = {
          string: { unit: "Zeichen", verb: "zu haben" },
          file: { unit: "Bytes", verb: "zu haben" },
          array: { unit: "Elemente", verb: "zu haben" },
          set: { unit: "Elemente", verb: "zu haben" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "Eingabe",
          email: "E-Mail-Adresse",
          url: "URL",
          emoji: "Emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-Datum und -Uhrzeit",
          date: "ISO-Datum",
          time: "ISO-Uhrzeit",
          duration: "ISO-Dauer",
          ipv4: "IPv4-Adresse",
          ipv6: "IPv6-Adresse",
          cidrv4: "IPv4-Bereich",
          cidrv6: "IPv6-Bereich",
          base64: "Base64-codierter String",
          base64url: "Base64-URL-codierter String",
          json_string: "JSON-String",
          e164: "E.164-Nummer",
          jwt: "JWT",
          template_literal: "Eingabe"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "Zahl",
          array: "Array"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
              }
              return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
              return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
              return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
              }
              return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
              if (_issue.format === "ends_with")
                return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
              if (_issue.format === "includes")
                return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
              if (_issue.format === "regex")
                return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
              return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
            case "unrecognized_keys":
              return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
            case "invalid_union":
              return "Ung\xFCltige Eingabe";
            case "invalid_element":
              return `Ung\xFCltiger Wert in ${issue2.origin}`;
            default:
              return `Ung\xFCltige Eingabe`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/en.js
  function en_default() {
    return {
      localeError: error9()
    };
  }
  var error9;
  var init_en = __esm({
    "node_modules/zod/v4/locales/en.js"() {
      init_util();
      error9 = () => {
        const Sizable = {
          string: { unit: "characters", verb: "to have" },
          file: { unit: "bytes", verb: "to have" },
          array: { unit: "items", verb: "to have" },
          set: { unit: "items", verb: "to have" },
          map: { unit: "entries", verb: "to have" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "email address",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datetime",
          date: "ISO date",
          time: "ISO time",
          duration: "ISO duration",
          ipv4: "IPv4 address",
          ipv6: "IPv6 address",
          mac: "MAC address",
          cidrv4: "IPv4 range",
          cidrv6: "IPv6 range",
          base64: "base64-encoded string",
          base64url: "base64url-encoded string",
          json_string: "JSON string",
          e164: "E.164 number",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          // Compatibility: "nan" -> "NaN" for display
          nan: "NaN"
          // All other type names omitted - they fall back to raw values via ?? operator
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              return `Invalid input: expected ${expected}, received ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
              return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
              return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Invalid string: must start with "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `Invalid string: must end with "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Invalid string: must include "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Invalid string: must match pattern ${_issue.pattern}`;
              return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Invalid number: must be a multiple of ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Invalid key in ${issue2.origin}`;
            case "invalid_union":
              return "Invalid input";
            case "invalid_element":
              return `Invalid value in ${issue2.origin}`;
            default:
              return `Invalid input`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/eo.js
  function eo_default() {
    return {
      localeError: error10()
    };
  }
  var error10;
  var init_eo = __esm({
    "node_modules/zod/v4/locales/eo.js"() {
      init_util();
      error10 = () => {
        const Sizable = {
          string: { unit: "karaktrojn", verb: "havi" },
          file: { unit: "bajtojn", verb: "havi" },
          array: { unit: "elementojn", verb: "havi" },
          set: { unit: "elementojn", verb: "havi" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "enigo",
          email: "retadreso",
          url: "URL",
          emoji: "emo\u011Dio",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-datotempo",
          date: "ISO-dato",
          time: "ISO-tempo",
          duration: "ISO-da\u016Dro",
          ipv4: "IPv4-adreso",
          ipv6: "IPv6-adreso",
          cidrv4: "IPv4-rango",
          cidrv6: "IPv6-rango",
          base64: "64-ume kodita karaktraro",
          base64url: "URL-64-ume kodita karaktraro",
          json_string: "JSON-karaktraro",
          e164: "E.164-nombro",
          jwt: "JWT",
          template_literal: "enigo"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "nombro",
          array: "tabelo",
          null: "senvalora"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
              }
              return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
              return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
              return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
              return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Nevalida \u015Dlosilo en ${issue2.origin}`;
            case "invalid_union":
              return "Nevalida enigo";
            case "invalid_element":
              return `Nevalida valoro en ${issue2.origin}`;
            default:
              return `Nevalida enigo`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/es.js
  function es_default() {
    return {
      localeError: error11()
    };
  }
  var error11;
  var init_es = __esm({
    "node_modules/zod/v4/locales/es.js"() {
      init_util();
      error11 = () => {
        const Sizable = {
          string: { unit: "caracteres", verb: "tener" },
          file: { unit: "bytes", verb: "tener" },
          array: { unit: "elementos", verb: "tener" },
          set: { unit: "elementos", verb: "tener" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "entrada",
          email: "direcci\xF3n de correo electr\xF3nico",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "fecha y hora ISO",
          date: "fecha ISO",
          time: "hora ISO",
          duration: "duraci\xF3n ISO",
          ipv4: "direcci\xF3n IPv4",
          ipv6: "direcci\xF3n IPv6",
          cidrv4: "rango IPv4",
          cidrv6: "rango IPv6",
          base64: "cadena codificada en base64",
          base64url: "URL codificada en base64",
          json_string: "cadena JSON",
          e164: "n\xFAmero E.164",
          jwt: "JWT",
          template_literal: "entrada"
        };
        const TypeDictionary = {
          nan: "NaN",
          string: "texto",
          number: "n\xFAmero",
          boolean: "booleano",
          array: "arreglo",
          object: "objeto",
          set: "conjunto",
          file: "archivo",
          date: "fecha",
          bigint: "n\xFAmero grande",
          symbol: "s\xEDmbolo",
          undefined: "indefinido",
          null: "nulo",
          function: "funci\xF3n",
          map: "mapa",
          record: "registro",
          tuple: "tupla",
          enum: "enumeraci\xF3n",
          union: "uni\xF3n",
          literal: "literal",
          promise: "promesa",
          void: "vac\xEDo",
          never: "nunca",
          unknown: "desconocido",
          any: "cualquiera"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
              }
              return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
              return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              if (sizing)
                return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              if (sizing) {
                return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
              return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
            case "invalid_union":
              return "Entrada inv\xE1lida";
            case "invalid_element":
              return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
            default:
              return `Entrada inv\xE1lida`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/fa.js
  function fa_default() {
    return {
      localeError: error12()
    };
  }
  var error12;
  var init_fa = __esm({
    "node_modules/zod/v4/locales/fa.js"() {
      init_util();
      error12 = () => {
        const Sizable = {
          string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
          file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
          array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
          set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0648\u0631\u0648\u062F\u06CC",
          email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
          url: "URL",
          emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
          date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
          time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
          duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
          ipv4: "IPv4 \u0622\u062F\u0631\u0633",
          ipv6: "IPv6 \u0622\u062F\u0631\u0633",
          cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
          cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
          base64: "base64-encoded \u0631\u0634\u062A\u0647",
          base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
          json_string: "JSON \u0631\u0634\u062A\u0647",
          e164: "E.164 \u0639\u062F\u062F",
          jwt: "JWT",
          template_literal: "\u0648\u0631\u0648\u062F\u06CC"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0639\u062F\u062F",
          array: "\u0622\u0631\u0627\u06CC\u0647"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
              }
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
            }
            case "invalid_value":
              if (issue2.values.length === 1) {
                return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
              }
              return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
              }
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
              }
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
              }
              if (_issue.format === "ends_with") {
                return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
              }
              if (_issue.format === "includes") {
                return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
              }
              if (_issue.format === "regex") {
                return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
              }
              return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
            }
            case "not_multiple_of":
              return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
            case "unrecognized_keys":
              return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
            case "invalid_union":
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
            case "invalid_element":
              return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
            default:
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/fi.js
  function fi_default() {
    return {
      localeError: error13()
    };
  }
  var error13;
  var init_fi = __esm({
    "node_modules/zod/v4/locales/fi.js"() {
      init_util();
      error13 = () => {
        const Sizable = {
          string: { unit: "merkki\xE4", subject: "merkkijonon" },
          file: { unit: "tavua", subject: "tiedoston" },
          array: { unit: "alkiota", subject: "listan" },
          set: { unit: "alkiota", subject: "joukon" },
          number: { unit: "", subject: "luvun" },
          bigint: { unit: "", subject: "suuren kokonaisluvun" },
          int: { unit: "", subject: "kokonaisluvun" },
          date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "s\xE4\xE4nn\xF6llinen lauseke",
          email: "s\xE4hk\xF6postiosoite",
          url: "URL-osoite",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-aikaleima",
          date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
          time: "ISO-aika",
          duration: "ISO-kesto",
          ipv4: "IPv4-osoite",
          ipv6: "IPv6-osoite",
          cidrv4: "IPv4-alue",
          cidrv6: "IPv6-alue",
          base64: "base64-koodattu merkkijono",
          base64url: "base64url-koodattu merkkijono",
          json_string: "JSON-merkkijono",
          e164: "E.164-luku",
          jwt: "JWT",
          template_literal: "templaattimerkkijono"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
              }
              return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
              return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
              }
              return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
              }
              return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
              if (_issue.format === "regex") {
                return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
              }
              return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
            case "unrecognized_keys":
              return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return "Virheellinen avain tietueessa";
            case "invalid_union":
              return "Virheellinen unioni";
            case "invalid_element":
              return "Virheellinen arvo joukossa";
            default:
              return `Virheellinen sy\xF6te`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/fr.js
  function fr_default() {
    return {
      localeError: error14()
    };
  }
  var error14;
  var init_fr = __esm({
    "node_modules/zod/v4/locales/fr.js"() {
      init_util();
      error14 = () => {
        const Sizable = {
          string: { unit: "caract\xE8res", verb: "avoir" },
          file: { unit: "octets", verb: "avoir" },
          array: { unit: "\xE9l\xE9ments", verb: "avoir" },
          set: { unit: "\xE9l\xE9ments", verb: "avoir" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "entr\xE9e",
          email: "adresse e-mail",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "date et heure ISO",
          date: "date ISO",
          time: "heure ISO",
          duration: "dur\xE9e ISO",
          ipv4: "adresse IPv4",
          ipv6: "adresse IPv6",
          cidrv4: "plage IPv4",
          cidrv6: "plage IPv6",
          base64: "cha\xEEne encod\xE9e en base64",
          base64url: "cha\xEEne encod\xE9e en base64url",
          json_string: "cha\xEEne JSON",
          e164: "num\xE9ro E.164",
          jwt: "JWT",
          template_literal: "entr\xE9e"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "nombre",
          array: "tableau"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
              }
              return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
              return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
              return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
            }
            case "not_multiple_of":
              return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Cl\xE9 invalide dans ${issue2.origin}`;
            case "invalid_union":
              return "Entr\xE9e invalide";
            case "invalid_element":
              return `Valeur invalide dans ${issue2.origin}`;
            default:
              return `Entr\xE9e invalide`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/fr-CA.js
  function fr_CA_default() {
    return {
      localeError: error15()
    };
  }
  var error15;
  var init_fr_CA = __esm({
    "node_modules/zod/v4/locales/fr-CA.js"() {
      init_util();
      error15 = () => {
        const Sizable = {
          string: { unit: "caract\xE8res", verb: "avoir" },
          file: { unit: "octets", verb: "avoir" },
          array: { unit: "\xE9l\xE9ments", verb: "avoir" },
          set: { unit: "\xE9l\xE9ments", verb: "avoir" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "entr\xE9e",
          email: "adresse courriel",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "date-heure ISO",
          date: "date ISO",
          time: "heure ISO",
          duration: "dur\xE9e ISO",
          ipv4: "adresse IPv4",
          ipv6: "adresse IPv6",
          cidrv4: "plage IPv4",
          cidrv6: "plage IPv6",
          base64: "cha\xEEne encod\xE9e en base64",
          base64url: "cha\xEEne encod\xE9e en base64url",
          json_string: "cha\xEEne JSON",
          e164: "num\xE9ro E.164",
          jwt: "JWT",
          template_literal: "entr\xE9e"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
              }
              return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
              return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "\u2264" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
              return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? "\u2265" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
            }
            case "not_multiple_of":
              return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Cl\xE9 invalide dans ${issue2.origin}`;
            case "invalid_union":
              return "Entr\xE9e invalide";
            case "invalid_element":
              return `Valeur invalide dans ${issue2.origin}`;
            default:
              return `Entr\xE9e invalide`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/he.js
  function he_default() {
    return {
      localeError: error16()
    };
  }
  var error16;
  var init_he = __esm({
    "node_modules/zod/v4/locales/he.js"() {
      init_util();
      error16 = () => {
        const TypeNames = {
          string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
          number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
          boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
          bigint: { label: "BigInt", gender: "m" },
          date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
          array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
          object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
          null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
          undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
          symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
          function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
          map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
          set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
          file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
          promise: { label: "Promise", gender: "m" },
          NaN: { label: "NaN", gender: "m" },
          unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
          value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
        };
        const Sizable = {
          string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
          file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
          array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
          set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
          number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
          // no unit
        };
        const typeEntry = (t) => t ? TypeNames[t] : void 0;
        const typeLabel = (t) => {
          const e = typeEntry(t);
          if (e)
            return e.label;
          return t ?? TypeNames.unknown.label;
        };
        const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
        const verbFor = (t) => {
          const e = typeEntry(t);
          const gender = e?.gender ?? "m";
          return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
        };
        const getSizing = (origin) => {
          if (!origin)
            return null;
          return Sizable[origin] ?? null;
        };
        const FormatDictionary = {
          regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
          email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
          url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
          emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
          uuid: { label: "UUID", gender: "m" },
          nanoid: { label: "nanoid", gender: "m" },
          guid: { label: "GUID", gender: "m" },
          cuid: { label: "cuid", gender: "m" },
          cuid2: { label: "cuid2", gender: "m" },
          ulid: { label: "ULID", gender: "m" },
          xid: { label: "XID", gender: "m" },
          ksuid: { label: "KSUID", gender: "m" },
          datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
          date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
          time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
          duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
          ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
          ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
          cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
          cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
          base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
          base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
          json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
          e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
          jwt: { label: "JWT", gender: "m" },
          ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
          includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
          lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
          starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
          uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expectedKey = issue2.expected;
              const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
              }
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
            }
            case "invalid_value": {
              if (issue2.values.length === 1) {
                return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
              }
              const stringified = issue2.values.map((v) => stringifyPrimitive(v));
              if (issue2.values.length === 2) {
                return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
              }
              const lastValue = stringified[stringified.length - 1];
              const restValues = stringified.slice(0, -1).join(", ");
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
            }
            case "too_big": {
              const sizing = getSizing(issue2.origin);
              const subject = withDefinite(issue2.origin ?? "value");
              if (issue2.origin === "string") {
                return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
              }
              if (issue2.origin === "number") {
                const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
                return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
              }
              if (issue2.origin === "array" || issue2.origin === "set") {
                const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
                const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
                return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
              }
              const adj = issue2.inclusive ? "<=" : "<";
              const be = verbFor(issue2.origin ?? "value");
              if (sizing?.unit) {
                return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
              }
              return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const sizing = getSizing(issue2.origin);
              const subject = withDefinite(issue2.origin ?? "value");
              if (issue2.origin === "string") {
                return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
              }
              if (issue2.origin === "number") {
                const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
              }
              if (issue2.origin === "array" || issue2.origin === "set") {
                const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
                if (issue2.minimum === 1 && issue2.inclusive) {
                  const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
                  return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
                }
                const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
              }
              const adj = issue2.inclusive ? ">=" : ">";
              const be = verbFor(issue2.origin ?? "value");
              if (sizing?.unit) {
                return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
              const nounEntry = FormatDictionary[_issue.format];
              const noun = nounEntry?.label ?? _issue.format;
              const gender = nounEntry?.gender ?? "m";
              const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
              return `${noun} \u05DC\u05D0 ${adjective}`;
            }
            case "not_multiple_of":
              return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key": {
              return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
            }
            case "invalid_union":
              return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
            case "invalid_element": {
              const place = withDefinite(issue2.origin ?? "array");
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
            }
            default:
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/hu.js
  function hu_default() {
    return {
      localeError: error17()
    };
  }
  var error17;
  var init_hu = __esm({
    "node_modules/zod/v4/locales/hu.js"() {
      init_util();
      error17 = () => {
        const Sizable = {
          string: { unit: "karakter", verb: "legyen" },
          file: { unit: "byte", verb: "legyen" },
          array: { unit: "elem", verb: "legyen" },
          set: { unit: "elem", verb: "legyen" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "bemenet",
          email: "email c\xEDm",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO id\u0151b\xE9lyeg",
          date: "ISO d\xE1tum",
          time: "ISO id\u0151",
          duration: "ISO id\u0151intervallum",
          ipv4: "IPv4 c\xEDm",
          ipv6: "IPv6 c\xEDm",
          cidrv4: "IPv4 tartom\xE1ny",
          cidrv6: "IPv6 tartom\xE1ny",
          base64: "base64-k\xF3dolt string",
          base64url: "base64url-k\xF3dolt string",
          json_string: "JSON string",
          e164: "E.164 sz\xE1m",
          jwt: "JWT",
          template_literal: "bemenet"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "sz\xE1m",
          array: "t\xF6mb"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
              }
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
              return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
              return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
              if (_issue.format === "ends_with")
                return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
              if (_issue.format === "includes")
                return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
              if (_issue.format === "regex")
                return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
              return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
            case "unrecognized_keys":
              return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
            case "invalid_union":
              return "\xC9rv\xE9nytelen bemenet";
            case "invalid_element":
              return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
            default:
              return `\xC9rv\xE9nytelen bemenet`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/hy.js
  function getArmenianPlural(count, one, many) {
    return Math.abs(count) === 1 ? one : many;
  }
  function withDefiniteArticle(word) {
    if (!word)
      return "";
    const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
    const lastChar = word[word.length - 1];
    return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
  }
  function hy_default() {
    return {
      localeError: error18()
    };
  }
  var error18;
  var init_hy = __esm({
    "node_modules/zod/v4/locales/hy.js"() {
      init_util();
      error18 = () => {
        const Sizable = {
          string: {
            unit: {
              one: "\u0576\u0577\u0561\u0576",
              many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
            },
            verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
          },
          file: {
            unit: {
              one: "\u0562\u0561\u0575\u0569",
              many: "\u0562\u0561\u0575\u0569\u0565\u0580"
            },
            verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
          },
          array: {
            unit: {
              one: "\u057F\u0561\u0580\u0580",
              many: "\u057F\u0561\u0580\u0580\u0565\u0580"
            },
            verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
          },
          set: {
            unit: {
              one: "\u057F\u0561\u0580\u0580",
              many: "\u057F\u0561\u0580\u0580\u0565\u0580"
            },
            verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
          }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0574\u0578\u0582\u057F\u0584",
          email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
          url: "URL",
          emoji: "\u0567\u0574\u0578\u057B\u056B",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
          date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
          time: "ISO \u056A\u0561\u0574",
          duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
          ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
          ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
          cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
          cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
          base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
          base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
          json_string: "JSON \u057F\u0578\u0572",
          e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
          jwt: "JWT",
          template_literal: "\u0574\u0578\u0582\u057F\u0584"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0569\u056B\u057E",
          array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
              }
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
              return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                const maxValue = Number(issue2.maximum);
                const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
                return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
              }
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                const minValue = Number(issue2.minimum);
                const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
                return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
              }
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
              if (_issue.format === "ends_with")
                return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
              if (_issue.format === "includes")
                return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
              return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
            case "unrecognized_keys":
              return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
            case "invalid_union":
              return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
            case "invalid_element":
              return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
            default:
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/id.js
  function id_default() {
    return {
      localeError: error19()
    };
  }
  var error19;
  var init_id = __esm({
    "node_modules/zod/v4/locales/id.js"() {
      init_util();
      error19 = () => {
        const Sizable = {
          string: { unit: "karakter", verb: "memiliki" },
          file: { unit: "byte", verb: "memiliki" },
          array: { unit: "item", verb: "memiliki" },
          set: { unit: "item", verb: "memiliki" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "alamat email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "tanggal dan waktu format ISO",
          date: "tanggal format ISO",
          time: "jam format ISO",
          duration: "durasi format ISO",
          ipv4: "alamat IPv4",
          ipv6: "alamat IPv6",
          cidrv4: "rentang alamat IPv4",
          cidrv6: "rentang alamat IPv6",
          base64: "string dengan enkode base64",
          base64url: "string dengan enkode base64url",
          json_string: "string JSON",
          e164: "angka E.164",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
              }
              return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
              return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
              return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `String tidak valid: harus menyertakan "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
            }
            case "not_multiple_of":
              return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Kunci tidak valid di ${issue2.origin}`;
            case "invalid_union":
              return "Input tidak valid";
            case "invalid_element":
              return `Nilai tidak valid di ${issue2.origin}`;
            default:
              return `Input tidak valid`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/is.js
  function is_default() {
    return {
      localeError: error20()
    };
  }
  var error20;
  var init_is = __esm({
    "node_modules/zod/v4/locales/is.js"() {
      init_util();
      error20 = () => {
        const Sizable = {
          string: { unit: "stafi", verb: "a\xF0 hafa" },
          file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
          array: { unit: "hluti", verb: "a\xF0 hafa" },
          set: { unit: "hluti", verb: "a\xF0 hafa" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "gildi",
          email: "netfang",
          url: "vefsl\xF3\xF0",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO dagsetning og t\xEDmi",
          date: "ISO dagsetning",
          time: "ISO t\xEDmi",
          duration: "ISO t\xEDmalengd",
          ipv4: "IPv4 address",
          ipv6: "IPv6 address",
          cidrv4: "IPv4 range",
          cidrv6: "IPv6 range",
          base64: "base64-encoded strengur",
          base64url: "base64url-encoded strengur",
          json_string: "JSON strengur",
          e164: "E.164 t\xF6lugildi",
          jwt: "JWT",
          template_literal: "gildi"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "n\xFAmer",
          array: "fylki"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
              }
              return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
              return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
              return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Rangur lykill \xED ${issue2.origin}`;
            case "invalid_union":
              return "Rangt gildi";
            case "invalid_element":
              return `Rangt gildi \xED ${issue2.origin}`;
            default:
              return `Rangt gildi`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/it.js
  function it_default() {
    return {
      localeError: error21()
    };
  }
  var error21;
  var init_it = __esm({
    "node_modules/zod/v4/locales/it.js"() {
      init_util();
      error21 = () => {
        const Sizable = {
          string: { unit: "caratteri", verb: "avere" },
          file: { unit: "byte", verb: "avere" },
          array: { unit: "elementi", verb: "avere" },
          set: { unit: "elementi", verb: "avere" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "indirizzo email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data e ora ISO",
          date: "data ISO",
          time: "ora ISO",
          duration: "durata ISO",
          ipv4: "indirizzo IPv4",
          ipv6: "indirizzo IPv6",
          cidrv4: "intervallo IPv4",
          cidrv6: "intervallo IPv6",
          base64: "stringa codificata in base64",
          base64url: "URL codificata in base64",
          json_string: "stringa JSON",
          e164: "numero E.164",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "numero",
          array: "vettore"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
              }
              return `Input non valido: atteso ${expected}, ricevuto ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
              return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
              return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Stringa non valida: deve includere "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
              return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Chiave non valida in ${issue2.origin}`;
            case "invalid_union":
              return "Input non valido";
            case "invalid_element":
              return `Valore non valido in ${issue2.origin}`;
            default:
              return `Input non valido`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ja.js
  function ja_default() {
    return {
      localeError: error22()
    };
  }
  var error22;
  var init_ja = __esm({
    "node_modules/zod/v4/locales/ja.js"() {
      init_util();
      error22 = () => {
        const Sizable = {
          string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
          file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
          array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
          set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u5165\u529B\u5024",
          email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
          url: "URL",
          emoji: "\u7D75\u6587\u5B57",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO\u65E5\u6642",
          date: "ISO\u65E5\u4ED8",
          time: "ISO\u6642\u523B",
          duration: "ISO\u671F\u9593",
          ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
          ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
          cidrv4: "IPv4\u7BC4\u56F2",
          cidrv6: "IPv6\u7BC4\u56F2",
          base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
          base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
          json_string: "JSON\u6587\u5B57\u5217",
          e164: "E.164\u756A\u53F7",
          jwt: "JWT",
          template_literal: "\u5165\u529B\u5024"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u6570\u5024",
          array: "\u914D\u5217"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
              }
              return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
              return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            case "too_big": {
              const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
              if (_issue.format === "ends_with")
                return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
              if (_issue.format === "includes")
                return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
              if (_issue.format === "regex")
                return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
              return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            case "unrecognized_keys":
              return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
            case "invalid_key":
              return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
            case "invalid_union":
              return "\u7121\u52B9\u306A\u5165\u529B";
            case "invalid_element":
              return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
            default:
              return `\u7121\u52B9\u306A\u5165\u529B`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ka.js
  function ka_default() {
    return {
      localeError: error23()
    };
  }
  var error23;
  var init_ka = __esm({
    "node_modules/zod/v4/locales/ka.js"() {
      init_util();
      error23 = () => {
        const Sizable = {
          string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
          file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
          array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
          set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
          email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
          url: "URL",
          emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
          date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
          time: "\u10D3\u10E0\u10DD",
          duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
          ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
          ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
          cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
          cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
          base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
          base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
          json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
          e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
          jwt: "JWT",
          template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
          string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
          boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
          function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
          array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
              }
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
              }
              if (_issue.format === "ends_with")
                return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
              if (_issue.format === "includes")
                return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
              if (_issue.format === "regex")
                return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
            case "unrecognized_keys":
              return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
            case "invalid_union":
              return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
            case "invalid_element":
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
            default:
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/km.js
  function km_default() {
    return {
      localeError: error24()
    };
  }
  var error24;
  var init_km = __esm({
    "node_modules/zod/v4/locales/km.js"() {
      init_util();
      error24 = () => {
        const Sizable = {
          string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
          file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
          array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
          set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
          email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
          url: "URL",
          emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
          date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
          time: "\u1798\u17C9\u17C4\u1784 ISO",
          duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
          ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
          ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
          cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
          cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
          base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
          base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
          json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
          e164: "\u179B\u17C1\u1781 E.164",
          jwt: "JWT",
          template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u179B\u17C1\u1781",
          array: "\u17A2\u17B6\u179A\u17C1 (Array)",
          null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
              }
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
              return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
              return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
            case "invalid_union":
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
            case "invalid_element":
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
            default:
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/kh.js
  function kh_default() {
    return km_default();
  }
  var init_kh = __esm({
    "node_modules/zod/v4/locales/kh.js"() {
      init_km();
    }
  });

  // node_modules/zod/v4/locales/ko.js
  function ko_default() {
    return {
      localeError: error25()
    };
  }
  var error25;
  var init_ko = __esm({
    "node_modules/zod/v4/locales/ko.js"() {
      init_util();
      error25 = () => {
        const Sizable = {
          string: { unit: "\uBB38\uC790", verb: "to have" },
          file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
          array: { unit: "\uAC1C", verb: "to have" },
          set: { unit: "\uAC1C", verb: "to have" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\uC785\uB825",
          email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
          url: "URL",
          emoji: "\uC774\uBAA8\uC9C0",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
          date: "ISO \uB0A0\uC9DC",
          time: "ISO \uC2DC\uAC04",
          duration: "ISO \uAE30\uAC04",
          ipv4: "IPv4 \uC8FC\uC18C",
          ipv6: "IPv6 \uC8FC\uC18C",
          cidrv4: "IPv4 \uBC94\uC704",
          cidrv6: "IPv6 \uBC94\uC704",
          base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
          base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
          json_string: "JSON \uBB38\uC790\uC5F4",
          e164: "E.164 \uBC88\uD638",
          jwt: "JWT",
          template_literal: "\uC785\uB825"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
              }
              return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
              return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
            case "too_big": {
              const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
              const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
              const sizing = getSizing(issue2.origin);
              const unit = sizing?.unit ?? "\uC694\uC18C";
              if (sizing)
                return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
              const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
              const sizing = getSizing(issue2.origin);
              const unit = sizing?.unit ?? "\uC694\uC18C";
              if (sizing) {
                return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
              }
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
              }
              if (_issue.format === "ends_with")
                return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
              if (_issue.format === "includes")
                return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
              if (_issue.format === "regex")
                return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
              return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
            case "unrecognized_keys":
              return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
            case "invalid_union":
              return `\uC798\uBABB\uB41C \uC785\uB825`;
            case "invalid_element":
              return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
            default:
              return `\uC798\uBABB\uB41C \uC785\uB825`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/lt.js
  function getUnitTypeFromNumber(number4) {
    const abs = Math.abs(number4);
    const last = abs % 10;
    const last2 = abs % 100;
    if (last2 >= 11 && last2 <= 19 || last === 0)
      return "many";
    if (last === 1)
      return "one";
    return "few";
  }
  function lt_default() {
    return {
      localeError: error26()
    };
  }
  var capitalizeFirstCharacter, error26;
  var init_lt = __esm({
    "node_modules/zod/v4/locales/lt.js"() {
      init_util();
      capitalizeFirstCharacter = (text) => {
        return text.charAt(0).toUpperCase() + text.slice(1);
      };
      error26 = () => {
        const Sizable = {
          string: {
            unit: {
              one: "simbolis",
              few: "simboliai",
              many: "simboli\u0173"
            },
            verb: {
              smaller: {
                inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
                notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
              },
              bigger: {
                inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
                notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
              }
            }
          },
          file: {
            unit: {
              one: "baitas",
              few: "baitai",
              many: "bait\u0173"
            },
            verb: {
              smaller: {
                inclusive: "turi b\u016Bti ne didesnis kaip",
                notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
              },
              bigger: {
                inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
                notInclusive: "turi b\u016Bti didesnis kaip"
              }
            }
          },
          array: {
            unit: {
              one: "element\u0105",
              few: "elementus",
              many: "element\u0173"
            },
            verb: {
              smaller: {
                inclusive: "turi tur\u0117ti ne daugiau kaip",
                notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
              },
              bigger: {
                inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
                notInclusive: "turi tur\u0117ti daugiau kaip"
              }
            }
          },
          set: {
            unit: {
              one: "element\u0105",
              few: "elementus",
              many: "element\u0173"
            },
            verb: {
              smaller: {
                inclusive: "turi tur\u0117ti ne daugiau kaip",
                notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
              },
              bigger: {
                inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
                notInclusive: "turi tur\u0117ti daugiau kaip"
              }
            }
          }
        };
        function getSizing(origin, unitType, inclusive, targetShouldBe) {
          const result = Sizable[origin] ?? null;
          if (result === null)
            return result;
          return {
            unit: result.unit[unitType],
            verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
          };
        }
        const FormatDictionary = {
          regex: "\u012Fvestis",
          email: "el. pa\u0161to adresas",
          url: "URL",
          emoji: "jaustukas",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO data ir laikas",
          date: "ISO data",
          time: "ISO laikas",
          duration: "ISO trukm\u0117",
          ipv4: "IPv4 adresas",
          ipv6: "IPv6 adresas",
          cidrv4: "IPv4 tinklo prefiksas (CIDR)",
          cidrv6: "IPv6 tinklo prefiksas (CIDR)",
          base64: "base64 u\u017Ekoduota eilut\u0117",
          base64url: "base64url u\u017Ekoduota eilut\u0117",
          json_string: "JSON eilut\u0117",
          e164: "E.164 numeris",
          jwt: "JWT",
          template_literal: "\u012Fvestis"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "skai\u010Dius",
          bigint: "sveikasis skai\u010Dius",
          string: "eilut\u0117",
          boolean: "login\u0117 reik\u0161m\u0117",
          undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
          function: "funkcija",
          symbol: "simbolis",
          array: "masyvas",
          object: "objektas",
          null: "nulin\u0117 reik\u0161m\u0117"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
              }
              return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
              return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
            case "too_big": {
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
              if (sizing?.verb)
                return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
              const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
            }
            case "too_small": {
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
              if (sizing?.verb)
                return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
              const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
              return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
            case "unrecognized_keys":
              return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return "Rastas klaidingas raktas";
            case "invalid_union":
              return "Klaidinga \u012Fvestis";
            case "invalid_element": {
              const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
            }
            default:
              return "Klaidinga \u012Fvestis";
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/mk.js
  function mk_default() {
    return {
      localeError: error27()
    };
  }
  var error27;
  var init_mk = __esm({
    "node_modules/zod/v4/locales/mk.js"() {
      init_util();
      error27 = () => {
        const Sizable = {
          string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
          file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
          array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
          set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0432\u043D\u0435\u0441",
          email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
          url: "URL",
          emoji: "\u0435\u043C\u043E\u045F\u0438",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
          date: "ISO \u0434\u0430\u0442\u0443\u043C",
          time: "ISO \u0432\u0440\u0435\u043C\u0435",
          duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
          ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
          ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
          cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
          cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
          base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
          base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
          json_string: "JSON \u043D\u0438\u0437\u0430",
          e164: "E.164 \u0431\u0440\u043E\u0458",
          jwt: "JWT",
          template_literal: "\u0432\u043D\u0435\u0441"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0431\u0440\u043E\u0458",
          array: "\u043D\u0438\u0437\u0430"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
              }
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
              return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
              return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
            case "unrecognized_keys":
              return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
            case "invalid_union":
              return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
            case "invalid_element":
              return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
            default:
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ms.js
  function ms_default() {
    return {
      localeError: error28()
    };
  }
  var error28;
  var init_ms = __esm({
    "node_modules/zod/v4/locales/ms.js"() {
      init_util();
      error28 = () => {
        const Sizable = {
          string: { unit: "aksara", verb: "mempunyai" },
          file: { unit: "bait", verb: "mempunyai" },
          array: { unit: "elemen", verb: "mempunyai" },
          set: { unit: "elemen", verb: "mempunyai" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "alamat e-mel",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "tarikh masa ISO",
          date: "tarikh ISO",
          time: "masa ISO",
          duration: "tempoh ISO",
          ipv4: "alamat IPv4",
          ipv6: "alamat IPv6",
          cidrv4: "julat IPv4",
          cidrv6: "julat IPv6",
          base64: "string dikodkan base64",
          base64url: "string dikodkan base64url",
          json_string: "string JSON",
          e164: "nombor E.164",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "nombor"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
              }
              return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
              return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
              return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
            }
            case "not_multiple_of":
              return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Kunci tidak sah dalam ${issue2.origin}`;
            case "invalid_union":
              return "Input tidak sah";
            case "invalid_element":
              return `Nilai tidak sah dalam ${issue2.origin}`;
            default:
              return `Input tidak sah`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/nl.js
  function nl_default() {
    return {
      localeError: error29()
    };
  }
  var error29;
  var init_nl = __esm({
    "node_modules/zod/v4/locales/nl.js"() {
      init_util();
      error29 = () => {
        const Sizable = {
          string: { unit: "tekens", verb: "heeft" },
          file: { unit: "bytes", verb: "heeft" },
          array: { unit: "elementen", verb: "heeft" },
          set: { unit: "elementen", verb: "heeft" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "invoer",
          email: "emailadres",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datum en tijd",
          date: "ISO datum",
          time: "ISO tijd",
          duration: "ISO duur",
          ipv4: "IPv4-adres",
          ipv6: "IPv6-adres",
          cidrv4: "IPv4-bereik",
          cidrv6: "IPv6-bereik",
          base64: "base64-gecodeerde tekst",
          base64url: "base64 URL-gecodeerde tekst",
          json_string: "JSON string",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "invoer"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "getal"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
              }
              return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
              return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
              if (sizing)
                return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
              return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
              if (sizing) {
                return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
              }
              return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
              }
              if (_issue.format === "ends_with")
                return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
              if (_issue.format === "includes")
                return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
              if (_issue.format === "regex")
                return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
              return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
            case "unrecognized_keys":
              return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Ongeldige key in ${issue2.origin}`;
            case "invalid_union":
              return "Ongeldige invoer";
            case "invalid_element":
              return `Ongeldige waarde in ${issue2.origin}`;
            default:
              return `Ongeldige invoer`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/no.js
  function no_default() {
    return {
      localeError: error30()
    };
  }
  var error30;
  var init_no = __esm({
    "node_modules/zod/v4/locales/no.js"() {
      init_util();
      error30 = () => {
        const Sizable = {
          string: { unit: "tegn", verb: "\xE5 ha" },
          file: { unit: "bytes", verb: "\xE5 ha" },
          array: { unit: "elementer", verb: "\xE5 inneholde" },
          set: { unit: "elementer", verb: "\xE5 inneholde" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "input",
          email: "e-postadresse",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO dato- og klokkeslett",
          date: "ISO-dato",
          time: "ISO-klokkeslett",
          duration: "ISO-varighet",
          ipv4: "IPv4-omr\xE5de",
          ipv6: "IPv6-omr\xE5de",
          cidrv4: "IPv4-spekter",
          cidrv6: "IPv6-spekter",
          base64: "base64-enkodet streng",
          base64url: "base64url-enkodet streng",
          json_string: "JSON-streng",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "tall",
          array: "liste"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
              }
              return `Ugyldig input: forventet ${expected}, fikk ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
              return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
              return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
              return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
            case "unrecognized_keys":
              return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Ugyldig n\xF8kkel i ${issue2.origin}`;
            case "invalid_union":
              return "Ugyldig input";
            case "invalid_element":
              return `Ugyldig verdi i ${issue2.origin}`;
            default:
              return `Ugyldig input`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ota.js
  function ota_default() {
    return {
      localeError: error31()
    };
  }
  var error31;
  var init_ota = __esm({
    "node_modules/zod/v4/locales/ota.js"() {
      init_util();
      error31 = () => {
        const Sizable = {
          string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
          file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
          array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
          set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "giren",
          email: "epostag\xE2h",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO heng\xE2m\u0131",
          date: "ISO tarihi",
          time: "ISO zaman\u0131",
          duration: "ISO m\xFCddeti",
          ipv4: "IPv4 ni\u015F\xE2n\u0131",
          ipv6: "IPv6 ni\u015F\xE2n\u0131",
          cidrv4: "IPv4 menzili",
          cidrv6: "IPv6 menzili",
          base64: "base64-\u015Fifreli metin",
          base64url: "base64url-\u015Fifreli metin",
          json_string: "JSON metin",
          e164: "E.164 say\u0131s\u0131",
          jwt: "JWT",
          template_literal: "giren"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "numara",
          array: "saf",
          null: "gayb"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
              }
              return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
              return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
              return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
              }
              return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
              if (_issue.format === "ends_with")
                return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
              if (_issue.format === "includes")
                return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
              if (_issue.format === "regex")
                return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
              return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
            case "unrecognized_keys":
              return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
            case "invalid_union":
              return "Giren tan\u0131namad\u0131.";
            case "invalid_element":
              return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
            default:
              return `K\u0131ymet tan\u0131namad\u0131.`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ps.js
  function ps_default() {
    return {
      localeError: error32()
    };
  }
  var error32;
  var init_ps = __esm({
    "node_modules/zod/v4/locales/ps.js"() {
      init_util();
      error32 = () => {
        const Sizable = {
          string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
          file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
          array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
          set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0648\u0631\u0648\u062F\u064A",
          email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
          url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
          emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
          date: "\u0646\u06D0\u067C\u0647",
          time: "\u0648\u062E\u062A",
          duration: "\u0645\u0648\u062F\u0647",
          ipv4: "\u062F IPv4 \u067E\u062A\u0647",
          ipv6: "\u062F IPv6 \u067E\u062A\u0647",
          cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
          cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
          base64: "base64-encoded \u0645\u062A\u0646",
          base64url: "base64url-encoded \u0645\u062A\u0646",
          json_string: "JSON \u0645\u062A\u0646",
          e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
          jwt: "JWT",
          template_literal: "\u0648\u0631\u0648\u062F\u064A"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0639\u062F\u062F",
          array: "\u0627\u0631\u06D0"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
              }
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
            }
            case "invalid_value":
              if (issue2.values.length === 1) {
                return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
              }
              return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
              }
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
              }
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
              }
              if (_issue.format === "ends_with") {
                return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
              }
              if (_issue.format === "includes") {
                return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
              }
              if (_issue.format === "regex") {
                return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
              }
              return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
            }
            case "not_multiple_of":
              return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
            case "unrecognized_keys":
              return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
            case "invalid_union":
              return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
            case "invalid_element":
              return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
            default:
              return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/pl.js
  function pl_default() {
    return {
      localeError: error33()
    };
  }
  var error33;
  var init_pl = __esm({
    "node_modules/zod/v4/locales/pl.js"() {
      init_util();
      error33 = () => {
        const Sizable = {
          string: { unit: "znak\xF3w", verb: "mie\u0107" },
          file: { unit: "bajt\xF3w", verb: "mie\u0107" },
          array: { unit: "element\xF3w", verb: "mie\u0107" },
          set: { unit: "element\xF3w", verb: "mie\u0107" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "wyra\u017Cenie",
          email: "adres email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data i godzina w formacie ISO",
          date: "data w formacie ISO",
          time: "godzina w formacie ISO",
          duration: "czas trwania ISO",
          ipv4: "adres IPv4",
          ipv6: "adres IPv6",
          cidrv4: "zakres IPv4",
          cidrv6: "zakres IPv6",
          base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
          base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
          json_string: "ci\u0105g znak\xF3w w formacie JSON",
          e164: "liczba E.164",
          jwt: "JWT",
          template_literal: "wej\u015Bcie"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "liczba",
          array: "tablica"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
              }
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
              return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
              }
              return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
              }
              return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
              return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
            case "invalid_union":
              return "Nieprawid\u0142owe dane wej\u015Bciowe";
            case "invalid_element":
              return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
            default:
              return `Nieprawid\u0142owe dane wej\u015Bciowe`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/pt.js
  function pt_default() {
    return {
      localeError: error34()
    };
  }
  var error34;
  var init_pt = __esm({
    "node_modules/zod/v4/locales/pt.js"() {
      init_util();
      error34 = () => {
        const Sizable = {
          string: { unit: "caracteres", verb: "ter" },
          file: { unit: "bytes", verb: "ter" },
          array: { unit: "itens", verb: "ter" },
          set: { unit: "itens", verb: "ter" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "padr\xE3o",
          email: "endere\xE7o de e-mail",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data e hora ISO",
          date: "data ISO",
          time: "hora ISO",
          duration: "dura\xE7\xE3o ISO",
          ipv4: "endere\xE7o IPv4",
          ipv6: "endere\xE7o IPv6",
          cidrv4: "faixa de IPv4",
          cidrv6: "faixa de IPv6",
          base64: "texto codificado em base64",
          base64url: "URL codificada em base64",
          json_string: "texto JSON",
          e164: "n\xFAmero E.164",
          jwt: "JWT",
          template_literal: "entrada"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "n\xFAmero",
          null: "nulo"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
              }
              return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
              return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
              return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
            }
            case "not_multiple_of":
              return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Chave inv\xE1lida em ${issue2.origin}`;
            case "invalid_union":
              return "Entrada inv\xE1lida";
            case "invalid_element":
              return `Valor inv\xE1lido em ${issue2.origin}`;
            default:
              return `Campo inv\xE1lido`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ru.js
  function getRussianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  function ru_default() {
    return {
      localeError: error35()
    };
  }
  var error35;
  var init_ru = __esm({
    "node_modules/zod/v4/locales/ru.js"() {
      init_util();
      error35 = () => {
        const Sizable = {
          string: {
            unit: {
              one: "\u0441\u0438\u043C\u0432\u043E\u043B",
              few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
              many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
            },
            verb: "\u0438\u043C\u0435\u0442\u044C"
          },
          file: {
            unit: {
              one: "\u0431\u0430\u0439\u0442",
              few: "\u0431\u0430\u0439\u0442\u0430",
              many: "\u0431\u0430\u0439\u0442"
            },
            verb: "\u0438\u043C\u0435\u0442\u044C"
          },
          array: {
            unit: {
              one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
              few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
              many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
            },
            verb: "\u0438\u043C\u0435\u0442\u044C"
          },
          set: {
            unit: {
              one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
              few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
              many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
            },
            verb: "\u0438\u043C\u0435\u0442\u044C"
          }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0432\u0432\u043E\u0434",
          email: "email \u0430\u0434\u0440\u0435\u0441",
          url: "URL",
          emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
          date: "ISO \u0434\u0430\u0442\u0430",
          time: "ISO \u0432\u0440\u0435\u043C\u044F",
          duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
          ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
          ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
          cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
          cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
          base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
          base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
          json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
          e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
          jwt: "JWT",
          template_literal: "\u0432\u0432\u043E\u0434"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0447\u0438\u0441\u043B\u043E",
          array: "\u043C\u0430\u0441\u0441\u0438\u0432"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
              }
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                const maxValue = Number(issue2.maximum);
                const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
              }
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                const minValue = Number(issue2.minimum);
                const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
              }
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
            case "invalid_union":
              return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
            case "invalid_element":
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
            default:
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/sl.js
  function sl_default() {
    return {
      localeError: error36()
    };
  }
  var error36;
  var init_sl = __esm({
    "node_modules/zod/v4/locales/sl.js"() {
      init_util();
      error36 = () => {
        const Sizable = {
          string: { unit: "znakov", verb: "imeti" },
          file: { unit: "bajtov", verb: "imeti" },
          array: { unit: "elementov", verb: "imeti" },
          set: { unit: "elementov", verb: "imeti" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "vnos",
          email: "e-po\u0161tni naslov",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datum in \u010Das",
          date: "ISO datum",
          time: "ISO \u010Das",
          duration: "ISO trajanje",
          ipv4: "IPv4 naslov",
          ipv6: "IPv6 naslov",
          cidrv4: "obseg IPv4",
          cidrv6: "obseg IPv6",
          base64: "base64 kodiran niz",
          base64url: "base64url kodiran niz",
          json_string: "JSON niz",
          e164: "E.164 \u0161tevilka",
          jwt: "JWT",
          template_literal: "vnos"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0161tevilo",
          array: "tabela"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
              }
              return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
              return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
              return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
              return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Neveljaven klju\u010D v ${issue2.origin}`;
            case "invalid_union":
              return "Neveljaven vnos";
            case "invalid_element":
              return `Neveljavna vrednost v ${issue2.origin}`;
            default:
              return "Neveljaven vnos";
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/sv.js
  function sv_default() {
    return {
      localeError: error37()
    };
  }
  var error37;
  var init_sv = __esm({
    "node_modules/zod/v4/locales/sv.js"() {
      init_util();
      error37 = () => {
        const Sizable = {
          string: { unit: "tecken", verb: "att ha" },
          file: { unit: "bytes", verb: "att ha" },
          array: { unit: "objekt", verb: "att inneh\xE5lla" },
          set: { unit: "objekt", verb: "att inneh\xE5lla" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "regulj\xE4rt uttryck",
          email: "e-postadress",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-datum och tid",
          date: "ISO-datum",
          time: "ISO-tid",
          duration: "ISO-varaktighet",
          ipv4: "IPv4-intervall",
          ipv6: "IPv6-intervall",
          cidrv4: "IPv4-spektrum",
          cidrv6: "IPv6-spektrum",
          base64: "base64-kodad str\xE4ng",
          base64url: "base64url-kodad str\xE4ng",
          json_string: "JSON-str\xE4ng",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "mall-literal"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "antal",
          array: "lista"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
              }
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
              return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
              }
              return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
              return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
            case "unrecognized_keys":
              return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
            case "invalid_union":
              return "Ogiltig input";
            case "invalid_element":
              return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
            default:
              return `Ogiltig input`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ta.js
  function ta_default() {
    return {
      localeError: error38()
    };
  }
  var error38;
  var init_ta = __esm({
    "node_modules/zod/v4/locales/ta.js"() {
      init_util();
      error38 = () => {
        const Sizable = {
          string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
          file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
          array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
          set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
          email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
          date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
          time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
          duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
          ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
          ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
          cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
          cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
          base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
          base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
          json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
          e164: "E.164 \u0B8E\u0BA3\u0BCD",
          jwt: "JWT",
          template_literal: "input"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0B8E\u0BA3\u0BCD",
          array: "\u0B85\u0BA3\u0BBF",
          null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
              }
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
              }
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
              }
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
              if (_issue.format === "ends_with")
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
              if (_issue.format === "includes")
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
              if (_issue.format === "regex")
                return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            case "unrecognized_keys":
              return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
            case "invalid_union":
              return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
            case "invalid_element":
              return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
            default:
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/th.js
  function th_default() {
    return {
      localeError: error39()
    };
  }
  var error39;
  var init_th = __esm({
    "node_modules/zod/v4/locales/th.js"() {
      init_util();
      error39 = () => {
        const Sizable = {
          string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
          file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
          array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
          set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
          email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
          url: "URL",
          emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
          date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
          time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
          duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
          ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
          ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
          cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
          cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
          base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
          base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
          json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
          e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
          jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
          template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
          array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
          null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
              }
              return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
              return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
              }
              if (_issue.format === "ends_with")
                return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
              if (_issue.format === "regex")
                return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
            case "unrecognized_keys":
              return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
            case "invalid_union":
              return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
            case "invalid_element":
              return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
            default:
              return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/tr.js
  function tr_default() {
    return {
      localeError: error40()
    };
  }
  var error40;
  var init_tr = __esm({
    "node_modules/zod/v4/locales/tr.js"() {
      init_util();
      error40 = () => {
        const Sizable = {
          string: { unit: "karakter", verb: "olmal\u0131" },
          file: { unit: "bayt", verb: "olmal\u0131" },
          array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
          set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "girdi",
          email: "e-posta adresi",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO tarih ve saat",
          date: "ISO tarih",
          time: "ISO saat",
          duration: "ISO s\xFCre",
          ipv4: "IPv4 adresi",
          ipv6: "IPv6 adresi",
          cidrv4: "IPv4 aral\u0131\u011F\u0131",
          cidrv6: "IPv6 aral\u0131\u011F\u0131",
          base64: "base64 ile \u015Fifrelenmi\u015F metin",
          base64url: "base64url ile \u015Fifrelenmi\u015F metin",
          json_string: "JSON dizesi",
          e164: "E.164 say\u0131s\u0131",
          jwt: "JWT",
          template_literal: "\u015Eablon dizesi"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
              }
              return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
              return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
              if (_issue.format === "ends_with")
                return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
              if (_issue.format === "includes")
                return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
              if (_issue.format === "regex")
                return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
              return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
            case "unrecognized_keys":
              return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
            case "invalid_union":
              return "Ge\xE7ersiz de\u011Fer";
            case "invalid_element":
              return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
            default:
              return `Ge\xE7ersiz de\u011Fer`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/uk.js
  function uk_default() {
    return {
      localeError: error41()
    };
  }
  var error41;
  var init_uk = __esm({
    "node_modules/zod/v4/locales/uk.js"() {
      init_util();
      error41 = () => {
        const Sizable = {
          string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
          file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
          array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
          set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
          email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
          url: "URL",
          emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
          date: "\u0434\u0430\u0442\u0430 ISO",
          time: "\u0447\u0430\u0441 ISO",
          duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
          ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
          ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
          cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
          cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
          base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
          base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
          json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
          e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
          jwt: "JWT",
          template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0447\u0438\u0441\u043B\u043E",
          array: "\u043C\u0430\u0441\u0438\u0432"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
              }
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
            case "unrecognized_keys":
              return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
            case "invalid_union":
              return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
            case "invalid_element":
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
            default:
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/ua.js
  function ua_default() {
    return uk_default();
  }
  var init_ua = __esm({
    "node_modules/zod/v4/locales/ua.js"() {
      init_uk();
    }
  });

  // node_modules/zod/v4/locales/ur.js
  function ur_default() {
    return {
      localeError: error42()
    };
  }
  var error42;
  var init_ur = __esm({
    "node_modules/zod/v4/locales/ur.js"() {
      init_util();
      error42 = () => {
        const Sizable = {
          string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
          file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
          array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
          set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0627\u0646 \u067E\u0679",
          email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
          url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
          emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
          uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
          uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
          uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
          nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
          guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
          cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
          cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
          ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
          xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
          ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
          datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
          date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
          time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
          duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
          ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
          ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
          cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
          cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
          base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
          base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
          json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
          e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
          jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
          template_literal: "\u0627\u0646 \u067E\u0679"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u0646\u0645\u0628\u0631",
          array: "\u0622\u0631\u06D2",
          null: "\u0646\u0644"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
              }
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
              return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
              }
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
              }
              if (_issue.format === "ends_with")
                return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
              if (_issue.format === "includes")
                return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
              if (_issue.format === "regex")
                return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
              return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            case "unrecognized_keys":
              return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
            case "invalid_key":
              return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
            case "invalid_union":
              return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
            case "invalid_element":
              return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
            default:
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/uz.js
  function uz_default() {
    return {
      localeError: error43()
    };
  }
  var error43;
  var init_uz = __esm({
    "node_modules/zod/v4/locales/uz.js"() {
      init_util();
      error43 = () => {
        const Sizable = {
          string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
          file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
          array: { unit: "element", verb: "bo\u2018lishi kerak" },
          set: { unit: "element", verb: "bo\u2018lishi kerak" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "kirish",
          email: "elektron pochta manzili",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO sana va vaqti",
          date: "ISO sana",
          time: "ISO vaqt",
          duration: "ISO davomiylik",
          ipv4: "IPv4 manzil",
          ipv6: "IPv6 manzil",
          mac: "MAC manzil",
          cidrv4: "IPv4 diapazon",
          cidrv6: "IPv6 diapazon",
          base64: "base64 kodlangan satr",
          base64url: "base64url kodlangan satr",
          json_string: "JSON satr",
          e164: "E.164 raqam",
          jwt: "JWT",
          template_literal: "kirish"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "raqam",
          array: "massiv"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
              }
              return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
              return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
              return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
              }
              return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
              if (_issue.format === "ends_with")
                return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
              if (_issue.format === "includes")
                return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
              if (_issue.format === "regex")
                return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
              return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
            case "unrecognized_keys":
              return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
            case "invalid_union":
              return "Noto\u2018g\u2018ri kirish";
            case "invalid_element":
              return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
            default:
              return `Noto\u2018g\u2018ri kirish`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/vi.js
  function vi_default() {
    return {
      localeError: error44()
    };
  }
  var error44;
  var init_vi = __esm({
    "node_modules/zod/v4/locales/vi.js"() {
      init_util();
      error44 = () => {
        const Sizable = {
          string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
          file: { unit: "byte", verb: "c\xF3" },
          array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
          set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u0111\u1EA7u v\xE0o",
          email: "\u0111\u1ECBa ch\u1EC9 email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ng\xE0y gi\u1EDD ISO",
          date: "ng\xE0y ISO",
          time: "gi\u1EDD ISO",
          duration: "kho\u1EA3ng th\u1EDDi gian ISO",
          ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
          ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
          cidrv4: "d\u1EA3i IPv4",
          cidrv6: "d\u1EA3i IPv6",
          base64: "chu\u1ED7i m\xE3 h\xF3a base64",
          base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
          json_string: "chu\u1ED7i JSON",
          e164: "s\u1ED1 E.164",
          jwt: "JWT",
          template_literal: "\u0111\u1EA7u v\xE0o"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "s\u1ED1",
          array: "m\u1EA3ng"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
              }
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
              return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
              return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
            }
            case "not_multiple_of":
              return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
            case "unrecognized_keys":
              return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
            case "invalid_union":
              return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
            case "invalid_element":
              return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
            default:
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/zh-CN.js
  function zh_CN_default() {
    return {
      localeError: error45()
    };
  }
  var error45;
  var init_zh_CN = __esm({
    "node_modules/zod/v4/locales/zh-CN.js"() {
      init_util();
      error45 = () => {
        const Sizable = {
          string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
          file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
          array: { unit: "\u9879", verb: "\u5305\u542B" },
          set: { unit: "\u9879", verb: "\u5305\u542B" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u8F93\u5165",
          email: "\u7535\u5B50\u90AE\u4EF6",
          url: "URL",
          emoji: "\u8868\u60C5\u7B26\u53F7",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO\u65E5\u671F\u65F6\u95F4",
          date: "ISO\u65E5\u671F",
          time: "ISO\u65F6\u95F4",
          duration: "ISO\u65F6\u957F",
          ipv4: "IPv4\u5730\u5740",
          ipv6: "IPv6\u5730\u5740",
          cidrv4: "IPv4\u7F51\u6BB5",
          cidrv6: "IPv6\u7F51\u6BB5",
          base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
          base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
          json_string: "JSON\u5B57\u7B26\u4E32",
          e164: "E.164\u53F7\u7801",
          jwt: "JWT",
          template_literal: "\u8F93\u5165"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "\u6570\u5B57",
          array: "\u6570\u7EC4",
          null: "\u7A7A\u503C(null)"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
              }
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
              return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
              if (_issue.format === "ends_with")
                return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
              if (_issue.format === "includes")
                return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
              return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
            case "unrecognized_keys":
              return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
            case "invalid_union":
              return "\u65E0\u6548\u8F93\u5165";
            case "invalid_element":
              return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
            default:
              return `\u65E0\u6548\u8F93\u5165`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/zh-TW.js
  function zh_TW_default() {
    return {
      localeError: error46()
    };
  }
  var error46;
  var init_zh_TW = __esm({
    "node_modules/zod/v4/locales/zh-TW.js"() {
      init_util();
      error46 = () => {
        const Sizable = {
          string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
          file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
          array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
          set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u8F38\u5165",
          email: "\u90F5\u4EF6\u5730\u5740",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO \u65E5\u671F\u6642\u9593",
          date: "ISO \u65E5\u671F",
          time: "ISO \u6642\u9593",
          duration: "ISO \u671F\u9593",
          ipv4: "IPv4 \u4F4D\u5740",
          ipv6: "IPv6 \u4F4D\u5740",
          cidrv4: "IPv4 \u7BC4\u570D",
          cidrv6: "IPv6 \u7BC4\u570D",
          base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
          base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
          json_string: "JSON \u5B57\u4E32",
          e164: "E.164 \u6578\u503C",
          jwt: "JWT",
          template_literal: "\u8F38\u5165"
        };
        const TypeDictionary = {
          nan: "NaN"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
              }
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
              return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing) {
                return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
              }
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with") {
                return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
              }
              if (_issue.format === "ends_with")
                return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
              if (_issue.format === "includes")
                return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
              return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
            case "unrecognized_keys":
              return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
            case "invalid_key":
              return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
            case "invalid_union":
              return "\u7121\u6548\u7684\u8F38\u5165\u503C";
            case "invalid_element":
              return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
            default:
              return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/yo.js
  function yo_default() {
    return {
      localeError: error47()
    };
  }
  var error47;
  var init_yo = __esm({
    "node_modules/zod/v4/locales/yo.js"() {
      init_util();
      error47 = () => {
        const Sizable = {
          string: { unit: "\xE0mi", verb: "n\xED" },
          file: { unit: "bytes", verb: "n\xED" },
          array: { unit: "nkan", verb: "n\xED" },
          set: { unit: "nkan", verb: "n\xED" }
        };
        function getSizing(origin) {
          return Sizable[origin] ?? null;
        }
        const FormatDictionary = {
          regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
          email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "\xE0k\xF3k\xF2 ISO",
          date: "\u1ECDj\u1ECD\u0301 ISO",
          time: "\xE0k\xF3k\xF2 ISO",
          duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
          ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
          ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
          cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
          cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
          base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
          base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
          json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
          e164: "n\u1ECD\u0301mb\xE0 E.164",
          jwt: "JWT",
          template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
        };
        const TypeDictionary = {
          nan: "NaN",
          number: "n\u1ECD\u0301mb\xE0",
          array: "akop\u1ECD"
        };
        return (issue2) => {
          switch (issue2.code) {
            case "invalid_type": {
              const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
              const receivedType = parsedType(issue2.input);
              const received = TypeDictionary[receivedType] ?? receivedType;
              if (/^[A-Z]/.test(issue2.expected)) {
                return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
              }
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
            }
            case "invalid_value":
              if (issue2.values.length === 1)
                return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
              return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
            case "too_big": {
              const adj = issue2.inclusive ? "<=" : "<";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
            }
            case "too_small": {
              const adj = issue2.inclusive ? ">=" : ">";
              const sizing = getSizing(issue2.origin);
              if (sizing)
                return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
            }
            case "invalid_format": {
              const _issue = issue2;
              if (_issue.format === "starts_with")
                return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
              if (_issue.format === "ends_with")
                return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
              if (_issue.format === "includes")
                return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
              if (_issue.format === "regex")
                return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
              return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
            }
            case "not_multiple_of":
              return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
            case "unrecognized_keys":
              return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
            case "invalid_key":
              return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
            case "invalid_union":
              return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
            case "invalid_element":
              return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
            default:
              return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          }
        };
      };
    }
  });

  // node_modules/zod/v4/locales/index.js
  var locales_exports = {};
  __export(locales_exports, {
    ar: () => ar_default,
    az: () => az_default,
    be: () => be_default,
    bg: () => bg_default,
    ca: () => ca_default,
    cs: () => cs_default,
    da: () => da_default,
    de: () => de_default,
    en: () => en_default,
    eo: () => eo_default,
    es: () => es_default,
    fa: () => fa_default,
    fi: () => fi_default,
    fr: () => fr_default,
    frCA: () => fr_CA_default,
    he: () => he_default,
    hu: () => hu_default,
    hy: () => hy_default,
    id: () => id_default,
    is: () => is_default,
    it: () => it_default,
    ja: () => ja_default,
    ka: () => ka_default,
    kh: () => kh_default,
    km: () => km_default,
    ko: () => ko_default,
    lt: () => lt_default,
    mk: () => mk_default,
    ms: () => ms_default,
    nl: () => nl_default,
    no: () => no_default,
    ota: () => ota_default,
    pl: () => pl_default,
    ps: () => ps_default,
    pt: () => pt_default,
    ru: () => ru_default,
    sl: () => sl_default,
    sv: () => sv_default,
    ta: () => ta_default,
    th: () => th_default,
    tr: () => tr_default,
    ua: () => ua_default,
    uk: () => uk_default,
    ur: () => ur_default,
    uz: () => uz_default,
    vi: () => vi_default,
    yo: () => yo_default,
    zhCN: () => zh_CN_default,
    zhTW: () => zh_TW_default
  });
  var init_locales = __esm({
    "node_modules/zod/v4/locales/index.js"() {
      init_ar();
      init_az();
      init_be();
      init_bg();
      init_ca();
      init_cs();
      init_da();
      init_de();
      init_en();
      init_eo();
      init_es();
      init_fa();
      init_fi();
      init_fr();
      init_fr_CA();
      init_he();
      init_hu();
      init_hy();
      init_id();
      init_is();
      init_it();
      init_ja();
      init_ka();
      init_kh();
      init_km();
      init_ko();
      init_lt();
      init_mk();
      init_ms();
      init_nl();
      init_no();
      init_ota();
      init_ps();
      init_pl();
      init_pt();
      init_ru();
      init_sl();
      init_sv();
      init_ta();
      init_th();
      init_tr();
      init_ua();
      init_uk();
      init_ur();
      init_uz();
      init_vi();
      init_zh_CN();
      init_zh_TW();
      init_yo();
    }
  });

  // node_modules/zod/v4/core/registries.js
  function registry() {
    return new $ZodRegistry();
  }
  var _a, $output, $input, $ZodRegistry, globalRegistry;
  var init_registries = __esm({
    "node_modules/zod/v4/core/registries.js"() {
      $output = /* @__PURE__ */ Symbol("ZodOutput");
      $input = /* @__PURE__ */ Symbol("ZodInput");
      $ZodRegistry = class {
        constructor() {
          this._map = /* @__PURE__ */ new WeakMap();
          this._idmap = /* @__PURE__ */ new Map();
        }
        add(schema, ..._meta) {
          const meta3 = _meta[0];
          this._map.set(schema, meta3);
          if (meta3 && typeof meta3 === "object" && "id" in meta3) {
            this._idmap.set(meta3.id, schema);
          }
          return this;
        }
        clear() {
          this._map = /* @__PURE__ */ new WeakMap();
          this._idmap = /* @__PURE__ */ new Map();
          return this;
        }
        remove(schema) {
          const meta3 = this._map.get(schema);
          if (meta3 && typeof meta3 === "object" && "id" in meta3) {
            this._idmap.delete(meta3.id);
          }
          this._map.delete(schema);
          return this;
        }
        get(schema) {
          const p = schema._zod.parent;
          if (p) {
            const pm = { ...this.get(p) ?? {} };
            delete pm.id;
            const f = { ...pm, ...this._map.get(schema) };
            return Object.keys(f).length ? f : void 0;
          }
          return this._map.get(schema);
        }
        has(schema) {
          return this._map.has(schema);
        }
      };
      (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
      globalRegistry = globalThis.__zod_globalRegistry;
    }
  });

  // node_modules/zod/v4/core/api.js
  // @__NO_SIDE_EFFECTS__
  function _string(Class2, params) {
    return new Class2({
      type: "string",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedString(Class2, params) {
    return new Class2({
      type: "string",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _email(Class2, params) {
    return new Class2({
      type: "string",
      format: "email",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _guid(Class2, params) {
    return new Class2({
      type: "string",
      format: "guid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v4",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v6",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv7(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v7",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _url(Class2, params) {
    return new Class2({
      type: "string",
      format: "url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _emoji2(Class2, params) {
    return new Class2({
      type: "string",
      format: "emoji",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nanoid(Class2, params) {
    return new Class2({
      type: "string",
      format: "nanoid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cuid2(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid2",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ulid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ulid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _xid(Class2, params) {
    return new Class2({
      type: "string",
      format: "xid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ksuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ksuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ipv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ipv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _mac(Class2, params) {
    return new Class2({
      type: "string",
      format: "mac",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cidrv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cidrv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _base64(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _base64url(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _e164(Class2, params) {
    return new Class2({
      type: "string",
      format: "e164",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _jwt(Class2, params) {
    return new Class2({
      type: "string",
      format: "jwt",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDateTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "datetime",
      check: "string_format",
      offset: false,
      local: false,
      precision: null,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDate(Class2, params) {
    return new Class2({
      type: "string",
      format: "date",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "time",
      check: "string_format",
      precision: null,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDuration(Class2, params) {
    return new Class2({
      type: "string",
      format: "duration",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _number(Class2, params) {
    return new Class2({
      type: "number",
      checks: [],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedNumber(Class2, params) {
    return new Class2({
      type: "number",
      coerce: true,
      checks: [],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "safeint",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _float32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _float64(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "int32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uint32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "uint32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _boolean(Class2, params) {
    return new Class2({
      type: "boolean",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedBoolean(Class2, params) {
    return new Class2({
      type: "boolean",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _bigint(Class2, params) {
    return new Class2({
      type: "bigint",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedBigint(Class2, params) {
    return new Class2({
      type: "bigint",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "int64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uint64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "uint64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _symbol(Class2, params) {
    return new Class2({
      type: "symbol",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _undefined2(Class2, params) {
    return new Class2({
      type: "undefined",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _null2(Class2, params) {
    return new Class2({
      type: "null",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _any(Class2) {
    return new Class2({
      type: "any"
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _unknown(Class2) {
    return new Class2({
      type: "unknown"
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _never(Class2, params) {
    return new Class2({
      type: "never",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _void(Class2, params) {
    return new Class2({
      type: "void",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _date(Class2, params) {
    return new Class2({
      type: "date",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedDate(Class2, params) {
    return new Class2({
      type: "date",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nan(Class2, params) {
    return new Class2({
      type: "nan",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lt(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lte(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _gt(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _gte(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _positive(params) {
    return /* @__PURE__ */ _gt(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _negative(params) {
    return /* @__PURE__ */ _lt(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _nonpositive(params) {
    return /* @__PURE__ */ _lte(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _nonnegative(params) {
    return /* @__PURE__ */ _gte(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _multipleOf(value, params) {
    return new $ZodCheckMultipleOf({
      check: "multiple_of",
      ...normalizeParams(params),
      value
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _maxSize(maximum, params) {
    return new $ZodCheckMaxSize({
      check: "max_size",
      ...normalizeParams(params),
      maximum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _minSize(minimum, params) {
    return new $ZodCheckMinSize({
      check: "min_size",
      ...normalizeParams(params),
      minimum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _size(size, params) {
    return new $ZodCheckSizeEquals({
      check: "size_equals",
      ...normalizeParams(params),
      size
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _maxLength(maximum, params) {
    const ch = new $ZodCheckMaxLength({
      check: "max_length",
      ...normalizeParams(params),
      maximum
    });
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _minLength(minimum, params) {
    return new $ZodCheckMinLength({
      check: "min_length",
      ...normalizeParams(params),
      minimum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _length(length, params) {
    return new $ZodCheckLengthEquals({
      check: "length_equals",
      ...normalizeParams(params),
      length
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _regex(pattern, params) {
    return new $ZodCheckRegex({
      check: "string_format",
      format: "regex",
      ...normalizeParams(params),
      pattern
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lowercase(params) {
    return new $ZodCheckLowerCase({
      check: "string_format",
      format: "lowercase",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uppercase(params) {
    return new $ZodCheckUpperCase({
      check: "string_format",
      format: "uppercase",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _includes(includes, params) {
    return new $ZodCheckIncludes({
      check: "string_format",
      format: "includes",
      ...normalizeParams(params),
      includes
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _startsWith(prefix, params) {
    return new $ZodCheckStartsWith({
      check: "string_format",
      format: "starts_with",
      ...normalizeParams(params),
      prefix
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _endsWith(suffix, params) {
    return new $ZodCheckEndsWith({
      check: "string_format",
      format: "ends_with",
      ...normalizeParams(params),
      suffix
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _property(property, schema, params) {
    return new $ZodCheckProperty({
      check: "property",
      property,
      schema,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _mime(types, params) {
    return new $ZodCheckMimeType({
      check: "mime_type",
      mime: types,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _overwrite(tx) {
    return new $ZodCheckOverwrite({
      check: "overwrite",
      tx
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _normalize(form) {
    return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
  }
  // @__NO_SIDE_EFFECTS__
  function _trim() {
    return /* @__PURE__ */ _overwrite((input) => input.trim());
  }
  // @__NO_SIDE_EFFECTS__
  function _toLowerCase() {
    return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
  }
  // @__NO_SIDE_EFFECTS__
  function _toUpperCase() {
    return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
  }
  // @__NO_SIDE_EFFECTS__
  function _slugify() {
    return /* @__PURE__ */ _overwrite((input) => slugify(input));
  }
  // @__NO_SIDE_EFFECTS__
  function _array(Class2, element, params) {
    return new Class2({
      type: "array",
      element,
      // get element() {
      //   return element;
      // },
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _union(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      ...normalizeParams(params)
    });
  }
  function _xor(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      inclusive: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _discriminatedUnion(Class2, discriminator, options, params) {
    return new Class2({
      type: "union",
      options,
      discriminator,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _intersection(Class2, left, right) {
    return new Class2({
      type: "intersection",
      left,
      right
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _tuple(Class2, items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new Class2({
      type: "tuple",
      items,
      rest,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _record(Class2, keyType, valueType, params) {
    return new Class2({
      type: "record",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _map(Class2, keyType, valueType, params) {
    return new Class2({
      type: "map",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _set(Class2, valueType, params) {
    return new Class2({
      type: "set",
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _enum(Class2, values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nativeEnum(Class2, entries, params) {
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _literal(Class2, value, params) {
    return new Class2({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _file(Class2, params) {
    return new Class2({
      type: "file",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _transform(Class2, fn) {
    return new Class2({
      type: "transform",
      transform: fn
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _optional(Class2, innerType) {
    return new Class2({
      type: "optional",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nullable(Class2, innerType) {
    return new Class2({
      type: "nullable",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _default(Class2, innerType, defaultValue) {
    return new Class2({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
      }
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nonoptional(Class2, innerType, params) {
    return new Class2({
      type: "nonoptional",
      innerType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _success(Class2, innerType) {
    return new Class2({
      type: "success",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _catch(Class2, innerType, catchValue) {
    return new Class2({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _pipe(Class2, in_, out) {
    return new Class2({
      type: "pipe",
      in: in_,
      out
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _readonly(Class2, innerType) {
    return new Class2({
      type: "readonly",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _templateLiteral(Class2, parts, params) {
    return new Class2({
      type: "template_literal",
      parts,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lazy(Class2, getter) {
    return new Class2({
      type: "lazy",
      getter
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _promise(Class2, innerType) {
    return new Class2({
      type: "promise",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _custom(Class2, fn, _params) {
    const norm = normalizeParams(_params);
    norm.abort ?? (norm.abort = true);
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...norm
    });
    return schema;
  }
  // @__NO_SIDE_EFFECTS__
  function _refine(Class2, fn, _params) {
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...normalizeParams(_params)
    });
    return schema;
  }
  // @__NO_SIDE_EFFECTS__
  function _superRefine(fn) {
    const ch = /* @__PURE__ */ _check((payload) => {
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(issue(issue2, payload.value, ch._zod.def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = ch);
          _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
          payload.issues.push(issue(_issue));
        }
      };
      return fn(payload.value, payload);
    });
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _check(fn, params) {
    const ch = new $ZodCheck({
      check: "custom",
      ...normalizeParams(params)
    });
    ch._zod.check = fn;
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function describe(description) {
    const ch = new $ZodCheck({ check: "describe" });
    ch._zod.onattach = [
      (inst) => {
        const existing = globalRegistry.get(inst) ?? {};
        globalRegistry.add(inst, { ...existing, description });
      }
    ];
    ch._zod.check = () => {
    };
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function meta(metadata) {
    const ch = new $ZodCheck({ check: "meta" });
    ch._zod.onattach = [
      (inst) => {
        const existing = globalRegistry.get(inst) ?? {};
        globalRegistry.add(inst, { ...existing, ...metadata });
      }
    ];
    ch._zod.check = () => {
    };
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _stringbool(Classes, _params) {
    const params = normalizeParams(_params);
    let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
    let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (params.case !== "sensitive") {
      truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
      falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    }
    const truthySet = new Set(truthyArray);
    const falsySet = new Set(falsyArray);
    const _Codec = Classes.Codec ?? $ZodCodec;
    const _Boolean = Classes.Boolean ?? $ZodBoolean;
    const _String = Classes.String ?? $ZodString;
    const stringSchema = new _String({ type: "string", error: params.error });
    const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
    const codec2 = new _Codec({
      type: "pipe",
      in: stringSchema,
      out: booleanSchema,
      transform: ((input, payload) => {
        let data = input;
        if (params.case !== "sensitive")
          data = data.toLowerCase();
        if (truthySet.has(data)) {
          return true;
        } else if (falsySet.has(data)) {
          return false;
        } else {
          payload.issues.push({
            code: "invalid_value",
            expected: "stringbool",
            values: [...truthySet, ...falsySet],
            input: payload.value,
            inst: codec2,
            continue: false
          });
          return {};
        }
      }),
      reverseTransform: ((input, _payload) => {
        if (input === true) {
          return truthyArray[0] || "true";
        } else {
          return falsyArray[0] || "false";
        }
      }),
      error: params.error
    });
    return codec2;
  }
  // @__NO_SIDE_EFFECTS__
  function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
    const params = normalizeParams(_params);
    const def = {
      ...normalizeParams(_params),
      check: "string_format",
      type: "string",
      format,
      fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
      ...params
    };
    if (fnOrRegex instanceof RegExp) {
      def.pattern = fnOrRegex;
    }
    const inst = new Class2(def);
    return inst;
  }
  var TimePrecision;
  var init_api = __esm({
    "node_modules/zod/v4/core/api.js"() {
      init_checks();
      init_registries();
      init_schemas();
      init_util();
      TimePrecision = {
        Any: null,
        Minute: -1,
        Second: 0,
        Millisecond: 3,
        Microsecond: 6
      };
    }
  });

  // node_modules/zod/v4/core/to-json-schema.js
  function initializeContext(params) {
    let target = params?.target ?? "draft-2020-12";
    if (target === "draft-4")
      target = "draft-04";
    if (target === "draft-7")
      target = "draft-07";
    return {
      processors: params.processors ?? {},
      metadataRegistry: params?.metadata ?? globalRegistry,
      target,
      unrepresentable: params?.unrepresentable ?? "throw",
      override: params?.override ?? (() => {
      }),
      io: params?.io ?? "output",
      counter: 0,
      seen: /* @__PURE__ */ new Map(),
      cycles: params?.cycles ?? "ref",
      reused: params?.reused ?? "inline",
      external: params?.external ?? void 0
    };
  }
  function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const seen = ctx.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    ctx.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      if (schema._zod.processJSONSchema) {
        schema._zod.processJSONSchema(ctx, result.schema, params);
      } else {
        const _json = result.schema;
        const processor = ctx.processors[def.type];
        if (!processor) {
          throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
        }
        processor(schema, ctx, _json, params);
      }
      const parent = schema._zod.parent;
      if (parent) {
        if (!result.ref)
          result.ref = parent;
        process2(parent, ctx, params);
        ctx.seen.get(parent).isParent = true;
      }
    }
    const meta3 = ctx.metadataRegistry.get(schema);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (ctx.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (ctx.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = ctx.seen.get(schema);
    return _result.schema;
  }
  function extractDefs(ctx, schema) {
    const root = ctx.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const idToSchema = /* @__PURE__ */ new Map();
    for (const entry of ctx.seen.entries()) {
      const id = ctx.metadataRegistry.get(entry[0])?.id;
      if (id) {
        const existing = idToSchema.get(id);
        if (existing && existing !== entry[0]) {
          throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
        }
        idToSchema.set(id, entry[0]);
      }
    }
    const makeURI = (entry) => {
      const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
      if (ctx.external) {
        const externalId = ctx.external.registry.get(entry[0])?.id;
        const uriGenerator = ctx.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (ctx.cycles === "throw") {
      for (const entry of ctx.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (ctx.external) {
        const ext = ctx.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = ctx.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (ctx.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
  }
  function finalize(ctx, schema) {
    const root = ctx.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const flattenRef = (zodSchema) => {
      const seen = ctx.seen.get(zodSchema);
      if (seen.ref === null)
        return;
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref);
        const refSeen = ctx.seen.get(ref);
        const refSchema = refSeen.schema;
        if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
        }
        Object.assign(schema2, _cached);
        const isParentRef = zodSchema._zod.parent === ref;
        if (isParentRef) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (!(key in _cached)) {
              delete schema2[key];
            }
          }
        }
        if (refSchema.$ref && refSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
      const parent = zodSchema._zod.parent;
      if (parent && parent !== ref) {
        flattenRef(parent);
        const parentSeen = ctx.seen.get(parent);
        if (parentSeen?.schema.$ref) {
          schema2.$ref = parentSeen.schema.$ref;
          if (parentSeen.def) {
            for (const key in schema2) {
              if (key === "$ref" || key === "allOf")
                continue;
              if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
                delete schema2[key];
              }
            }
          }
        }
      }
      ctx.override({
        zodSchema,
        jsonSchema: schema2,
        path: seen.path ?? []
      });
    };
    for (const entry of [...ctx.seen.entries()].reverse()) {
      flattenRef(entry[0]);
    }
    const result = {};
    if (ctx.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (ctx.target === "draft-07") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (ctx.target === "draft-04") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (ctx.target === "openapi-3.0") {
    } else {
    }
    if (ctx.external?.uri) {
      const id = ctx.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = ctx.external.uri(id);
    }
    Object.assign(result, root.def ?? root.schema);
    const defs = ctx.external?.defs ?? {};
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (ctx.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (ctx.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      const finalized = JSON.parse(JSON.stringify(result));
      Object.defineProperty(finalized, "~standard", {
        value: {
          ...schema["~standard"],
          jsonSchema: {
            input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
            output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
          }
        },
        enumerable: false,
        writable: false
      });
      return finalized;
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
  function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
    if (ctx.seen.has(_schema))
      return false;
    ctx.seen.add(_schema);
    const def = _schema._zod.def;
    if (def.type === "transform")
      return true;
    if (def.type === "array")
      return isTransforming(def.element, ctx);
    if (def.type === "set")
      return isTransforming(def.valueType, ctx);
    if (def.type === "lazy")
      return isTransforming(def.getter(), ctx);
    if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
      return isTransforming(def.innerType, ctx);
    }
    if (def.type === "intersection") {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    if (def.type === "record" || def.type === "map") {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    if (def.type === "pipe") {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    if (def.type === "object") {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    if (def.type === "union") {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    if (def.type === "tuple") {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    return false;
  }
  var createToJSONSchemaMethod, createStandardJSONSchemaMethod;
  var init_to_json_schema = __esm({
    "node_modules/zod/v4/core/to-json-schema.js"() {
      init_registries();
      createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
        const ctx = initializeContext({ ...params, processors });
        process2(schema, ctx);
        extractDefs(ctx, schema);
        return finalize(ctx, schema);
      };
      createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
        const { libraryOptions, target } = params ?? {};
        const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
        process2(schema, ctx);
        extractDefs(ctx, schema);
        return finalize(ctx, schema);
      };
    }
  });

  // node_modules/zod/v4/core/json-schema-processors.js
  function toJSONSchema(input, params) {
    if ("_idmap" in input) {
      const registry2 = input;
      const ctx2 = initializeContext({ ...params, processors: allProcessors });
      const defs = {};
      for (const entry of registry2._idmap.entries()) {
        const [_, schema] = entry;
        process2(schema, ctx2);
      }
      const schemas = {};
      const external = {
        registry: registry2,
        uri: params?.uri,
        defs
      };
      ctx2.external = external;
      for (const entry of registry2._idmap.entries()) {
        const [key, schema] = entry;
        extractDefs(ctx2, schema);
        schemas[key] = finalize(ctx2, schema);
      }
      if (Object.keys(defs).length > 0) {
        const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
        schemas.__shared = {
          [defsSegment]: defs
        };
      }
      return { schemas };
    }
    const ctx = initializeContext({ ...params, processors: allProcessors });
    process2(input, ctx);
    extractDefs(ctx, input);
    return finalize(ctx, input);
  }
  var formatMap, stringProcessor, numberProcessor, booleanProcessor, bigintProcessor, symbolProcessor, nullProcessor, undefinedProcessor, voidProcessor, neverProcessor, anyProcessor, unknownProcessor, dateProcessor, enumProcessor, literalProcessor, nanProcessor, templateLiteralProcessor, fileProcessor, successProcessor, customProcessor, functionProcessor, transformProcessor, mapProcessor, setProcessor, arrayProcessor, objectProcessor, unionProcessor, intersectionProcessor, tupleProcessor, recordProcessor, nullableProcessor, nonoptionalProcessor, defaultProcessor, prefaultProcessor, catchProcessor, pipeProcessor, readonlyProcessor, promiseProcessor, optionalProcessor, lazyProcessor, allProcessors;
  var init_json_schema_processors = __esm({
    "node_modules/zod/v4/core/json-schema-processors.js"() {
      init_to_json_schema();
      init_util();
      formatMap = {
        guid: "uuid",
        url: "uri",
        datetime: "date-time",
        json_string: "json-string",
        regex: ""
        // do not set
      };
      stringProcessor = (schema, ctx, _json, _params) => {
        const json2 = _json;
        json2.type = "string";
        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
        if (typeof minimum === "number")
          json2.minLength = minimum;
        if (typeof maximum === "number")
          json2.maxLength = maximum;
        if (format) {
          json2.format = formatMap[format] ?? format;
          if (json2.format === "")
            delete json2.format;
          if (format === "time") {
            delete json2.format;
          }
        }
        if (contentEncoding)
          json2.contentEncoding = contentEncoding;
        if (patterns && patterns.size > 0) {
          const regexes = [...patterns];
          if (regexes.length === 1)
            json2.pattern = regexes[0].source;
          else if (regexes.length > 1) {
            json2.allOf = [
              ...regexes.map((regex) => ({
                ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
                pattern: regex.source
              }))
            ];
          }
        }
      };
      numberProcessor = (schema, ctx, _json, _params) => {
        const json2 = _json;
        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
        if (typeof format === "string" && format.includes("int"))
          json2.type = "integer";
        else
          json2.type = "number";
        if (typeof exclusiveMinimum === "number") {
          if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
            json2.minimum = exclusiveMinimum;
            json2.exclusiveMinimum = true;
          } else {
            json2.exclusiveMinimum = exclusiveMinimum;
          }
        }
        if (typeof minimum === "number") {
          json2.minimum = minimum;
          if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
            if (exclusiveMinimum >= minimum)
              delete json2.minimum;
            else
              delete json2.exclusiveMinimum;
          }
        }
        if (typeof exclusiveMaximum === "number") {
          if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
            json2.maximum = exclusiveMaximum;
            json2.exclusiveMaximum = true;
          } else {
            json2.exclusiveMaximum = exclusiveMaximum;
          }
        }
        if (typeof maximum === "number") {
          json2.maximum = maximum;
          if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
            if (exclusiveMaximum <= maximum)
              delete json2.maximum;
            else
              delete json2.exclusiveMaximum;
          }
        }
        if (typeof multipleOf === "number")
          json2.multipleOf = multipleOf;
      };
      booleanProcessor = (_schema, _ctx, json2, _params) => {
        json2.type = "boolean";
      };
      bigintProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("BigInt cannot be represented in JSON Schema");
        }
      };
      symbolProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Symbols cannot be represented in JSON Schema");
        }
      };
      nullProcessor = (_schema, ctx, json2, _params) => {
        if (ctx.target === "openapi-3.0") {
          json2.type = "string";
          json2.nullable = true;
          json2.enum = [null];
        } else {
          json2.type = "null";
        }
      };
      undefinedProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Undefined cannot be represented in JSON Schema");
        }
      };
      voidProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Void cannot be represented in JSON Schema");
        }
      };
      neverProcessor = (_schema, _ctx, json2, _params) => {
        json2.not = {};
      };
      anyProcessor = (_schema, _ctx, _json, _params) => {
      };
      unknownProcessor = (_schema, _ctx, _json, _params) => {
      };
      dateProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Date cannot be represented in JSON Schema");
        }
      };
      enumProcessor = (schema, _ctx, json2, _params) => {
        const def = schema._zod.def;
        const values = getEnumValues(def.entries);
        if (values.every((v) => typeof v === "number"))
          json2.type = "number";
        if (values.every((v) => typeof v === "string"))
          json2.type = "string";
        json2.enum = values;
      };
      literalProcessor = (schema, ctx, json2, _params) => {
        const def = schema._zod.def;
        const vals = [];
        for (const val of def.values) {
          if (val === void 0) {
            if (ctx.unrepresentable === "throw") {
              throw new Error("Literal `undefined` cannot be represented in JSON Schema");
            } else {
            }
          } else if (typeof val === "bigint") {
            if (ctx.unrepresentable === "throw") {
              throw new Error("BigInt literals cannot be represented in JSON Schema");
            } else {
              vals.push(Number(val));
            }
          } else {
            vals.push(val);
          }
        }
        if (vals.length === 0) {
        } else if (vals.length === 1) {
          const val = vals[0];
          json2.type = val === null ? "null" : typeof val;
          if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
            json2.enum = [val];
          } else {
            json2.const = val;
          }
        } else {
          if (vals.every((v) => typeof v === "number"))
            json2.type = "number";
          if (vals.every((v) => typeof v === "string"))
            json2.type = "string";
          if (vals.every((v) => typeof v === "boolean"))
            json2.type = "boolean";
          if (vals.every((v) => v === null))
            json2.type = "null";
          json2.enum = vals;
        }
      };
      nanProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("NaN cannot be represented in JSON Schema");
        }
      };
      templateLiteralProcessor = (schema, _ctx, json2, _params) => {
        const _json = json2;
        const pattern = schema._zod.pattern;
        if (!pattern)
          throw new Error("Pattern not found in template literal");
        _json.type = "string";
        _json.pattern = pattern.source;
      };
      fileProcessor = (schema, _ctx, json2, _params) => {
        const _json = json2;
        const file2 = {
          type: "string",
          format: "binary",
          contentEncoding: "binary"
        };
        const { minimum, maximum, mime } = schema._zod.bag;
        if (minimum !== void 0)
          file2.minLength = minimum;
        if (maximum !== void 0)
          file2.maxLength = maximum;
        if (mime) {
          if (mime.length === 1) {
            file2.contentMediaType = mime[0];
            Object.assign(_json, file2);
          } else {
            Object.assign(_json, file2);
            _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
          }
        } else {
          Object.assign(_json, file2);
        }
      };
      successProcessor = (_schema, _ctx, json2, _params) => {
        json2.type = "boolean";
      };
      customProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Custom types cannot be represented in JSON Schema");
        }
      };
      functionProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Function types cannot be represented in JSON Schema");
        }
      };
      transformProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Transforms cannot be represented in JSON Schema");
        }
      };
      mapProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Map cannot be represented in JSON Schema");
        }
      };
      setProcessor = (_schema, ctx, _json, _params) => {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Set cannot be represented in JSON Schema");
        }
      };
      arrayProcessor = (schema, ctx, _json, params) => {
        const json2 = _json;
        const def = schema._zod.def;
        const { minimum, maximum } = schema._zod.bag;
        if (typeof minimum === "number")
          json2.minItems = minimum;
        if (typeof maximum === "number")
          json2.maxItems = maximum;
        json2.type = "array";
        json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
      };
      objectProcessor = (schema, ctx, _json, params) => {
        const json2 = _json;
        const def = schema._zod.def;
        json2.type = "object";
        json2.properties = {};
        const shape = def.shape;
        for (const key in shape) {
          json2.properties[key] = process2(shape[key], ctx, {
            ...params,
            path: [...params.path, "properties", key]
          });
        }
        const allKeys = new Set(Object.keys(shape));
        const requiredKeys = new Set([...allKeys].filter((key) => {
          const v = def.shape[key]._zod;
          if (ctx.io === "input") {
            return v.optin === void 0;
          } else {
            return v.optout === void 0;
          }
        }));
        if (requiredKeys.size > 0) {
          json2.required = Array.from(requiredKeys);
        }
        if (def.catchall?._zod.def.type === "never") {
          json2.additionalProperties = false;
        } else if (!def.catchall) {
          if (ctx.io === "output")
            json2.additionalProperties = false;
        } else if (def.catchall) {
          json2.additionalProperties = process2(def.catchall, ctx, {
            ...params,
            path: [...params.path, "additionalProperties"]
          });
        }
      };
      unionProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        const isExclusive = def.inclusive === false;
        const options = def.options.map((x, i) => process2(x, ctx, {
          ...params,
          path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
        }));
        if (isExclusive) {
          json2.oneOf = options;
        } else {
          json2.anyOf = options;
        }
      };
      intersectionProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        const a = process2(def.left, ctx, {
          ...params,
          path: [...params.path, "allOf", 0]
        });
        const b = process2(def.right, ctx, {
          ...params,
          path: [...params.path, "allOf", 1]
        });
        const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
        const allOf = [
          ...isSimpleIntersection(a) ? a.allOf : [a],
          ...isSimpleIntersection(b) ? b.allOf : [b]
        ];
        json2.allOf = allOf;
      };
      tupleProcessor = (schema, ctx, _json, params) => {
        const json2 = _json;
        const def = schema._zod.def;
        json2.type = "array";
        const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
        const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
        const prefixItems = def.items.map((x, i) => process2(x, ctx, {
          ...params,
          path: [...params.path, prefixPath, i]
        }));
        const rest = def.rest ? process2(def.rest, ctx, {
          ...params,
          path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
        }) : null;
        if (ctx.target === "draft-2020-12") {
          json2.prefixItems = prefixItems;
          if (rest) {
            json2.items = rest;
          }
        } else if (ctx.target === "openapi-3.0") {
          json2.items = {
            anyOf: prefixItems
          };
          if (rest) {
            json2.items.anyOf.push(rest);
          }
          json2.minItems = prefixItems.length;
          if (!rest) {
            json2.maxItems = prefixItems.length;
          }
        } else {
          json2.items = prefixItems;
          if (rest) {
            json2.additionalItems = rest;
          }
        }
        const { minimum, maximum } = schema._zod.bag;
        if (typeof minimum === "number")
          json2.minItems = minimum;
        if (typeof maximum === "number")
          json2.maxItems = maximum;
      };
      recordProcessor = (schema, ctx, _json, params) => {
        const json2 = _json;
        const def = schema._zod.def;
        json2.type = "object";
        const keyType = def.keyType;
        const keyBag = keyType._zod.bag;
        const patterns = keyBag?.patterns;
        if (def.mode === "loose" && patterns && patterns.size > 0) {
          const valueSchema = process2(def.valueType, ctx, {
            ...params,
            path: [...params.path, "patternProperties", "*"]
          });
          json2.patternProperties = {};
          for (const pattern of patterns) {
            json2.patternProperties[pattern.source] = valueSchema;
          }
        } else {
          if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
            json2.propertyNames = process2(def.keyType, ctx, {
              ...params,
              path: [...params.path, "propertyNames"]
            });
          }
          json2.additionalProperties = process2(def.valueType, ctx, {
            ...params,
            path: [...params.path, "additionalProperties"]
          });
        }
        const keyValues = keyType._zod.values;
        if (keyValues) {
          const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
          if (validKeyValues.length > 0) {
            json2.required = validKeyValues;
          }
        }
      };
      nullableProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        const inner = process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        if (ctx.target === "openapi-3.0") {
          seen.ref = def.innerType;
          json2.nullable = true;
        } else {
          json2.anyOf = [inner, { type: "null" }];
        }
      };
      nonoptionalProcessor = (schema, ctx, _json, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
      };
      defaultProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
        json2.default = JSON.parse(JSON.stringify(def.defaultValue));
      };
      prefaultProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
        if (ctx.io === "input")
          json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
      };
      catchProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
        let catchValue;
        try {
          catchValue = def.catchValue(void 0);
        } catch {
          throw new Error("Dynamic catch values are not supported in JSON Schema");
        }
        json2.default = catchValue;
      };
      pipeProcessor = (schema, ctx, _json, params) => {
        const def = schema._zod.def;
        const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
        process2(innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = innerType;
      };
      readonlyProcessor = (schema, ctx, json2, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
        json2.readOnly = true;
      };
      promiseProcessor = (schema, ctx, _json, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
      };
      optionalProcessor = (schema, ctx, _json, params) => {
        const def = schema._zod.def;
        process2(def.innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = def.innerType;
      };
      lazyProcessor = (schema, ctx, _json, params) => {
        const innerType = schema._zod.innerType;
        process2(innerType, ctx, params);
        const seen = ctx.seen.get(schema);
        seen.ref = innerType;
      };
      allProcessors = {
        string: stringProcessor,
        number: numberProcessor,
        boolean: booleanProcessor,
        bigint: bigintProcessor,
        symbol: symbolProcessor,
        null: nullProcessor,
        undefined: undefinedProcessor,
        void: voidProcessor,
        never: neverProcessor,
        any: anyProcessor,
        unknown: unknownProcessor,
        date: dateProcessor,
        enum: enumProcessor,
        literal: literalProcessor,
        nan: nanProcessor,
        template_literal: templateLiteralProcessor,
        file: fileProcessor,
        success: successProcessor,
        custom: customProcessor,
        function: functionProcessor,
        transform: transformProcessor,
        map: mapProcessor,
        set: setProcessor,
        array: arrayProcessor,
        object: objectProcessor,
        union: unionProcessor,
        intersection: intersectionProcessor,
        tuple: tupleProcessor,
        record: recordProcessor,
        nullable: nullableProcessor,
        nonoptional: nonoptionalProcessor,
        default: defaultProcessor,
        prefault: prefaultProcessor,
        catch: catchProcessor,
        pipe: pipeProcessor,
        readonly: readonlyProcessor,
        promise: promiseProcessor,
        optional: optionalProcessor,
        lazy: lazyProcessor
      };
    }
  });

  // node_modules/zod/v4/core/json-schema-generator.js
  var JSONSchemaGenerator;
  var init_json_schema_generator = __esm({
    "node_modules/zod/v4/core/json-schema-generator.js"() {
      init_json_schema_processors();
      init_to_json_schema();
      JSONSchemaGenerator = class {
        /** @deprecated Access via ctx instead */
        get metadataRegistry() {
          return this.ctx.metadataRegistry;
        }
        /** @deprecated Access via ctx instead */
        get target() {
          return this.ctx.target;
        }
        /** @deprecated Access via ctx instead */
        get unrepresentable() {
          return this.ctx.unrepresentable;
        }
        /** @deprecated Access via ctx instead */
        get override() {
          return this.ctx.override;
        }
        /** @deprecated Access via ctx instead */
        get io() {
          return this.ctx.io;
        }
        /** @deprecated Access via ctx instead */
        get counter() {
          return this.ctx.counter;
        }
        set counter(value) {
          this.ctx.counter = value;
        }
        /** @deprecated Access via ctx instead */
        get seen() {
          return this.ctx.seen;
        }
        constructor(params) {
          let normalizedTarget = params?.target ?? "draft-2020-12";
          if (normalizedTarget === "draft-4")
            normalizedTarget = "draft-04";
          if (normalizedTarget === "draft-7")
            normalizedTarget = "draft-07";
          this.ctx = initializeContext({
            processors: allProcessors,
            target: normalizedTarget,
            ...params?.metadata && { metadata: params.metadata },
            ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
            ...params?.override && { override: params.override },
            ...params?.io && { io: params.io }
          });
        }
        /**
         * Process a schema to prepare it for JSON Schema generation.
         * This must be called before emit().
         */
        process(schema, _params = { path: [], schemaPath: [] }) {
          return process2(schema, this.ctx, _params);
        }
        /**
         * Emit the final JSON Schema after processing.
         * Must call process() first.
         */
        emit(schema, _params) {
          if (_params) {
            if (_params.cycles)
              this.ctx.cycles = _params.cycles;
            if (_params.reused)
              this.ctx.reused = _params.reused;
            if (_params.external)
              this.ctx.external = _params.external;
          }
          extractDefs(this.ctx, schema);
          const result = finalize(this.ctx, schema);
          const { "~standard": _, ...plainResult } = result;
          return plainResult;
        }
      };
    }
  });

  // node_modules/zod/v4/core/json-schema.js
  var json_schema_exports = {};
  var init_json_schema = __esm({
    "node_modules/zod/v4/core/json-schema.js"() {
    }
  });

  // node_modules/zod/v4/core/index.js
  var core_exports2 = {};
  __export(core_exports2, {
    $ZodAny: () => $ZodAny,
    $ZodArray: () => $ZodArray,
    $ZodAsyncError: () => $ZodAsyncError,
    $ZodBase64: () => $ZodBase64,
    $ZodBase64URL: () => $ZodBase64URL,
    $ZodBigInt: () => $ZodBigInt,
    $ZodBigIntFormat: () => $ZodBigIntFormat,
    $ZodBoolean: () => $ZodBoolean,
    $ZodCIDRv4: () => $ZodCIDRv4,
    $ZodCIDRv6: () => $ZodCIDRv6,
    $ZodCUID: () => $ZodCUID,
    $ZodCUID2: () => $ZodCUID2,
    $ZodCatch: () => $ZodCatch,
    $ZodCheck: () => $ZodCheck,
    $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
    $ZodCheckEndsWith: () => $ZodCheckEndsWith,
    $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
    $ZodCheckIncludes: () => $ZodCheckIncludes,
    $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
    $ZodCheckLessThan: () => $ZodCheckLessThan,
    $ZodCheckLowerCase: () => $ZodCheckLowerCase,
    $ZodCheckMaxLength: () => $ZodCheckMaxLength,
    $ZodCheckMaxSize: () => $ZodCheckMaxSize,
    $ZodCheckMimeType: () => $ZodCheckMimeType,
    $ZodCheckMinLength: () => $ZodCheckMinLength,
    $ZodCheckMinSize: () => $ZodCheckMinSize,
    $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
    $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
    $ZodCheckOverwrite: () => $ZodCheckOverwrite,
    $ZodCheckProperty: () => $ZodCheckProperty,
    $ZodCheckRegex: () => $ZodCheckRegex,
    $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
    $ZodCheckStartsWith: () => $ZodCheckStartsWith,
    $ZodCheckStringFormat: () => $ZodCheckStringFormat,
    $ZodCheckUpperCase: () => $ZodCheckUpperCase,
    $ZodCodec: () => $ZodCodec,
    $ZodCustom: () => $ZodCustom,
    $ZodCustomStringFormat: () => $ZodCustomStringFormat,
    $ZodDate: () => $ZodDate,
    $ZodDefault: () => $ZodDefault,
    $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
    $ZodE164: () => $ZodE164,
    $ZodEmail: () => $ZodEmail,
    $ZodEmoji: () => $ZodEmoji,
    $ZodEncodeError: () => $ZodEncodeError,
    $ZodEnum: () => $ZodEnum,
    $ZodError: () => $ZodError,
    $ZodExactOptional: () => $ZodExactOptional,
    $ZodFile: () => $ZodFile,
    $ZodFunction: () => $ZodFunction,
    $ZodGUID: () => $ZodGUID,
    $ZodIPv4: () => $ZodIPv4,
    $ZodIPv6: () => $ZodIPv6,
    $ZodISODate: () => $ZodISODate,
    $ZodISODateTime: () => $ZodISODateTime,
    $ZodISODuration: () => $ZodISODuration,
    $ZodISOTime: () => $ZodISOTime,
    $ZodIntersection: () => $ZodIntersection,
    $ZodJWT: () => $ZodJWT,
    $ZodKSUID: () => $ZodKSUID,
    $ZodLazy: () => $ZodLazy,
    $ZodLiteral: () => $ZodLiteral,
    $ZodMAC: () => $ZodMAC,
    $ZodMap: () => $ZodMap,
    $ZodNaN: () => $ZodNaN,
    $ZodNanoID: () => $ZodNanoID,
    $ZodNever: () => $ZodNever,
    $ZodNonOptional: () => $ZodNonOptional,
    $ZodNull: () => $ZodNull,
    $ZodNullable: () => $ZodNullable,
    $ZodNumber: () => $ZodNumber,
    $ZodNumberFormat: () => $ZodNumberFormat,
    $ZodObject: () => $ZodObject,
    $ZodObjectJIT: () => $ZodObjectJIT,
    $ZodOptional: () => $ZodOptional,
    $ZodPipe: () => $ZodPipe,
    $ZodPrefault: () => $ZodPrefault,
    $ZodPromise: () => $ZodPromise,
    $ZodReadonly: () => $ZodReadonly,
    $ZodRealError: () => $ZodRealError,
    $ZodRecord: () => $ZodRecord,
    $ZodRegistry: () => $ZodRegistry,
    $ZodSet: () => $ZodSet,
    $ZodString: () => $ZodString,
    $ZodStringFormat: () => $ZodStringFormat,
    $ZodSuccess: () => $ZodSuccess,
    $ZodSymbol: () => $ZodSymbol,
    $ZodTemplateLiteral: () => $ZodTemplateLiteral,
    $ZodTransform: () => $ZodTransform,
    $ZodTuple: () => $ZodTuple,
    $ZodType: () => $ZodType,
    $ZodULID: () => $ZodULID,
    $ZodURL: () => $ZodURL,
    $ZodUUID: () => $ZodUUID,
    $ZodUndefined: () => $ZodUndefined,
    $ZodUnion: () => $ZodUnion,
    $ZodUnknown: () => $ZodUnknown,
    $ZodVoid: () => $ZodVoid,
    $ZodXID: () => $ZodXID,
    $ZodXor: () => $ZodXor,
    $brand: () => $brand,
    $constructor: () => $constructor,
    $input: () => $input,
    $output: () => $output,
    Doc: () => Doc,
    JSONSchema: () => json_schema_exports,
    JSONSchemaGenerator: () => JSONSchemaGenerator,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    _any: () => _any,
    _array: () => _array,
    _base64: () => _base64,
    _base64url: () => _base64url,
    _bigint: () => _bigint,
    _boolean: () => _boolean,
    _catch: () => _catch,
    _check: () => _check,
    _cidrv4: () => _cidrv4,
    _cidrv6: () => _cidrv6,
    _coercedBigint: () => _coercedBigint,
    _coercedBoolean: () => _coercedBoolean,
    _coercedDate: () => _coercedDate,
    _coercedNumber: () => _coercedNumber,
    _coercedString: () => _coercedString,
    _cuid: () => _cuid,
    _cuid2: () => _cuid2,
    _custom: () => _custom,
    _date: () => _date,
    _decode: () => _decode,
    _decodeAsync: () => _decodeAsync,
    _default: () => _default,
    _discriminatedUnion: () => _discriminatedUnion,
    _e164: () => _e164,
    _email: () => _email,
    _emoji: () => _emoji2,
    _encode: () => _encode,
    _encodeAsync: () => _encodeAsync,
    _endsWith: () => _endsWith,
    _enum: () => _enum,
    _file: () => _file,
    _float32: () => _float32,
    _float64: () => _float64,
    _gt: () => _gt,
    _gte: () => _gte,
    _guid: () => _guid,
    _includes: () => _includes,
    _int: () => _int,
    _int32: () => _int32,
    _int64: () => _int64,
    _intersection: () => _intersection,
    _ipv4: () => _ipv4,
    _ipv6: () => _ipv6,
    _isoDate: () => _isoDate,
    _isoDateTime: () => _isoDateTime,
    _isoDuration: () => _isoDuration,
    _isoTime: () => _isoTime,
    _jwt: () => _jwt,
    _ksuid: () => _ksuid,
    _lazy: () => _lazy,
    _length: () => _length,
    _literal: () => _literal,
    _lowercase: () => _lowercase,
    _lt: () => _lt,
    _lte: () => _lte,
    _mac: () => _mac,
    _map: () => _map,
    _max: () => _lte,
    _maxLength: () => _maxLength,
    _maxSize: () => _maxSize,
    _mime: () => _mime,
    _min: () => _gte,
    _minLength: () => _minLength,
    _minSize: () => _minSize,
    _multipleOf: () => _multipleOf,
    _nan: () => _nan,
    _nanoid: () => _nanoid,
    _nativeEnum: () => _nativeEnum,
    _negative: () => _negative,
    _never: () => _never,
    _nonnegative: () => _nonnegative,
    _nonoptional: () => _nonoptional,
    _nonpositive: () => _nonpositive,
    _normalize: () => _normalize,
    _null: () => _null2,
    _nullable: () => _nullable,
    _number: () => _number,
    _optional: () => _optional,
    _overwrite: () => _overwrite,
    _parse: () => _parse,
    _parseAsync: () => _parseAsync,
    _pipe: () => _pipe,
    _positive: () => _positive,
    _promise: () => _promise,
    _property: () => _property,
    _readonly: () => _readonly,
    _record: () => _record,
    _refine: () => _refine,
    _regex: () => _regex,
    _safeDecode: () => _safeDecode,
    _safeDecodeAsync: () => _safeDecodeAsync,
    _safeEncode: () => _safeEncode,
    _safeEncodeAsync: () => _safeEncodeAsync,
    _safeParse: () => _safeParse,
    _safeParseAsync: () => _safeParseAsync,
    _set: () => _set,
    _size: () => _size,
    _slugify: () => _slugify,
    _startsWith: () => _startsWith,
    _string: () => _string,
    _stringFormat: () => _stringFormat,
    _stringbool: () => _stringbool,
    _success: () => _success,
    _superRefine: () => _superRefine,
    _symbol: () => _symbol,
    _templateLiteral: () => _templateLiteral,
    _toLowerCase: () => _toLowerCase,
    _toUpperCase: () => _toUpperCase,
    _transform: () => _transform,
    _trim: () => _trim,
    _tuple: () => _tuple,
    _uint32: () => _uint32,
    _uint64: () => _uint64,
    _ulid: () => _ulid,
    _undefined: () => _undefined2,
    _union: () => _union,
    _unknown: () => _unknown,
    _uppercase: () => _uppercase,
    _url: () => _url,
    _uuid: () => _uuid,
    _uuidv4: () => _uuidv4,
    _uuidv6: () => _uuidv6,
    _uuidv7: () => _uuidv7,
    _void: () => _void,
    _xid: () => _xid,
    _xor: () => _xor,
    clone: () => clone,
    config: () => config,
    createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
    createToJSONSchemaMethod: () => createToJSONSchemaMethod,
    decode: () => decode,
    decodeAsync: () => decodeAsync,
    describe: () => describe,
    encode: () => encode,
    encodeAsync: () => encodeAsync,
    extractDefs: () => extractDefs,
    finalize: () => finalize,
    flattenError: () => flattenError,
    formatError: () => formatError,
    globalConfig: () => globalConfig,
    globalRegistry: () => globalRegistry,
    initializeContext: () => initializeContext,
    isValidBase64: () => isValidBase64,
    isValidBase64URL: () => isValidBase64URL,
    isValidJWT: () => isValidJWT,
    locales: () => locales_exports,
    meta: () => meta,
    parse: () => parse,
    parseAsync: () => parseAsync,
    prettifyError: () => prettifyError,
    process: () => process2,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode,
    safeDecodeAsync: () => safeDecodeAsync,
    safeEncode: () => safeEncode,
    safeEncodeAsync: () => safeEncodeAsync,
    safeParse: () => safeParse,
    safeParseAsync: () => safeParseAsync,
    toDotPath: () => toDotPath,
    toJSONSchema: () => toJSONSchema,
    treeifyError: () => treeifyError,
    util: () => util_exports,
    version: () => version
  });
  var init_core2 = __esm({
    "node_modules/zod/v4/core/index.js"() {
      init_core();
      init_parse();
      init_errors();
      init_schemas();
      init_checks();
      init_versions();
      init_util();
      init_regexes();
      init_locales();
      init_registries();
      init_doc();
      init_api();
      init_to_json_schema();
      init_json_schema_processors();
      init_json_schema_generator();
      init_json_schema();
    }
  });

  // node_modules/zod/v4/classic/checks.js
  var checks_exports2 = {};
  __export(checks_exports2, {
    endsWith: () => _endsWith,
    gt: () => _gt,
    gte: () => _gte,
    includes: () => _includes,
    length: () => _length,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    negative: () => _negative,
    nonnegative: () => _nonnegative,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    overwrite: () => _overwrite,
    positive: () => _positive,
    property: () => _property,
    regex: () => _regex,
    size: () => _size,
    slugify: () => _slugify,
    startsWith: () => _startsWith,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    trim: () => _trim,
    uppercase: () => _uppercase
  });
  var init_checks2 = __esm({
    "node_modules/zod/v4/classic/checks.js"() {
      init_core2();
    }
  });

  // node_modules/zod/v4/classic/iso.js
  var iso_exports = {};
  __export(iso_exports, {
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    date: () => date2,
    datetime: () => datetime2,
    duration: () => duration2,
    time: () => time2
  });
  function datetime2(params) {
    return _isoDateTime(ZodISODateTime, params);
  }
  function date2(params) {
    return _isoDate(ZodISODate, params);
  }
  function time2(params) {
    return _isoTime(ZodISOTime, params);
  }
  function duration2(params) {
    return _isoDuration(ZodISODuration, params);
  }
  var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
  var init_iso = __esm({
    "node_modules/zod/v4/classic/iso.js"() {
      init_core2();
      init_schemas2();
      ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
        $ZodISODateTime.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
        $ZodISODate.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
        $ZodISOTime.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
        $ZodISODuration.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
    }
  });

  // node_modules/zod/v4/classic/errors.js
  var initializer2, ZodError, ZodRealError;
  var init_errors2 = __esm({
    "node_modules/zod/v4/classic/errors.js"() {
      init_core2();
      init_core2();
      init_util();
      initializer2 = (inst, issues) => {
        $ZodError.init(inst, issues);
        inst.name = "ZodError";
        Object.defineProperties(inst, {
          format: {
            value: (mapper) => formatError(inst, mapper)
            // enumerable: false,
          },
          flatten: {
            value: (mapper) => flattenError(inst, mapper)
            // enumerable: false,
          },
          addIssue: {
            value: (issue2) => {
              inst.issues.push(issue2);
              inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
            }
            // enumerable: false,
          },
          addIssues: {
            value: (issues2) => {
              inst.issues.push(...issues2);
              inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
            }
            // enumerable: false,
          },
          isEmpty: {
            get() {
              return inst.issues.length === 0;
            }
            // enumerable: false,
          }
        });
      };
      ZodError = $constructor("ZodError", initializer2);
      ZodRealError = $constructor("ZodError", initializer2, {
        Parent: Error
      });
    }
  });

  // node_modules/zod/v4/classic/parse.js
  var parse2, parseAsync2, safeParse2, safeParseAsync2, encode2, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
  var init_parse2 = __esm({
    "node_modules/zod/v4/classic/parse.js"() {
      init_core2();
      init_errors2();
      parse2 = /* @__PURE__ */ _parse(ZodRealError);
      parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
      safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
      safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
      encode2 = /* @__PURE__ */ _encode(ZodRealError);
      decode2 = /* @__PURE__ */ _decode(ZodRealError);
      encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
      decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
      safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
      safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
      safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
      safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
    }
  });

  // node_modules/zod/v4/classic/schemas.js
  var schemas_exports2 = {};
  __export(schemas_exports2, {
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodExactOptional: () => ZodExactOptional,
    ZodFile: () => ZodFile,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodIntersection: () => ZodIntersection,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMAC: () => ZodMAC,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    ZodXor: () => ZodXor,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    codec: () => codec,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    describe: () => describe2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    enum: () => _enum2,
    exactOptional: () => exactOptional,
    file: () => file,
    float32: () => float32,
    float64: () => float64,
    function: () => _function,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    literal: () => literal,
    looseObject: () => looseObject,
    looseRecord: () => looseRecord,
    mac: () => mac2,
    map: () => map,
    meta: () => meta2,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    never: () => never,
    nonoptional: () => nonoptional,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    prefault: () => prefault,
    preprocess: () => preprocess,
    promise: () => promise,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    set: () => set,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol,
    templateLiteral: () => templateLiteral,
    transform: () => transform,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    url: () => url,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2,
    xor: () => xor
  });
  function string2(params) {
    return _string(ZodString, params);
  }
  function email2(params) {
    return _email(ZodEmail, params);
  }
  function guid2(params) {
    return _guid(ZodGUID, params);
  }
  function uuid2(params) {
    return _uuid(ZodUUID, params);
  }
  function uuidv4(params) {
    return _uuidv4(ZodUUID, params);
  }
  function uuidv6(params) {
    return _uuidv6(ZodUUID, params);
  }
  function uuidv7(params) {
    return _uuidv7(ZodUUID, params);
  }
  function url(params) {
    return _url(ZodURL, params);
  }
  function httpUrl(params) {
    return _url(ZodURL, {
      protocol: /^https?$/,
      hostname: regexes_exports.domain,
      ...util_exports.normalizeParams(params)
    });
  }
  function emoji2(params) {
    return _emoji2(ZodEmoji, params);
  }
  function nanoid2(params) {
    return _nanoid(ZodNanoID, params);
  }
  function cuid3(params) {
    return _cuid(ZodCUID, params);
  }
  function cuid22(params) {
    return _cuid2(ZodCUID2, params);
  }
  function ulid2(params) {
    return _ulid(ZodULID, params);
  }
  function xid2(params) {
    return _xid(ZodXID, params);
  }
  function ksuid2(params) {
    return _ksuid(ZodKSUID, params);
  }
  function ipv42(params) {
    return _ipv4(ZodIPv4, params);
  }
  function mac2(params) {
    return _mac(ZodMAC, params);
  }
  function ipv62(params) {
    return _ipv6(ZodIPv6, params);
  }
  function cidrv42(params) {
    return _cidrv4(ZodCIDRv4, params);
  }
  function cidrv62(params) {
    return _cidrv6(ZodCIDRv6, params);
  }
  function base642(params) {
    return _base64(ZodBase64, params);
  }
  function base64url2(params) {
    return _base64url(ZodBase64URL, params);
  }
  function e1642(params) {
    return _e164(ZodE164, params);
  }
  function jwt(params) {
    return _jwt(ZodJWT, params);
  }
  function stringFormat(format, fnOrRegex, _params = {}) {
    return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
  }
  function hostname2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
  }
  function hex2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
  }
  function hash(alg, params) {
    const enc = params?.enc ?? "hex";
    const format = `${alg}_${enc}`;
    const regex = regexes_exports[format];
    if (!regex)
      throw new Error(`Unrecognized hash format: ${format}`);
    return _stringFormat(ZodCustomStringFormat, format, regex, params);
  }
  function number2(params) {
    return _number(ZodNumber, params);
  }
  function int(params) {
    return _int(ZodNumberFormat, params);
  }
  function float32(params) {
    return _float32(ZodNumberFormat, params);
  }
  function float64(params) {
    return _float64(ZodNumberFormat, params);
  }
  function int32(params) {
    return _int32(ZodNumberFormat, params);
  }
  function uint32(params) {
    return _uint32(ZodNumberFormat, params);
  }
  function boolean2(params) {
    return _boolean(ZodBoolean, params);
  }
  function bigint2(params) {
    return _bigint(ZodBigInt, params);
  }
  function int64(params) {
    return _int64(ZodBigIntFormat, params);
  }
  function uint64(params) {
    return _uint64(ZodBigIntFormat, params);
  }
  function symbol(params) {
    return _symbol(ZodSymbol, params);
  }
  function _undefined3(params) {
    return _undefined2(ZodUndefined, params);
  }
  function _null3(params) {
    return _null2(ZodNull, params);
  }
  function any() {
    return _any(ZodAny);
  }
  function unknown() {
    return _unknown(ZodUnknown);
  }
  function never(params) {
    return _never(ZodNever, params);
  }
  function _void2(params) {
    return _void(ZodVoid, params);
  }
  function date3(params) {
    return _date(ZodDate, params);
  }
  function array(element, params) {
    return _array(ZodArray, element, params);
  }
  function keyof(schema) {
    const shape = schema._zod.def.shape;
    return _enum2(Object.keys(shape));
  }
  function object(shape, params) {
    const def = {
      type: "object",
      shape: shape ?? {},
      ...util_exports.normalizeParams(params)
    };
    return new ZodObject(def);
  }
  function strictObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: never(),
      ...util_exports.normalizeParams(params)
    });
  }
  function looseObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: unknown(),
      ...util_exports.normalizeParams(params)
    });
  }
  function union(options, params) {
    return new ZodUnion({
      type: "union",
      options,
      ...util_exports.normalizeParams(params)
    });
  }
  function xor(options, params) {
    return new ZodXor({
      type: "union",
      options,
      inclusive: false,
      ...util_exports.normalizeParams(params)
    });
  }
  function discriminatedUnion(discriminator, options, params) {
    return new ZodDiscriminatedUnion({
      type: "union",
      options,
      discriminator,
      ...util_exports.normalizeParams(params)
    });
  }
  function intersection(left, right) {
    return new ZodIntersection({
      type: "intersection",
      left,
      right
    });
  }
  function tuple(items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new ZodTuple({
      type: "tuple",
      items,
      rest,
      ...util_exports.normalizeParams(params)
    });
  }
  function record(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function partialRecord(keyType, valueType, params) {
    const k = clone(keyType);
    k._zod.values = void 0;
    return new ZodRecord({
      type: "record",
      keyType: k,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function looseRecord(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      mode: "loose",
      ...util_exports.normalizeParams(params)
    });
  }
  function map(keyType, valueType, params) {
    return new ZodMap({
      type: "map",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function set(valueType, params) {
    return new ZodSet({
      type: "set",
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function _enum2(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  function nativeEnum(entries, params) {
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  function literal(value, params) {
    return new ZodLiteral({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...util_exports.normalizeParams(params)
    });
  }
  function file(params) {
    return _file(ZodFile, params);
  }
  function transform(fn) {
    return new ZodTransform({
      type: "transform",
      transform: fn
    });
  }
  function optional(innerType) {
    return new ZodOptional({
      type: "optional",
      innerType
    });
  }
  function exactOptional(innerType) {
    return new ZodExactOptional({
      type: "optional",
      innerType
    });
  }
  function nullable(innerType) {
    return new ZodNullable({
      type: "nullable",
      innerType
    });
  }
  function nullish2(innerType) {
    return optional(nullable(innerType));
  }
  function _default2(innerType, defaultValue) {
    return new ZodDefault({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  function prefault(innerType, defaultValue) {
    return new ZodPrefault({
      type: "prefault",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  function nonoptional(innerType, params) {
    return new ZodNonOptional({
      type: "nonoptional",
      innerType,
      ...util_exports.normalizeParams(params)
    });
  }
  function success(innerType) {
    return new ZodSuccess({
      type: "success",
      innerType
    });
  }
  function _catch2(innerType, catchValue) {
    return new ZodCatch({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  function nan(params) {
    return _nan(ZodNaN, params);
  }
  function pipe(in_, out) {
    return new ZodPipe({
      type: "pipe",
      in: in_,
      out
      // ...util.normalizeParams(params),
    });
  }
  function codec(in_, out, params) {
    return new ZodCodec({
      type: "pipe",
      in: in_,
      out,
      transform: params.decode,
      reverseTransform: params.encode
    });
  }
  function readonly(innerType) {
    return new ZodReadonly({
      type: "readonly",
      innerType
    });
  }
  function templateLiteral(parts, params) {
    return new ZodTemplateLiteral({
      type: "template_literal",
      parts,
      ...util_exports.normalizeParams(params)
    });
  }
  function lazy(getter) {
    return new ZodLazy({
      type: "lazy",
      getter
    });
  }
  function promise(innerType) {
    return new ZodPromise({
      type: "promise",
      innerType
    });
  }
  function _function(params) {
    return new ZodFunction({
      type: "function",
      input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
      output: params?.output ?? unknown()
    });
  }
  function check(fn) {
    const ch = new $ZodCheck({
      check: "custom"
      // ...util.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
  }
  function custom(fn, _params) {
    return _custom(ZodCustom, fn ?? (() => true), _params);
  }
  function refine(fn, _params = {}) {
    return _refine(ZodCustom, fn, _params);
  }
  function superRefine(fn) {
    return _superRefine(fn);
  }
  function _instanceof(cls, params = {}) {
    const inst = new ZodCustom({
      type: "custom",
      check: "custom",
      fn: (data) => data instanceof cls,
      abort: true,
      ...util_exports.normalizeParams(params)
    });
    inst._zod.bag.Class = cls;
    inst._zod.check = (payload) => {
      if (!(payload.value instanceof cls)) {
        payload.issues.push({
          code: "invalid_type",
          expected: cls.name,
          input: payload.value,
          inst,
          path: [...inst._zod.def.path ?? []]
        });
      }
    };
    return inst;
  }
  function json(params) {
    const jsonSchema = lazy(() => {
      return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
    });
    return jsonSchema;
  }
  function preprocess(fn, schema) {
    return pipe(transform(fn), schema);
  }
  var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodXor, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodExactOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool;
  var init_schemas2 = __esm({
    "node_modules/zod/v4/classic/schemas.js"() {
      init_core2();
      init_core2();
      init_json_schema_processors();
      init_to_json_schema();
      init_checks2();
      init_iso();
      init_parse2();
      ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
        $ZodType.init(inst, def);
        Object.assign(inst["~standard"], {
          jsonSchema: {
            input: createStandardJSONSchemaMethod(inst, "input"),
            output: createStandardJSONSchemaMethod(inst, "output")
          }
        });
        inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
        inst.def = def;
        inst.type = def.type;
        Object.defineProperty(inst, "_def", { value: def });
        inst.check = (...checks) => {
          return inst.clone(util_exports.mergeDefs(def, {
            checks: [
              ...def.checks ?? [],
              ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
            ]
          }), {
            parent: true
          });
        };
        inst.with = inst.check;
        inst.clone = (def2, params) => clone(inst, def2, params);
        inst.brand = () => inst;
        inst.register = ((reg, meta3) => {
          reg.add(inst, meta3);
          return inst;
        });
        inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
        inst.safeParse = (data, params) => safeParse2(inst, data, params);
        inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
        inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
        inst.spa = inst.safeParseAsync;
        inst.encode = (data, params) => encode2(inst, data, params);
        inst.decode = (data, params) => decode2(inst, data, params);
        inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
        inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
        inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
        inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
        inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
        inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
        inst.refine = (check2, params) => inst.check(refine(check2, params));
        inst.superRefine = (refinement) => inst.check(superRefine(refinement));
        inst.overwrite = (fn) => inst.check(_overwrite(fn));
        inst.optional = () => optional(inst);
        inst.exactOptional = () => exactOptional(inst);
        inst.nullable = () => nullable(inst);
        inst.nullish = () => optional(nullable(inst));
        inst.nonoptional = (params) => nonoptional(inst, params);
        inst.array = () => array(inst);
        inst.or = (arg) => union([inst, arg]);
        inst.and = (arg) => intersection(inst, arg);
        inst.transform = (tx) => pipe(inst, transform(tx));
        inst.default = (def2) => _default2(inst, def2);
        inst.prefault = (def2) => prefault(inst, def2);
        inst.catch = (params) => _catch2(inst, params);
        inst.pipe = (target) => pipe(inst, target);
        inst.readonly = () => readonly(inst);
        inst.describe = (description) => {
          const cl = inst.clone();
          globalRegistry.add(cl, { description });
          return cl;
        };
        Object.defineProperty(inst, "description", {
          get() {
            return globalRegistry.get(inst)?.description;
          },
          configurable: true
        });
        inst.meta = (...args) => {
          if (args.length === 0) {
            return globalRegistry.get(inst);
          }
          const cl = inst.clone();
          globalRegistry.add(cl, args[0]);
          return cl;
        };
        inst.isOptional = () => inst.safeParse(void 0).success;
        inst.isNullable = () => inst.safeParse(null).success;
        inst.apply = (fn) => fn(inst);
        return inst;
      });
      _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
        $ZodString.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
        const bag = inst._zod.bag;
        inst.format = bag.format ?? null;
        inst.minLength = bag.minimum ?? null;
        inst.maxLength = bag.maximum ?? null;
        inst.regex = (...args) => inst.check(_regex(...args));
        inst.includes = (...args) => inst.check(_includes(...args));
        inst.startsWith = (...args) => inst.check(_startsWith(...args));
        inst.endsWith = (...args) => inst.check(_endsWith(...args));
        inst.min = (...args) => inst.check(_minLength(...args));
        inst.max = (...args) => inst.check(_maxLength(...args));
        inst.length = (...args) => inst.check(_length(...args));
        inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
        inst.lowercase = (params) => inst.check(_lowercase(params));
        inst.uppercase = (params) => inst.check(_uppercase(params));
        inst.trim = () => inst.check(_trim());
        inst.normalize = (...args) => inst.check(_normalize(...args));
        inst.toLowerCase = () => inst.check(_toLowerCase());
        inst.toUpperCase = () => inst.check(_toUpperCase());
        inst.slugify = () => inst.check(_slugify());
      });
      ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
        $ZodString.init(inst, def);
        _ZodString.init(inst, def);
        inst.email = (params) => inst.check(_email(ZodEmail, params));
        inst.url = (params) => inst.check(_url(ZodURL, params));
        inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
        inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
        inst.guid = (params) => inst.check(_guid(ZodGUID, params));
        inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
        inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
        inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
        inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
        inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
        inst.guid = (params) => inst.check(_guid(ZodGUID, params));
        inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
        inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
        inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
        inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
        inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
        inst.xid = (params) => inst.check(_xid(ZodXID, params));
        inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
        inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
        inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
        inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
        inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
        inst.e164 = (params) => inst.check(_e164(ZodE164, params));
        inst.datetime = (params) => inst.check(datetime2(params));
        inst.date = (params) => inst.check(date2(params));
        inst.time = (params) => inst.check(time2(params));
        inst.duration = (params) => inst.check(duration2(params));
      });
      ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
        $ZodStringFormat.init(inst, def);
        _ZodString.init(inst, def);
      });
      ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
        $ZodEmail.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
        $ZodGUID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
        $ZodUUID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
        $ZodURL.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
        $ZodEmoji.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
        $ZodNanoID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
        $ZodCUID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
        $ZodCUID2.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
        $ZodULID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
        $ZodXID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
        $ZodKSUID.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
        $ZodIPv4.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
        $ZodMAC.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
        $ZodIPv6.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
        $ZodCIDRv4.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
        $ZodCIDRv6.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
        $ZodBase64.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
        $ZodBase64URL.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
        $ZodE164.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
        $ZodJWT.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
        $ZodCustomStringFormat.init(inst, def);
        ZodStringFormat.init(inst, def);
      });
      ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
        $ZodNumber.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params);
        inst.gt = (value, params) => inst.check(_gt(value, params));
        inst.gte = (value, params) => inst.check(_gte(value, params));
        inst.min = (value, params) => inst.check(_gte(value, params));
        inst.lt = (value, params) => inst.check(_lt(value, params));
        inst.lte = (value, params) => inst.check(_lte(value, params));
        inst.max = (value, params) => inst.check(_lte(value, params));
        inst.int = (params) => inst.check(int(params));
        inst.safe = (params) => inst.check(int(params));
        inst.positive = (params) => inst.check(_gt(0, params));
        inst.nonnegative = (params) => inst.check(_gte(0, params));
        inst.negative = (params) => inst.check(_lt(0, params));
        inst.nonpositive = (params) => inst.check(_lte(0, params));
        inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
        inst.step = (value, params) => inst.check(_multipleOf(value, params));
        inst.finite = () => inst;
        const bag = inst._zod.bag;
        inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
        inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
        inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
        inst.isFinite = true;
        inst.format = bag.format ?? null;
      });
      ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
        $ZodNumberFormat.init(inst, def);
        ZodNumber.init(inst, def);
      });
      ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
        $ZodBoolean.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
      });
      ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
        $ZodBigInt.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params);
        inst.gte = (value, params) => inst.check(_gte(value, params));
        inst.min = (value, params) => inst.check(_gte(value, params));
        inst.gt = (value, params) => inst.check(_gt(value, params));
        inst.gte = (value, params) => inst.check(_gte(value, params));
        inst.min = (value, params) => inst.check(_gte(value, params));
        inst.lt = (value, params) => inst.check(_lt(value, params));
        inst.lte = (value, params) => inst.check(_lte(value, params));
        inst.max = (value, params) => inst.check(_lte(value, params));
        inst.positive = (params) => inst.check(_gt(BigInt(0), params));
        inst.negative = (params) => inst.check(_lt(BigInt(0), params));
        inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
        inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
        inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
        const bag = inst._zod.bag;
        inst.minValue = bag.minimum ?? null;
        inst.maxValue = bag.maximum ?? null;
        inst.format = bag.format ?? null;
      });
      ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
        $ZodBigIntFormat.init(inst, def);
        ZodBigInt.init(inst, def);
      });
      ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
        $ZodSymbol.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
      });
      ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
        $ZodUndefined.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
      });
      ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
        $ZodNull.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
      });
      ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
        $ZodAny.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
      });
      ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
        $ZodUnknown.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
      });
      ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
        $ZodNever.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
      });
      ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
        $ZodVoid.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
      });
      ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
        $ZodDate.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params);
        inst.min = (value, params) => inst.check(_gte(value, params));
        inst.max = (value, params) => inst.check(_lte(value, params));
        const c = inst._zod.bag;
        inst.minDate = c.minimum ? new Date(c.minimum) : null;
        inst.maxDate = c.maximum ? new Date(c.maximum) : null;
      });
      ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
        $ZodArray.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
        inst.element = def.element;
        inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
        inst.nonempty = (params) => inst.check(_minLength(1, params));
        inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
        inst.length = (len, params) => inst.check(_length(len, params));
        inst.unwrap = () => inst.element;
      });
      ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
        $ZodObjectJIT.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
        util_exports.defineLazy(inst, "shape", () => {
          return def.shape;
        });
        inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
        inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
        inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
        inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
        inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
        inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
        inst.extend = (incoming) => {
          return util_exports.extend(inst, incoming);
        };
        inst.safeExtend = (incoming) => {
          return util_exports.safeExtend(inst, incoming);
        };
        inst.merge = (other) => util_exports.merge(inst, other);
        inst.pick = (mask) => util_exports.pick(inst, mask);
        inst.omit = (mask) => util_exports.omit(inst, mask);
        inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
        inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
      });
      ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
        $ZodUnion.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
        inst.options = def.options;
      });
      ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
        ZodUnion.init(inst, def);
        $ZodXor.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
        inst.options = def.options;
      });
      ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
        ZodUnion.init(inst, def);
        $ZodDiscriminatedUnion.init(inst, def);
      });
      ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
        $ZodIntersection.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
      });
      ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
        $ZodTuple.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
        inst.rest = (rest) => inst.clone({
          ...inst._zod.def,
          rest
        });
      });
      ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
        $ZodRecord.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
        inst.keyType = def.keyType;
        inst.valueType = def.valueType;
      });
      ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
        $ZodMap.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params);
        inst.keyType = def.keyType;
        inst.valueType = def.valueType;
        inst.min = (...args) => inst.check(_minSize(...args));
        inst.nonempty = (params) => inst.check(_minSize(1, params));
        inst.max = (...args) => inst.check(_maxSize(...args));
        inst.size = (...args) => inst.check(_size(...args));
      });
      ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
        $ZodSet.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params);
        inst.min = (...args) => inst.check(_minSize(...args));
        inst.nonempty = (params) => inst.check(_minSize(1, params));
        inst.max = (...args) => inst.check(_maxSize(...args));
        inst.size = (...args) => inst.check(_size(...args));
      });
      ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
        $ZodEnum.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params);
        inst.enum = def.entries;
        inst.options = Object.values(def.entries);
        const keys = new Set(Object.keys(def.entries));
        inst.extract = (values, params) => {
          const newEntries = {};
          for (const value of values) {
            if (keys.has(value)) {
              newEntries[value] = def.entries[value];
            } else
              throw new Error(`Key ${value} not found in enum`);
          }
          return new ZodEnum({
            ...def,
            checks: [],
            ...util_exports.normalizeParams(params),
            entries: newEntries
          });
        };
        inst.exclude = (values, params) => {
          const newEntries = { ...def.entries };
          for (const value of values) {
            if (keys.has(value)) {
              delete newEntries[value];
            } else
              throw new Error(`Key ${value} not found in enum`);
          }
          return new ZodEnum({
            ...def,
            checks: [],
            ...util_exports.normalizeParams(params),
            entries: newEntries
          });
        };
      });
      ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
        $ZodLiteral.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params);
        inst.values = new Set(def.values);
        Object.defineProperty(inst, "value", {
          get() {
            if (def.values.length > 1) {
              throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
            }
            return def.values[0];
          }
        });
      });
      ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
        $ZodFile.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params);
        inst.min = (size, params) => inst.check(_minSize(size, params));
        inst.max = (size, params) => inst.check(_maxSize(size, params));
        inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
      });
      ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
        $ZodTransform.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params);
        inst._zod.parse = (payload, _ctx) => {
          if (_ctx.direction === "backward") {
            throw new $ZodEncodeError(inst.constructor.name);
          }
          payload.addIssue = (issue2) => {
            if (typeof issue2 === "string") {
              payload.issues.push(util_exports.issue(issue2, payload.value, def));
            } else {
              const _issue = issue2;
              if (_issue.fatal)
                _issue.continue = false;
              _issue.code ?? (_issue.code = "custom");
              _issue.input ?? (_issue.input = payload.value);
              _issue.inst ?? (_issue.inst = inst);
              payload.issues.push(util_exports.issue(_issue));
            }
          };
          const output = def.transform(payload.value, payload);
          if (output instanceof Promise) {
            return output.then((output2) => {
              payload.value = output2;
              return payload;
            });
          }
          payload.value = output;
          return payload;
        };
      });
      ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
        $ZodOptional.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
        $ZodExactOptional.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
        $ZodNullable.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
        $ZodDefault.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
        inst.removeDefault = inst.unwrap;
      });
      ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
        $ZodPrefault.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
        $ZodNonOptional.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
        $ZodSuccess.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
        $ZodCatch.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
        inst.removeCatch = inst.unwrap;
      });
      ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
        $ZodNaN.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
      });
      ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
        $ZodPipe.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
        inst.in = def.in;
        inst.out = def.out;
      });
      ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
        ZodPipe.init(inst, def);
        $ZodCodec.init(inst, def);
      });
      ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
        $ZodReadonly.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
        $ZodTemplateLiteral.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
      });
      ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
        $ZodLazy.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.getter();
      });
      ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
        $ZodPromise.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
        inst.unwrap = () => inst._zod.def.innerType;
      });
      ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
        $ZodFunction.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
      });
      ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
        $ZodCustom.init(inst, def);
        ZodType.init(inst, def);
        inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
      });
      describe2 = describe;
      meta2 = meta;
      stringbool = (...args) => _stringbool({
        Codec: ZodCodec,
        Boolean: ZodBoolean,
        String: ZodString
      }, ...args);
    }
  });

  // node_modules/zod/v4/classic/compat.js
  function setErrorMap(map2) {
    config({
      customError: map2
    });
  }
  function getErrorMap() {
    return config().customError;
  }
  var ZodIssueCode, ZodFirstPartyTypeKind;
  var init_compat = __esm({
    "node_modules/zod/v4/classic/compat.js"() {
      init_core2();
      init_core2();
      ZodIssueCode = {
        invalid_type: "invalid_type",
        too_big: "too_big",
        too_small: "too_small",
        invalid_format: "invalid_format",
        not_multiple_of: "not_multiple_of",
        unrecognized_keys: "unrecognized_keys",
        invalid_union: "invalid_union",
        invalid_key: "invalid_key",
        invalid_element: "invalid_element",
        invalid_value: "invalid_value",
        custom: "custom"
      };
      /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    }
  });

  // node_modules/zod/v4/classic/from-json-schema.js
  function detectVersion(schema, defaultTarget) {
    const $schema = schema.$schema;
    if ($schema === "https://json-schema.org/draft/2020-12/schema") {
      return "draft-2020-12";
    }
    if ($schema === "http://json-schema.org/draft-07/schema#") {
      return "draft-7";
    }
    if ($schema === "http://json-schema.org/draft-04/schema#") {
      return "draft-4";
    }
    return defaultTarget ?? "draft-2020-12";
  }
  function resolveRef(ref, ctx) {
    if (!ref.startsWith("#")) {
      throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
    }
    const path = ref.slice(1).split("/").filter(Boolean);
    if (path.length === 0) {
      return ctx.rootSchema;
    }
    const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
    if (path[0] === defsKey) {
      const key = path[1];
      if (!key || !ctx.defs[key]) {
        throw new Error(`Reference not found: ${ref}`);
      }
      return ctx.defs[key];
    }
    throw new Error(`Reference not found: ${ref}`);
  }
  function convertBaseSchema(schema, ctx) {
    if (schema.not !== void 0) {
      if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
        return z.never();
      }
      throw new Error("not is not supported in Zod (except { not: {} } for never)");
    }
    if (schema.unevaluatedItems !== void 0) {
      throw new Error("unevaluatedItems is not supported");
    }
    if (schema.unevaluatedProperties !== void 0) {
      throw new Error("unevaluatedProperties is not supported");
    }
    if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
      throw new Error("Conditional schemas (if/then/else) are not supported");
    }
    if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
      throw new Error("dependentSchemas and dependentRequired are not supported");
    }
    if (schema.$ref) {
      const refPath = schema.$ref;
      if (ctx.refs.has(refPath)) {
        return ctx.refs.get(refPath);
      }
      if (ctx.processing.has(refPath)) {
        return z.lazy(() => {
          if (!ctx.refs.has(refPath)) {
            throw new Error(`Circular reference not resolved: ${refPath}`);
          }
          return ctx.refs.get(refPath);
        });
      }
      ctx.processing.add(refPath);
      const resolved = resolveRef(refPath, ctx);
      const zodSchema2 = convertSchema(resolved, ctx);
      ctx.refs.set(refPath, zodSchema2);
      ctx.processing.delete(refPath);
      return zodSchema2;
    }
    if (schema.enum !== void 0) {
      const enumValues = schema.enum;
      if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
        return z.null();
      }
      if (enumValues.length === 0) {
        return z.never();
      }
      if (enumValues.length === 1) {
        return z.literal(enumValues[0]);
      }
      if (enumValues.every((v) => typeof v === "string")) {
        return z.enum(enumValues);
      }
      const literalSchemas = enumValues.map((v) => z.literal(v));
      if (literalSchemas.length < 2) {
        return literalSchemas[0];
      }
      return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
    }
    if (schema.const !== void 0) {
      return z.literal(schema.const);
    }
    const type = schema.type;
    if (Array.isArray(type)) {
      const typeSchemas = type.map((t) => {
        const typeSchema = { ...schema, type: t };
        return convertBaseSchema(typeSchema, ctx);
      });
      if (typeSchemas.length === 0) {
        return z.never();
      }
      if (typeSchemas.length === 1) {
        return typeSchemas[0];
      }
      return z.union(typeSchemas);
    }
    if (!type) {
      return z.any();
    }
    let zodSchema;
    switch (type) {
      case "string": {
        let stringSchema = z.string();
        if (schema.format) {
          const format = schema.format;
          if (format === "email") {
            stringSchema = stringSchema.check(z.email());
          } else if (format === "uri" || format === "uri-reference") {
            stringSchema = stringSchema.check(z.url());
          } else if (format === "uuid" || format === "guid") {
            stringSchema = stringSchema.check(z.uuid());
          } else if (format === "date-time") {
            stringSchema = stringSchema.check(z.iso.datetime());
          } else if (format === "date") {
            stringSchema = stringSchema.check(z.iso.date());
          } else if (format === "time") {
            stringSchema = stringSchema.check(z.iso.time());
          } else if (format === "duration") {
            stringSchema = stringSchema.check(z.iso.duration());
          } else if (format === "ipv4") {
            stringSchema = stringSchema.check(z.ipv4());
          } else if (format === "ipv6") {
            stringSchema = stringSchema.check(z.ipv6());
          } else if (format === "mac") {
            stringSchema = stringSchema.check(z.mac());
          } else if (format === "cidr") {
            stringSchema = stringSchema.check(z.cidrv4());
          } else if (format === "cidr-v6") {
            stringSchema = stringSchema.check(z.cidrv6());
          } else if (format === "base64") {
            stringSchema = stringSchema.check(z.base64());
          } else if (format === "base64url") {
            stringSchema = stringSchema.check(z.base64url());
          } else if (format === "e164") {
            stringSchema = stringSchema.check(z.e164());
          } else if (format === "jwt") {
            stringSchema = stringSchema.check(z.jwt());
          } else if (format === "emoji") {
            stringSchema = stringSchema.check(z.emoji());
          } else if (format === "nanoid") {
            stringSchema = stringSchema.check(z.nanoid());
          } else if (format === "cuid") {
            stringSchema = stringSchema.check(z.cuid());
          } else if (format === "cuid2") {
            stringSchema = stringSchema.check(z.cuid2());
          } else if (format === "ulid") {
            stringSchema = stringSchema.check(z.ulid());
          } else if (format === "xid") {
            stringSchema = stringSchema.check(z.xid());
          } else if (format === "ksuid") {
            stringSchema = stringSchema.check(z.ksuid());
          }
        }
        if (typeof schema.minLength === "number") {
          stringSchema = stringSchema.min(schema.minLength);
        }
        if (typeof schema.maxLength === "number") {
          stringSchema = stringSchema.max(schema.maxLength);
        }
        if (schema.pattern) {
          stringSchema = stringSchema.regex(new RegExp(schema.pattern));
        }
        zodSchema = stringSchema;
        break;
      }
      case "number":
      case "integer": {
        let numberSchema = type === "integer" ? z.number().int() : z.number();
        if (typeof schema.minimum === "number") {
          numberSchema = numberSchema.min(schema.minimum);
        }
        if (typeof schema.maximum === "number") {
          numberSchema = numberSchema.max(schema.maximum);
        }
        if (typeof schema.exclusiveMinimum === "number") {
          numberSchema = numberSchema.gt(schema.exclusiveMinimum);
        } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
          numberSchema = numberSchema.gt(schema.minimum);
        }
        if (typeof schema.exclusiveMaximum === "number") {
          numberSchema = numberSchema.lt(schema.exclusiveMaximum);
        } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
          numberSchema = numberSchema.lt(schema.maximum);
        }
        if (typeof schema.multipleOf === "number") {
          numberSchema = numberSchema.multipleOf(schema.multipleOf);
        }
        zodSchema = numberSchema;
        break;
      }
      case "boolean": {
        zodSchema = z.boolean();
        break;
      }
      case "null": {
        zodSchema = z.null();
        break;
      }
      case "object": {
        const shape = {};
        const properties = schema.properties || {};
        const requiredSet = new Set(schema.required || []);
        for (const [key, propSchema] of Object.entries(properties)) {
          const propZodSchema = convertSchema(propSchema, ctx);
          shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
        }
        if (schema.propertyNames) {
          const keySchema = convertSchema(schema.propertyNames, ctx);
          const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
          if (Object.keys(shape).length === 0) {
            zodSchema = z.record(keySchema, valueSchema);
            break;
          }
          const objectSchema2 = z.object(shape).passthrough();
          const recordSchema = z.looseRecord(keySchema, valueSchema);
          zodSchema = z.intersection(objectSchema2, recordSchema);
          break;
        }
        if (schema.patternProperties) {
          const patternProps = schema.patternProperties;
          const patternKeys = Object.keys(patternProps);
          const looseRecords = [];
          for (const pattern of patternKeys) {
            const patternValue = convertSchema(patternProps[pattern], ctx);
            const keySchema = z.string().regex(new RegExp(pattern));
            looseRecords.push(z.looseRecord(keySchema, patternValue));
          }
          const schemasToIntersect = [];
          if (Object.keys(shape).length > 0) {
            schemasToIntersect.push(z.object(shape).passthrough());
          }
          schemasToIntersect.push(...looseRecords);
          if (schemasToIntersect.length === 0) {
            zodSchema = z.object({}).passthrough();
          } else if (schemasToIntersect.length === 1) {
            zodSchema = schemasToIntersect[0];
          } else {
            let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
            for (let i = 2; i < schemasToIntersect.length; i++) {
              result = z.intersection(result, schemasToIntersect[i]);
            }
            zodSchema = result;
          }
          break;
        }
        const objectSchema = z.object(shape);
        if (schema.additionalProperties === false) {
          zodSchema = objectSchema.strict();
        } else if (typeof schema.additionalProperties === "object") {
          zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
        } else {
          zodSchema = objectSchema.passthrough();
        }
        break;
      }
      case "array": {
        const prefixItems = schema.prefixItems;
        const items = schema.items;
        if (prefixItems && Array.isArray(prefixItems)) {
          const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
          const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
          if (rest) {
            zodSchema = z.tuple(tupleItems).rest(rest);
          } else {
            zodSchema = z.tuple(tupleItems);
          }
          if (typeof schema.minItems === "number") {
            zodSchema = zodSchema.check(z.minLength(schema.minItems));
          }
          if (typeof schema.maxItems === "number") {
            zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
          }
        } else if (Array.isArray(items)) {
          const tupleItems = items.map((item) => convertSchema(item, ctx));
          const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
          if (rest) {
            zodSchema = z.tuple(tupleItems).rest(rest);
          } else {
            zodSchema = z.tuple(tupleItems);
          }
          if (typeof schema.minItems === "number") {
            zodSchema = zodSchema.check(z.minLength(schema.minItems));
          }
          if (typeof schema.maxItems === "number") {
            zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
          }
        } else if (items !== void 0) {
          const element = convertSchema(items, ctx);
          let arraySchema = z.array(element);
          if (typeof schema.minItems === "number") {
            arraySchema = arraySchema.min(schema.minItems);
          }
          if (typeof schema.maxItems === "number") {
            arraySchema = arraySchema.max(schema.maxItems);
          }
          zodSchema = arraySchema;
        } else {
          zodSchema = z.array(z.any());
        }
        break;
      }
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
    if (schema.description) {
      zodSchema = zodSchema.describe(schema.description);
    }
    if (schema.default !== void 0) {
      zodSchema = zodSchema.default(schema.default);
    }
    return zodSchema;
  }
  function convertSchema(schema, ctx) {
    if (typeof schema === "boolean") {
      return schema ? z.any() : z.never();
    }
    let baseSchema = convertBaseSchema(schema, ctx);
    const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
    if (schema.anyOf && Array.isArray(schema.anyOf)) {
      const options = schema.anyOf.map((s) => convertSchema(s, ctx));
      const anyOfUnion = z.union(options);
      baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
    }
    if (schema.oneOf && Array.isArray(schema.oneOf)) {
      const options = schema.oneOf.map((s) => convertSchema(s, ctx));
      const oneOfUnion = z.xor(options);
      baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
    }
    if (schema.allOf && Array.isArray(schema.allOf)) {
      if (schema.allOf.length === 0) {
        baseSchema = hasExplicitType ? baseSchema : z.any();
      } else {
        let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
        const startIdx = hasExplicitType ? 0 : 1;
        for (let i = startIdx; i < schema.allOf.length; i++) {
          result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
        }
        baseSchema = result;
      }
    }
    if (schema.nullable === true && ctx.version === "openapi-3.0") {
      baseSchema = z.nullable(baseSchema);
    }
    if (schema.readOnly === true) {
      baseSchema = z.readonly(baseSchema);
    }
    const extraMeta = {};
    const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
    for (const key of coreMetadataKeys) {
      if (key in schema) {
        extraMeta[key] = schema[key];
      }
    }
    const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
    for (const key of contentMetadataKeys) {
      if (key in schema) {
        extraMeta[key] = schema[key];
      }
    }
    for (const key of Object.keys(schema)) {
      if (!RECOGNIZED_KEYS.has(key)) {
        extraMeta[key] = schema[key];
      }
    }
    if (Object.keys(extraMeta).length > 0) {
      ctx.registry.add(baseSchema, extraMeta);
    }
    return baseSchema;
  }
  function fromJSONSchema(schema, params) {
    if (typeof schema === "boolean") {
      return schema ? z.any() : z.never();
    }
    const version2 = detectVersion(schema, params?.defaultTarget);
    const defs = schema.$defs || schema.definitions || {};
    const ctx = {
      version: version2,
      defs,
      refs: /* @__PURE__ */ new Map(),
      processing: /* @__PURE__ */ new Set(),
      rootSchema: schema,
      registry: params?.registry ?? globalRegistry
    };
    return convertSchema(schema, ctx);
  }
  var z, RECOGNIZED_KEYS;
  var init_from_json_schema = __esm({
    "node_modules/zod/v4/classic/from-json-schema.js"() {
      init_registries();
      init_checks2();
      init_iso();
      init_schemas2();
      z = {
        ...schemas_exports2,
        ...checks_exports2,
        iso: iso_exports
      };
      RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
        // Schema identification
        "$schema",
        "$ref",
        "$defs",
        "definitions",
        // Core schema keywords
        "$id",
        "id",
        "$comment",
        "$anchor",
        "$vocabulary",
        "$dynamicRef",
        "$dynamicAnchor",
        // Type
        "type",
        "enum",
        "const",
        // Composition
        "anyOf",
        "oneOf",
        "allOf",
        "not",
        // Object
        "properties",
        "required",
        "additionalProperties",
        "patternProperties",
        "propertyNames",
        "minProperties",
        "maxProperties",
        // Array
        "items",
        "prefixItems",
        "additionalItems",
        "minItems",
        "maxItems",
        "uniqueItems",
        "contains",
        "minContains",
        "maxContains",
        // String
        "minLength",
        "maxLength",
        "pattern",
        "format",
        // Number
        "minimum",
        "maximum",
        "exclusiveMinimum",
        "exclusiveMaximum",
        "multipleOf",
        // Already handled metadata
        "description",
        "default",
        // Content
        "contentEncoding",
        "contentMediaType",
        "contentSchema",
        // Unsupported (error-throwing)
        "unevaluatedItems",
        "unevaluatedProperties",
        "if",
        "then",
        "else",
        "dependentSchemas",
        "dependentRequired",
        // OpenAPI
        "nullable",
        "readOnly"
      ]);
    }
  });

  // node_modules/zod/v4/classic/coerce.js
  var coerce_exports = {};
  __export(coerce_exports, {
    bigint: () => bigint3,
    boolean: () => boolean3,
    date: () => date4,
    number: () => number3,
    string: () => string3
  });
  function string3(params) {
    return _coercedString(ZodString, params);
  }
  function number3(params) {
    return _coercedNumber(ZodNumber, params);
  }
  function boolean3(params) {
    return _coercedBoolean(ZodBoolean, params);
  }
  function bigint3(params) {
    return _coercedBigint(ZodBigInt, params);
  }
  function date4(params) {
    return _coercedDate(ZodDate, params);
  }
  var init_coerce = __esm({
    "node_modules/zod/v4/classic/coerce.js"() {
      init_core2();
      init_schemas2();
    }
  });

  // node_modules/zod/v4/classic/external.js
  var external_exports = {};
  __export(external_exports, {
    $brand: () => $brand,
    $input: () => $input,
    $output: () => $output,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodExactOptional: () => ZodExactOptional,
    ZodFile: () => ZodFile,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMAC: () => ZodMAC,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRealError: () => ZodRealError,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    ZodXor: () => ZodXor,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    clone: () => clone,
    codec: () => codec,
    coerce: () => coerce_exports,
    config: () => config,
    core: () => core_exports2,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    decode: () => decode2,
    decodeAsync: () => decodeAsync2,
    describe: () => describe2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    encode: () => encode2,
    encodeAsync: () => encodeAsync2,
    endsWith: () => _endsWith,
    enum: () => _enum2,
    exactOptional: () => exactOptional,
    file: () => file,
    flattenError: () => flattenError,
    float32: () => float32,
    float64: () => float64,
    formatError: () => formatError,
    fromJSONSchema: () => fromJSONSchema,
    function: () => _function,
    getErrorMap: () => getErrorMap,
    globalRegistry: () => globalRegistry,
    gt: () => _gt,
    gte: () => _gte,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    includes: () => _includes,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    iso: () => iso_exports,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    length: () => _length,
    literal: () => literal,
    locales: () => locales_exports,
    looseObject: () => looseObject,
    looseRecord: () => looseRecord,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    mac: () => mac2,
    map: () => map,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    meta: () => meta2,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    negative: () => _negative,
    never: () => never,
    nonnegative: () => _nonnegative,
    nonoptional: () => nonoptional,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    overwrite: () => _overwrite,
    parse: () => parse2,
    parseAsync: () => parseAsync2,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    positive: () => _positive,
    prefault: () => prefault,
    preprocess: () => preprocess,
    prettifyError: () => prettifyError,
    promise: () => promise,
    property: () => _property,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    regex: () => _regex,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode2,
    safeDecodeAsync: () => safeDecodeAsync2,
    safeEncode: () => safeEncode2,
    safeEncodeAsync: () => safeEncodeAsync2,
    safeParse: () => safeParse2,
    safeParseAsync: () => safeParseAsync2,
    set: () => set,
    setErrorMap: () => setErrorMap,
    size: () => _size,
    slugify: () => _slugify,
    startsWith: () => _startsWith,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol,
    templateLiteral: () => templateLiteral,
    toJSONSchema: () => toJSONSchema,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    transform: () => transform,
    treeifyError: () => treeifyError,
    trim: () => _trim,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    uppercase: () => _uppercase,
    url: () => url,
    util: () => util_exports,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2,
    xor: () => xor
  });
  var init_external = __esm({
    "node_modules/zod/v4/classic/external.js"() {
      init_core2();
      init_schemas2();
      init_checks2();
      init_errors2();
      init_parse2();
      init_compat();
      init_core2();
      init_en();
      init_core2();
      init_json_schema_processors();
      init_from_json_schema();
      init_locales();
      init_iso();
      init_iso();
      init_coerce();
      config(en_default());
    }
  });

  // node_modules/zod/index.js
  var init_zod = __esm({
    "node_modules/zod/index.js"() {
      init_external();
      init_external();
    }
  });

  // src/config/config-manager.js
  var mergedConfigSchema, ConfigManager;
  var init_config_manager = __esm({
    "src/config/config-manager.js"() {
      "use strict";
      init_zod();
      mergedConfigSchema = external_exports.object({
        storageMode: external_exports.enum(["local", "pinboard", "file", "sync"]).optional(),
        hoverShowRecentTags: external_exports.boolean().optional(),
        hoverShowTooltips: external_exports.boolean().optional(),
        showHoverOnPageLoad: external_exports.boolean().optional(),
        showHoverOPLOnlyIfNoTags: external_exports.boolean().optional(),
        showHoverOPLOnlyIfSomeTags: external_exports.boolean().optional(),
        inhibitSitesOnPageLoad: external_exports.boolean().optional(),
        setIconOnLoad: external_exports.boolean().optional(),
        recentTagsCountMax: external_exports.number().int().min(0).optional(),
        initRecentPostsCount: external_exports.number().int().min(0).optional(),
        uxAutoCloseTimeout: external_exports.number().min(0).optional(),
        uxRecentRowWithBlock: external_exports.boolean().optional(),
        uxRecentRowWithBookmarkButton: external_exports.boolean().optional(),
        uxRecentRowWithCloseButton: external_exports.boolean().optional(),
        uxRecentRowWithPrivateButton: external_exports.boolean().optional(),
        uxRecentRowWithDeletePin: external_exports.boolean().optional(),
        uxRecentRowWithInput: external_exports.boolean().optional(),
        uxUrlStripHash: external_exports.boolean().optional(),
        uxShowSectionLabels: external_exports.boolean().optional(),
        recentTagsMaxListSize: external_exports.number().int().min(0).optional(),
        recentTagsMaxDisplayCount: external_exports.number().int().min(0).optional(),
        recentTagsSharedMemoryKey: external_exports.string().optional(),
        recentTagsEnableUserDriven: external_exports.boolean().optional(),
        recentTagsClearOnReload: external_exports.boolean().optional(),
        badgeTextIfNotBookmarked: external_exports.string().optional(),
        badgeTextIfPrivate: external_exports.string().optional(),
        badgeTextIfQueued: external_exports.string().optional(),
        badgeTextIfBookmarkedNoTags: external_exports.string().optional(),
        pinRetryCountMax: external_exports.number().int().min(0).optional(),
        pinRetryDelay: external_exports.number().min(0).optional(),
        defaultVisibilityTheme: external_exports.string().optional(),
        defaultTransparencyEnabled: external_exports.boolean().optional(),
        defaultBackgroundOpacity: external_exports.number().min(0).max(100).optional(),
        overlayPositionMode: external_exports.string().optional(),
        fontSizeSuggestedTags: external_exports.number().int().min(1).optional(),
        fontSizeLabels: external_exports.number().int().min(1).optional(),
        fontSizeTags: external_exports.number().int().min(1).optional(),
        fontSizeBase: external_exports.number().int().min(1).optional(),
        fontSizeInputs: external_exports.number().int().min(1).optional(),
        aiApiKey: external_exports.string().optional(),
        aiProvider: external_exports.string().optional(),
        aiTagLimit: external_exports.number().int().min(0).optional()
      }).passthrough();
      ConfigManager = class {
        constructor() {
          this.storageKeys = {
            AUTH_TOKEN: "hoverboard_auth_token",
            SETTINGS: "hoverboard_settings",
            STORAGE_MODE: "hoverboard_storage_mode",
            // [ARCH-LOCAL_STORAGE_PROVIDER] - Bookmark storage mode (pinboard | local)
            INHIBIT_URLS: "hoverboard_inhibit_urls",
            RECENT_TAGS: "hoverboard_recent_tags",
            // [IMMUTABLE-REQ-TAG-001] - Tag storage key
            TAG_FREQUENCY: "hoverboard_tag_frequency"
            // [IMMUTABLE-REQ-TAG-001] - Tag frequency storage key
          };
          this.defaultConfig = this.getDefaultConfiguration();
        }
        /**
         * Get default configuration values
         * Migrated from src/shared/config.js
         * @returns {MergedConfig}
         * IMPL-FEATURE_FLAGS: Feature flags and UI behavior control defaults
         * SPECIFICATION: Each setting controls specific extension behavior
         * IMPLEMENTATION DECISION: Conservative defaults favor user privacy and minimal intrusion
         */
        getDefaultConfiguration() {
          return {
            // [ARCH-LOCAL_STORAGE_PROVIDER] [REQ-STORAGE_MODE_DEFAULT] - Default local: preferable for most users (no account/API required)
            storageMode: "local",
            // IMPL-FEATURE_FLAGS: Feature flags - Core functionality toggles
            // IMPLEMENTATION DECISION: Enable helpful features by default, disable potentially intrusive ones
            hoverShowRecentTags: true,
            // Show recent tags in hover overlay
            hoverShowTooltips: false,
            // Tooltips disabled by default to avoid visual clutter
            showHoverOnPageLoad: false,
            // No automatic hover to respect user intent
            showHoverOPLOnlyIfNoTags: true,
            // Smart overlay display logic
            showHoverOPLOnlyIfSomeTags: false,
            // Complementary to above setting
            inhibitSitesOnPageLoad: true,
            // Respect site-specific inhibition settings
            setIconOnLoad: true,
            // Update extension icon to reflect bookmark status
            // IMPL-FEATURE_FLAGS: UI behavior settings - User experience configuration
            // IMPLEMENTATION DECISION: Reasonable limits that balance functionality with performance
            recentTagsCountMax: 32,
            // Maximum recent tags to track
            initRecentPostsCount: 15,
            // Initial recent posts to load
            uxAutoCloseTimeout: 0,
            // in ms, 0 to disable auto-close (user control)
            uxRecentRowWithBlock: true,
            // Show block button in recent rows
            uxRecentRowWithBookmarkButton: true,
            // Show bookmark button
            uxRecentRowWithCloseButton: true,
            // Show close button for user control
            uxRecentRowWithPrivateButton: true,
            // Privacy control in interface
            uxRecentRowWithDeletePin: true,
            // Allow pin deletion from interface
            uxRecentRowWithInput: true,
            // Enable input controls
            uxUrlStripHash: false,
            // Preserve URL hash by default (maintain full URL context)
            uxShowSectionLabels: false,
            // Show section labels in popup (Quick Actions, Search Tabs)
            // [IMMUTABLE-REQ-TAG-003] - Recent tags configuration
            // IMPLEMENTATION DECISION: Conservative defaults for shared memory management
            recentTagsMaxListSize: 50,
            // Maximum recent tags in shared memory
            recentTagsMaxDisplayCount: 10,
            // Maximum tags to display in UI
            recentTagsSharedMemoryKey: "hoverboard_recent_tags_shared",
            // Shared memory key
            recentTagsEnableUserDriven: true,
            // Enable user-driven recent tags
            recentTagsClearOnReload: true,
            // Clear shared memory on extension reload
            // IMPL-FEATURE_FLAGS: Badge configuration - Extension icon indicator settings
            // IMPLEMENTATION DECISION: Clear visual indicators for different bookmark states
            badgeTextIfNotBookmarked: "-",
            // Clear indication of non-bookmarked state
            badgeTextIfPrivate: "*",
            // Privacy indicator
            badgeTextIfQueued: "!",
            // Pending action indicator
            badgeTextIfBookmarkedNoTags: "0",
            // Zero tags indicator
            // IMPL-CONFIG_MIGRATION: API retry configuration - Network resilience settings
            // IMPLEMENTATION DECISION: Conservative retry strategy to avoid API rate limiting
            pinRetryCountMax: 2,
            // Maximum retry attempts
            pinRetryDelay: 1e3,
            // in ms - delay between retries
            //  UI-006: Visibility Controls -  Per-window overlay appearance defaults
            // IMPLEMENTATION DECISION: Conservative defaults for broad compatibility and readability
            defaultVisibilityTheme: "light-on-dark",
            // 'light-on-dark' | 'dark-on-light' - Dark theme default
            defaultTransparencyEnabled: false,
            // Conservative default - solid background for readability
            defaultBackgroundOpacity: 90,
            // 10-100% - High opacity default for good contrast
            overlayPositionMode: "default",
            // 'default' | 'bottom-fixed' - Keep existing position setting
            // Font size configuration - User-customizable text sizes across UI
            // IMPLEMENTATION DECISION: Reasonable defaults with customization for accessibility
            fontSizeSuggestedTags: 10,
            // Suggested tags font size in pixels (smaller for less intrusion)
            fontSizeLabels: 12,
            // Label text (Current, Recent, Suggested) in pixels
            fontSizeTags: 12,
            // Current and recent tag elements in pixels
            fontSizeBase: 14,
            // Base UI text size in pixels
            fontSizeInputs: 14,
            // Input fields and buttons font size in pixels
            // [REQ-AI_TAGGING_CONFIG] [ARCH-AI_TAGGING_CONFIG] [IMPL-AI_CONFIG_OPTIONS] AI tagging defaults for options and storage; empty key disables feature.
            aiApiKey: "",
            aiProvider: "openai",
            aiTagLimit: 64
          };
        }
        /**
         * Initialize default settings on first installation
         *
         * IMPL-FEATURE_FLAGS: First-run initialization ensures extension works immediately
         * IMPLEMENTATION DECISION: Only initialize if no settings exist to preserve user customizations
         */
        async initializeDefaults() {
          const existingSettings = await this.getStoredSettings();
          if (!existingSettings || Object.keys(existingSettings).length === 0) {
            await this.saveSettings(this.defaultConfig);
          }
        }
        /**
         * Get complete configuration object
         * @returns {Promise<MergedConfig>} Configuration object
         *
         * IMPL-FEATURE_FLAGS: Configuration resolution with default fallback
         * IMPLEMENTATION DECISION: Merge defaults with stored settings to handle partial configurations
         */
        async getConfig() {
          const stored = await this.getStoredSettings();
          if (!stored || typeof stored !== "object" || Array.isArray(stored)) {
            return { ...this.defaultConfig };
          }
          const merged = { ...this.defaultConfig, ...stored };
          const parsed = mergedConfigSchema.safeParse(merged);
          if (!parsed.success) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("[IMPL-RUNTIME_VALIDATION] Config validation failed, using defaults:", parsed.error?.issues);
            }
            return { ...this.defaultConfig };
          }
          return parsed.data;
        }
        /**
         * Get user-configurable options (subset of config for UI)
         * @returns {Promise<Object>} Options object
         *
         * IMPL-FEATURE_FLAGS: UI-specific configuration subset
         * IMPLEMENTATION DECISION: Only expose user-relevant settings to avoid configuration complexity
         */
        async getOptions() {
          const config2 = await this.getConfig();
          return {
            badgeTextIfBookmarkedNoTags: config2.badgeTextIfBookmarkedNoTags,
            badgeTextIfNotBookmarked: config2.badgeTextIfNotBookmarked,
            badgeTextIfPrivate: config2.badgeTextIfPrivate,
            badgeTextIfQueued: config2.badgeTextIfQueued,
            recentPostsCount: config2.initRecentPostsCount,
            showHoverOnPageLoad: config2.showHoverOnPageLoad,
            hoverShowTooltips: config2.hoverShowTooltips,
            // UI-006: Visibility defaults for configuration UI
            defaultVisibilityTheme: config2.defaultVisibilityTheme,
            defaultTransparencyEnabled: config2.defaultTransparencyEnabled,
            defaultBackgroundOpacity: config2.defaultBackgroundOpacity,
            // Popup UI settings
            uxShowSectionLabels: config2.uxShowSectionLabels,
            // Font size configuration
            fontSizeSuggestedTags: config2.fontSizeSuggestedTags,
            fontSizeLabels: config2.fontSizeLabels,
            fontSizeTags: config2.fontSizeTags,
            fontSizeBase: config2.fontSizeBase,
            fontSizeInputs: config2.fontSizeInputs
          };
        }
        /**
         * Update specific configuration values
         * @param {Partial<MergedConfig>} updates - Configuration updates
         *
         * IMPL-FEATURE_FLAGS: Partial configuration updates with persistence
         * IMPLEMENTATION DECISION: Merge updates to preserve unmodified settings
         */
        async updateConfig(updates) {
          const current = await this.getConfig();
          const updated = { ...current, ...updates };
          await this.saveSettings(updated);
        }
        /**
         * Get bookmark storage mode (default backend for new bookmarks when using router).
         * @returns {Promise<string>} 'pinboard', 'local', 'file', or 'sync'
         *
         * [ARCH-LOCAL_STORAGE_PROVIDER] [ARCH-STORAGE_INDEX_AND_ROUTER] Storage mode for provider selection and default for new bookmarks
         * IMPLEMENTATION DECISION: Stored in settings blob; invalid values fall back to 'local'
         */
        async getStorageMode() {
          const config2 = await this.getConfig();
          const mode = config2.storageMode;
          return mode === "local" || mode === "pinboard" || mode === "file" || mode === "sync" ? mode : "local";
        }
        /**
         * Set bookmark storage mode
         * @param {string} mode - 'pinboard', 'local', 'file', or 'sync'
         *
         * [ARCH-LOCAL_STORAGE_PROVIDER] [ARCH-STORAGE_INDEX_AND_ROUTER] Persist storage mode
         */
        async setStorageMode(mode) {
          if (mode !== "pinboard" && mode !== "local" && mode !== "file" && mode !== "sync") {
            throw new Error(`Invalid storage mode: ${mode}. Use 'pinboard', 'local', 'file', or 'sync'.`);
          }
          await this.updateConfig({ storageMode: mode });
        }
        /**
         * Get visibility default settings
         * @returns {Promise<Object>} Visibility defaults object
         *
         * UI-006: Visibility defaults retrieval
         * IMPLEMENTATION DECISION: Dedicated method for overlay visibility configuration
         */
        async getVisibilityDefaults() {
          const config2 = await this.getConfig();
          return {
            textTheme: config2.defaultVisibilityTheme,
            transparencyEnabled: config2.defaultTransparencyEnabled,
            backgroundOpacity: config2.defaultBackgroundOpacity
          };
        }
        /**
         * Update visibility default settings
         * @param {{ textTheme?: string, transparencyEnabled?: boolean, backgroundOpacity?: number }} visibilitySettings - New visibility defaults
         *
         * UI-006: Visibility defaults update
         * IMPLEMENTATION DECISION: Dedicated method for clean visibility settings management
         */
        async updateVisibilityDefaults(visibilitySettings) {
          const updates = {};
          if (visibilitySettings.textTheme !== void 0) {
            updates.defaultVisibilityTheme = visibilitySettings.textTheme;
          }
          if (visibilitySettings.transparencyEnabled !== void 0) {
            updates.defaultTransparencyEnabled = visibilitySettings.transparencyEnabled;
          }
          if (visibilitySettings.backgroundOpacity !== void 0) {
            updates.defaultBackgroundOpacity = visibilitySettings.backgroundOpacity;
          }
          await this.updateConfig(updates);
        }
        /**
         * Get authentication token
         * @returns {Promise<string>} Auth token or empty string
         *
         * IMPL-CONFIG_MIGRATION: Secure authentication token retrieval
         * IMPLEMENTATION DECISION: Return empty string on failure to ensure graceful degradation
         */
        async getAuthToken() {
          try {
            const result = await chrome.storage.sync.get(this.storageKeys.AUTH_TOKEN);
            return result[this.storageKeys.AUTH_TOKEN] || "";
          } catch (error48) {
            console.error("Failed to get auth token:", error48);
            return "";
          }
        }
        /**
         * Set authentication token
         * @param {string} token - Pinboard API token
         *
         * IMPL-CONFIG_MIGRATION: Secure authentication token storage
         * IMPLEMENTATION DECISION: Use sync storage for cross-device authentication
         */
        async setAuthToken(token) {
          try {
            await chrome.storage.sync.set({
              [this.storageKeys.AUTH_TOKEN]: token
            });
          } catch (error48) {
            console.error("Failed to set auth token:", error48);
            throw error48;
          }
        }
        /**
         * Check if authentication token exists
         * @returns {Promise<boolean>} Whether token exists
         *
         * IMPL-CONFIG_MIGRATION: Authentication state validation
         * IMPLEMENTATION DECISION: Simple boolean check for authentication state
         */
        async hasAuthToken() {
          const token = await this.getAuthToken();
          return token.length > 0;
        }
        /**
         * Get authentication token formatted for API requests
         * @returns {Promise<string>} Token formatted as URL parameter
         *
         * IMPL-CONFIG_MIGRATION: API-ready authentication parameter formatting
         * IMPLEMENTATION DECISION: Pre-format token for consistent API usage
         */
        async getAuthTokenParam() {
          const token = await this.getAuthToken();
          return `auth_token=${token}`;
        }
        /**
         * [IMPL-URL_INHIBITION] [ARCH-CONFIG_STRUCTURE] [REQ-SITE_MANAGEMENT] Get inhibited URLs list (newline-separated).
         * @returns {Promise<string[]>} Array of inhibited URLs
         */
        async getInhibitUrls() {
          try {
            const result = await chrome.storage.sync.get(this.storageKeys.INHIBIT_URLS);
            const inhibitString = result[this.storageKeys.INHIBIT_URLS] || "";
            return inhibitString.split("\n").filter((url2) => url2.trim().length > 0);
          } catch (error48) {
            console.error("Failed to get inhibit URLs:", error48);
            return [];
          }
        }
        /**
         * [IMPL-URL_INHIBITION] [ARCH-CONFIG_STRUCTURE] [REQ-SITE_MANAGEMENT] Add URL to inhibit list (no duplicate).
         * @param {string} url - URL to inhibit
         */
        async addInhibitUrl(url2) {
          try {
            const normalizedUrl = url2.replace(/^https?:\/\//, "");
            const current = await this.getInhibitUrls();
            if (!current.includes(normalizedUrl)) {
              current.push(normalizedUrl);
              const inhibitString = current.join("\n");
              await chrome.storage.sync.set({
                [this.storageKeys.INHIBIT_URLS]: inhibitString
              });
            }
            return { inhibit: current.join("\n") };
          } catch (error48) {
            console.error("Failed to add inhibit URL:", error48);
            throw error48;
          }
        }
        /**
         * [IMPL-URL_INHIBITION] [ARCH-CONFIG_STRUCTURE] [REQ-SITE_MANAGEMENT] Set inhibit URLs list (replaces existing).
         * @param {string[]} urls - Array of URLs to inhibit
         */
        async setInhibitUrls(urls) {
          try {
            const inhibitString = urls.join("\n");
            await chrome.storage.sync.set({
              [this.storageKeys.INHIBIT_URLS]: inhibitString
            });
          } catch (error48) {
            console.error("Failed to set inhibit URLs:", error48);
            throw error48;
          }
        }
        /**
         * [IMPL-URL_INHIBITION] [ARCH-CONFIG_STRUCTURE] [REQ-SITE_MANAGEMENT] Check if URL is allowed (not in inhibit list; substring match).
         * @param {string} url - URL to check
         * @returns {Promise<boolean>} Whether URL is allowed
         */
        async isUrlAllowed(url2) {
          try {
            const inhibitUrls = await this.getInhibitUrls();
            const normalizedUrl = url2.replace(/^https?:\/\//, "");
            return !inhibitUrls.some(
              (inhibitUrl) => normalizedUrl.includes(inhibitUrl) || inhibitUrl.includes(normalizedUrl)
            );
          } catch (error48) {
            console.error("Failed to check URL allowance:", error48);
            return true;
          }
        }
        /**
         * Get stored settings from storage
         * @returns {Promise<Object>} Stored settings
         *
         * IMPL-FEATURE_FLAGS: Core settings retrieval with error handling
         * IMPLEMENTATION DECISION: Return empty object on failure to allow default merging
         */
        async getStoredSettings() {
          try {
            const result = await chrome.storage.sync.get(this.storageKeys.SETTINGS);
            const stored = result[this.storageKeys.SETTINGS];
            if (typeof stored === "string") {
              try {
                return JSON.parse(stored);
              } catch (parseError) {
                console.error("Failed to parse stored settings:", parseError);
                return {};
              }
            }
            return stored || {};
          } catch (error48) {
            console.error("Failed to get stored settings:", error48);
            return {};
          }
        }
        /**
         * Save settings to storage
         * @param {MergedConfig|Record<string, unknown>} settings - Settings to save
         *
         * IMPL-FEATURE_FLAGS: Settings persistence with error propagation
         * IMPLEMENTATION DECISION: Let errors propagate to caller for proper error handling
         */
        async saveSettings(settings) {
          try {
            await chrome.storage.sync.set({
              [this.storageKeys.SETTINGS]: settings
            });
          } catch (error48) {
            console.error("Failed to save settings:", error48);
            throw error48;
          }
        }
        /**
         * Reset all settings to defaults
         *
         * IMPL-FEATURE_FLAGS: Configuration reset functionality
         * IMPLEMENTATION DECISION: Simple replacement with defaults for clean reset
         */
        async resetToDefaults() {
          await this.saveSettings(this.defaultConfig);
        }
        /**
         * Export configuration for backup
         * @returns {Promise<Object>} Complete configuration export
         *
         * IMPL-CONFIG_BACKUP_RESTORE: Configuration backup and portability
         * IMPLEMENTATION DECISION: Include all configuration data with metadata for validation
         */
        async exportConfig() {
          const [settings, token, inhibitUrls] = await Promise.all([
            this.getStoredSettings(),
            this.getAuthToken(),
            this.getInhibitUrls()
          ]);
          return {
            settings,
            authToken: token,
            inhibitUrls,
            exportDate: (/* @__PURE__ */ new Date()).toISOString(),
            version: "1.0.0"
            // Version for import compatibility checking
          };
        }
        /**
         * Import configuration from backup
         * @param {{ settings?: MergedConfig|Record<string, unknown>, authToken?: string, inhibitUrls?: string[] }} configData - Configuration data to import
         *
         * IMPL-CONFIG_BACKUP_RESTORE: Configuration restoration from backup
         * IMPLEMENTATION DECISION: Selective import allows partial configuration restoration
         */
        async importConfig(configData) {
          if (configData.settings) {
            await this.saveSettings(configData.settings);
          }
          if (configData.authToken) {
            await this.setAuthToken(configData.authToken);
          }
          if (configData.inhibitUrls) {
            const inhibitString = configData.inhibitUrls.join("\n");
            await chrome.storage.sync.set({
              [this.storageKeys.INHIBIT_URLS]: inhibitString
            });
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Enhanced tag storage management
         * @param {string[]} tags - Array of tags to store
         * @returns {Promise<void>}
         */
        async updateRecentTags(tags) {
          try {
            if (!Array.isArray(tags)) {
              console.warn("[IMMUTABLE-REQ-TAG-001] Invalid tags array provided");
              return;
            }
            const config2 = await this.getConfig();
            const maxTags = config2.recentTagsCountMax || 50;
            const limitedTags = tags.slice(0, maxTags);
            await chrome.storage.sync.set({
              [this.storageKeys.RECENT_TAGS]: {
                tags: limitedTags,
                timestamp: Date.now(),
                count: limitedTags.length
              }
            });
          } catch (error48) {
            console.error("[IMMUTABLE-REQ-TAG-001] Failed to update recent tags:", error48);
            try {
              await chrome.storage.local.set({
                [this.storageKeys.RECENT_TAGS]: {
                  tags: tags.slice(0, 50),
                  timestamp: Date.now(),
                  count: Math.min(tags.length, 50)
                }
              });
            } catch (fallbackError) {
              console.error("[IMMUTABLE-REQ-TAG-001] Fallback storage also failed:", fallbackError);
            }
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Get recent tags with deduplication
         * @returns {Promise<string[]>} Array of recent tags
         */
        async getRecentTags() {
          try {
            const syncResult = await chrome.storage.sync.get(this.storageKeys.RECENT_TAGS);
            if (syncResult[this.storageKeys.RECENT_TAGS]) {
              return syncResult[this.storageKeys.RECENT_TAGS].tags || [];
            }
            const localResult = await chrome.storage.local.get(this.storageKeys.RECENT_TAGS);
            if (localResult[this.storageKeys.RECENT_TAGS]) {
              return localResult[this.storageKeys.RECENT_TAGS].tags || [];
            }
            return [];
          } catch (error48) {
            console.error("[IMMUTABLE-REQ-TAG-001] Failed to get recent tags:", error48);
            return [];
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Get tag frequency data
         * @returns {Promise<Object>} Tag frequency map
         */
        async getTagFrequency() {
          try {
            const result = await chrome.storage.local.get(this.storageKeys.TAG_FREQUENCY);
            return result[this.storageKeys.TAG_FREQUENCY] || {};
          } catch (error48) {
            console.error("[IMMUTABLE-REQ-TAG-001] Failed to get tag frequency:", error48);
            return {};
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Update tag frequency
         * @param {Object} frequency - Updated frequency map
         * @returns {Promise<void>}
         */
        async updateTagFrequency(frequency) {
          try {
            await chrome.storage.local.set({
              [this.storageKeys.TAG_FREQUENCY]: frequency
            });
          } catch (error48) {
            console.error("[IMMUTABLE-REQ-TAG-001] Failed to update tag frequency:", error48);
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Clean up old tags to manage storage
         * @returns {Promise<void>}
         */
        async cleanupOldTags() {
          try {
            const config2 = await this.getConfig();
            const maxTags = config2.recentTagsCountMax || 50;
            const recentTags = await this.getRecentTags();
            if (recentTags.length > maxTags) {
              const trimmedTags = recentTags.slice(0, maxTags);
              await this.updateRecentTags(trimmedTags);
            }
          } catch (error48) {
            console.error("[IMMUTABLE-REQ-TAG-001] Failed to cleanup old tags:", error48);
          }
        }
      };
    }
  });

  // node_modules/fast-xml-parser/src/util.js
  function getAllMatches(string4, regex) {
    const matches = [];
    let match = regex.exec(string4);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0; index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string4);
    }
    return matches;
  }
  function isExist(v) {
    return typeof v !== "undefined";
  }
  var nameStartChar, nameChar, nameRegexp, regexName, isName;
  var init_util2 = __esm({
    "node_modules/fast-xml-parser/src/util.js"() {
      "use strict";
      nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      regexName = new RegExp("^" + nameRegexp + "$");
      isName = function(string4) {
        const match = regexName.exec(string4);
        return !(match === null || typeof match === "undefined");
      };
    }
  });

  // node_modules/fast-xml-parser/src/validator.js
  function validate(xmlData, options) {
    options = Object.assign({}, defaultOptions, options);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i = 0; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
        i += 2;
        i = readPI(xmlData, i);
        if (i.err) return i;
      } else if (xmlData[i] === "<") {
        let tagStartPos = i;
        i++;
        if (xmlData[i] === "!") {
          i = readCommentAndCDATA(xmlData, i);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i] === "/") {
            closingTag = true;
            i++;
          }
          let tagName = "";
          for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
            tagName += xmlData[i];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
          }
          const result = readAttributeStr(xmlData, i);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
          }
          let attrStr = result.value;
          i = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options);
            if (isValid === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else if (tags.length === 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject(
                  "InvalidTag",
                  "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                  getLineNumberForPosition(xmlData, tagStartPos)
                );
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options);
            if (isValid !== true) {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
            } else if (options.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i++; i < xmlData.length; i++) {
            if (xmlData[i] === "<") {
              if (xmlData[i + 1] === "!") {
                i++;
                i = readCommentAndCDATA(xmlData, i);
                continue;
              } else if (xmlData[i + 1] === "?") {
                i = readPI(xmlData, ++i);
                if (i.err) return i;
              } else {
                break;
              }
            } else if (xmlData[i] === "&") {
              const afterAmp = validateAmpersand(xmlData, i);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
              i = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
              }
            }
          }
          if (xmlData[i] === "<") {
            i--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  }
  function isWhiteSpace(char) {
    return char === " " || char === "	" || char === "\n" || char === "\r";
  }
  function readPI(xmlData, i) {
    const start = i;
    for (; i < xmlData.length; i++) {
      if (xmlData[i] == "?" || xmlData[i] == " ") {
        const tagname = xmlData.substr(start, i - start);
        if (i > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
        } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
          i++;
          break;
        } else {
          continue;
        }
      }
    }
    return i;
  }
  function readCommentAndCDATA(xmlData, i) {
    if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
      for (i += 3; i < xmlData.length; i++) {
        if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
          i += 2;
          break;
        }
      }
    } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
      let angleBracketsCount = 1;
      for (i += 8; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
      for (i += 8; i < xmlData.length; i++) {
        if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
          i += 2;
          break;
        }
      }
    }
    return i;
  }
  function readAttributeStr(xmlData, i) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i];
        } else if (startChar !== xmlData[i]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i,
      tagClosed
    };
  }
  function validateAttributeString(attrStr, options) {
    const matches = getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i = 0; i < matches.length; i++) {
      if (matches[i][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
      }
      const attrName = matches[i][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
      }
    }
    return true;
  }
  function validateNumberAmpersand(xmlData, i) {
    let re = /\d/;
    if (xmlData[i] === "x") {
      i++;
      re = /[\da-fA-F]/;
    }
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === ";")
        return i;
      if (!xmlData[i].match(re))
        break;
    }
    return -1;
  }
  function validateAmpersand(xmlData, i) {
    i++;
    if (xmlData[i] === ";")
      return -1;
    if (xmlData[i] === "#") {
      i++;
      return validateNumberAmpersand(xmlData, i);
    }
    let count = 0;
    for (; i < xmlData.length; i++, count++) {
      if (xmlData[i].match(/\w/) && count < 20)
        continue;
      if (xmlData[i] === ";")
        break;
      return -1;
    }
    return i;
  }
  function getErrorObject(code, message, lineNumber) {
    return {
      err: {
        code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  function validateAttrName(attrName) {
    return isName(attrName);
  }
  function validateTagName(tagname) {
    return isName(tagname);
  }
  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      // column number is last line's length + 1, because column numbering starts at 1:
      col: lines[lines.length - 1].length + 1
    };
  }
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
  var defaultOptions, doubleQuote, singleQuote, validAttrStrRegxp;
  var init_validator = __esm({
    "node_modules/fast-xml-parser/src/validator.js"() {
      "use strict";
      init_util2();
      defaultOptions = {
        allowBooleanAttributes: false,
        //A tag can have attributes without any value
        unpairedTags: []
      };
      doubleQuote = '"';
      singleQuote = "'";
      validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  function normalizeProcessEntities(value) {
    if (typeof value === "boolean") {
      return {
        enabled: value,
        // true or false
        maxEntitySize: 1e4,
        maxExpansionDepth: 10,
        maxTotalExpansions: 1e3,
        maxExpandedLength: 1e5,
        allowedTags: null,
        tagFilter: null
      };
    }
    if (typeof value === "object" && value !== null) {
      return {
        enabled: value.enabled !== false,
        // default true if not specified
        maxEntitySize: value.maxEntitySize ?? 1e4,
        maxExpansionDepth: value.maxExpansionDepth ?? 10,
        maxTotalExpansions: value.maxTotalExpansions ?? 1e3,
        maxExpandedLength: value.maxExpandedLength ?? 1e5,
        allowedTags: value.allowedTags ?? null,
        tagFilter: value.tagFilter ?? null
      };
    }
    return normalizeProcessEntities(true);
  }
  var defaultOptions2, buildOptions;
  var init_OptionsBuilder = __esm({
    "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"() {
      defaultOptions2 = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        // remove NS from tag name or attribute name if true
        allowBooleanAttributes: false,
        //a tag can have attributes without any value
        //ignoreRootElement : false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        //Trim string values of tag and attributes
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val) {
          return val;
        },
        attributeValueProcessor: function(attrName, val) {
          return val;
        },
        stopNodes: [],
        //nested tags will not be parsed even for errors
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        },
        // skipEmptyListItem: false
        captureMetaData: false
      };
      buildOptions = function(options) {
        const built = Object.assign({}, defaultOptions2, options);
        built.processEntities = normalizeProcessEntities(built.processEntities);
        return built;
      };
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var METADATA_SYMBOL, XmlNode;
  var init_xmlNode = __esm({
    "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"() {
      "use strict";
      if (typeof Symbol !== "function") {
        METADATA_SYMBOL = "@@xmlMetadata";
      } else {
        METADATA_SYMBOL = /* @__PURE__ */ Symbol("XML Node Metadata");
      }
      XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val) {
          if (key === "__proto__") key = "#__proto__";
          this.child.push({ [key]: val });
        }
        addChild(node, startIndex) {
          if (node.tagname === "__proto__") node.tagname = "#__proto__";
          if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
          } else {
            this.child.push({ [node.tagname]: node.child });
          }
          if (startIndex !== void 0) {
            this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };
          }
        }
        /** symbol used for metadata */
        static getMetaDataSymbol() {
          return METADATA_SYMBOL;
        }
      };
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  function hasSeq(data, seq, i) {
    for (let j = 0; j < seq.length; j++) {
      if (seq[j] !== data[i + j + 1]) return false;
    }
    return true;
  }
  function validateEntityName(name) {
    if (isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  var DocTypeReader, skipWhitespace;
  var init_DocTypeReader = __esm({
    "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"() {
      init_util2();
      DocTypeReader = class {
        constructor(options) {
          this.suppressValidationErr = !options;
          this.options = options;
        }
        readDocType(xmlData, i) {
          const entities = {};
          if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
            i = i + 9;
            let angleBracketsCount = 1;
            let hasBody = false, comment = false;
            let exp = "";
            for (; i < xmlData.length; i++) {
              if (xmlData[i] === "<" && !comment) {
                if (hasBody && hasSeq(xmlData, "!ENTITY", i)) {
                  i += 7;
                  let entityName, val;
                  [entityName, val, i] = this.readEntityExp(xmlData, i + 1, this.suppressValidationErr);
                  if (val.indexOf("&") === -1) {
                    const escaped = entityName.replace(/[.\-+*:]/g, "\\.");
                    entities[entityName] = {
                      regx: RegExp(`&${escaped};`, "g"),
                      val
                    };
                  }
                } else if (hasBody && hasSeq(xmlData, "!ELEMENT", i)) {
                  i += 8;
                  const { index } = this.readElementExp(xmlData, i + 1);
                  i = index;
                } else if (hasBody && hasSeq(xmlData, "!ATTLIST", i)) {
                  i += 8;
                } else if (hasBody && hasSeq(xmlData, "!NOTATION", i)) {
                  i += 9;
                  const { index } = this.readNotationExp(xmlData, i + 1, this.suppressValidationErr);
                  i = index;
                } else if (hasSeq(xmlData, "!--", i)) comment = true;
                else throw new Error(`Invalid DOCTYPE`);
                angleBracketsCount++;
                exp = "";
              } else if (xmlData[i] === ">") {
                if (comment) {
                  if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                    comment = false;
                    angleBracketsCount--;
                  }
                } else {
                  angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
              } else if (xmlData[i] === "[") {
                hasBody = true;
              } else {
                exp += xmlData[i];
              }
            }
            if (angleBracketsCount !== 0) {
              throw new Error(`Unclosed DOCTYPE`);
            }
          } else {
            throw new Error(`Invalid Tag instead of DOCTYPE`);
          }
          return { entities, i };
        }
        readEntityExp(xmlData, i) {
          i = skipWhitespace(xmlData, i);
          let entityName = "";
          while (i < xmlData.length && !/\s/.test(xmlData[i]) && xmlData[i] !== '"' && xmlData[i] !== "'") {
            entityName += xmlData[i];
            i++;
          }
          validateEntityName(entityName);
          i = skipWhitespace(xmlData, i);
          if (!this.suppressValidationErr) {
            if (xmlData.substring(i, i + 6).toUpperCase() === "SYSTEM") {
              throw new Error("External entities are not supported");
            } else if (xmlData[i] === "%") {
              throw new Error("Parameter entities are not supported");
            }
          }
          let entityValue = "";
          [i, entityValue] = this.readIdentifierVal(xmlData, i, "entity");
          if (this.options.enabled !== false && this.options.maxEntitySize && entityValue.length > this.options.maxEntitySize) {
            throw new Error(
              `Entity "${entityName}" size (${entityValue.length}) exceeds maximum allowed size (${this.options.maxEntitySize})`
            );
          }
          i--;
          return [entityName, entityValue, i];
        }
        readNotationExp(xmlData, i) {
          i = skipWhitespace(xmlData, i);
          let notationName = "";
          while (i < xmlData.length && !/\s/.test(xmlData[i])) {
            notationName += xmlData[i];
            i++;
          }
          !this.suppressValidationErr && validateEntityName(notationName);
          i = skipWhitespace(xmlData, i);
          const identifierType = xmlData.substring(i, i + 6).toUpperCase();
          if (!this.suppressValidationErr && identifierType !== "SYSTEM" && identifierType !== "PUBLIC") {
            throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
          }
          i += identifierType.length;
          i = skipWhitespace(xmlData, i);
          let publicIdentifier = null;
          let systemIdentifier = null;
          if (identifierType === "PUBLIC") {
            [i, publicIdentifier] = this.readIdentifierVal(xmlData, i, "publicIdentifier");
            i = skipWhitespace(xmlData, i);
            if (xmlData[i] === '"' || xmlData[i] === "'") {
              [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, "systemIdentifier");
            }
          } else if (identifierType === "SYSTEM") {
            [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, "systemIdentifier");
            if (!this.suppressValidationErr && !systemIdentifier) {
              throw new Error("Missing mandatory system identifier for SYSTEM notation");
            }
          }
          return { notationName, publicIdentifier, systemIdentifier, index: --i };
        }
        readIdentifierVal(xmlData, i, type) {
          let identifierVal = "";
          const startChar = xmlData[i];
          if (startChar !== '"' && startChar !== "'") {
            throw new Error(`Expected quoted string, found "${startChar}"`);
          }
          i++;
          while (i < xmlData.length && xmlData[i] !== startChar) {
            identifierVal += xmlData[i];
            i++;
          }
          if (xmlData[i] !== startChar) {
            throw new Error(`Unterminated ${type} value`);
          }
          i++;
          return [i, identifierVal];
        }
        readElementExp(xmlData, i) {
          i = skipWhitespace(xmlData, i);
          let elementName = "";
          while (i < xmlData.length && !/\s/.test(xmlData[i])) {
            elementName += xmlData[i];
            i++;
          }
          if (!this.suppressValidationErr && !isName(elementName)) {
            throw new Error(`Invalid element name: "${elementName}"`);
          }
          i = skipWhitespace(xmlData, i);
          let contentModel = "";
          if (xmlData[i] === "E" && hasSeq(xmlData, "MPTY", i)) i += 4;
          else if (xmlData[i] === "A" && hasSeq(xmlData, "NY", i)) i += 2;
          else if (xmlData[i] === "(") {
            i++;
            while (i < xmlData.length && xmlData[i] !== ")") {
              contentModel += xmlData[i];
              i++;
            }
            if (xmlData[i] !== ")") {
              throw new Error("Unterminated content model");
            }
          } else if (!this.suppressValidationErr) {
            throw new Error(`Invalid Element Expression, found "${xmlData[i]}"`);
          }
          return {
            elementName,
            contentModel: contentModel.trim(),
            index: i
          };
        }
        readAttlistExp(xmlData, i) {
          i = skipWhitespace(xmlData, i);
          let elementName = "";
          while (i < xmlData.length && !/\s/.test(xmlData[i])) {
            elementName += xmlData[i];
            i++;
          }
          validateEntityName(elementName);
          i = skipWhitespace(xmlData, i);
          let attributeName = "";
          while (i < xmlData.length && !/\s/.test(xmlData[i])) {
            attributeName += xmlData[i];
            i++;
          }
          if (!validateEntityName(attributeName)) {
            throw new Error(`Invalid attribute name: "${attributeName}"`);
          }
          i = skipWhitespace(xmlData, i);
          let attributeType = "";
          if (xmlData.substring(i, i + 8).toUpperCase() === "NOTATION") {
            attributeType = "NOTATION";
            i += 8;
            i = skipWhitespace(xmlData, i);
            if (xmlData[i] !== "(") {
              throw new Error(`Expected '(', found "${xmlData[i]}"`);
            }
            i++;
            let allowedNotations = [];
            while (i < xmlData.length && xmlData[i] !== ")") {
              let notation = "";
              while (i < xmlData.length && xmlData[i] !== "|" && xmlData[i] !== ")") {
                notation += xmlData[i];
                i++;
              }
              notation = notation.trim();
              if (!validateEntityName(notation)) {
                throw new Error(`Invalid notation name: "${notation}"`);
              }
              allowedNotations.push(notation);
              if (xmlData[i] === "|") {
                i++;
                i = skipWhitespace(xmlData, i);
              }
            }
            if (xmlData[i] !== ")") {
              throw new Error("Unterminated list of notations");
            }
            i++;
            attributeType += " (" + allowedNotations.join("|") + ")";
          } else {
            while (i < xmlData.length && !/\s/.test(xmlData[i])) {
              attributeType += xmlData[i];
              i++;
            }
            const validTypes = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
            if (!this.suppressValidationErr && !validTypes.includes(attributeType.toUpperCase())) {
              throw new Error(`Invalid attribute type: "${attributeType}"`);
            }
          }
          i = skipWhitespace(xmlData, i);
          let defaultValue = "";
          if (xmlData.substring(i, i + 8).toUpperCase() === "#REQUIRED") {
            defaultValue = "#REQUIRED";
            i += 8;
          } else if (xmlData.substring(i, i + 7).toUpperCase() === "#IMPLIED") {
            defaultValue = "#IMPLIED";
            i += 7;
          } else {
            [i, defaultValue] = this.readIdentifierVal(xmlData, i, "ATTLIST");
          }
          return {
            elementName,
            attributeName,
            attributeType,
            defaultValue,
            index: i
          };
        }
      };
      skipWhitespace = (data, index) => {
        while (index < data.length && /\s/.test(data[index])) {
          index++;
        }
        return index;
      };
    }
  });

  // node_modules/strnum/strnum.js
  function toNumber(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string") return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
    else if (str === "0") return 0;
    else if (options.hex && hexRegex.test(trimmedStr)) {
      return parse_int(trimmedStr, 16);
    } else if (trimmedStr.includes("e") || trimmedStr.includes("E")) {
      return resolveEnotation(str, trimmedStr, options);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1] || "";
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const decimalAdjacentToLeadingZeros = sign ? (
          // 0., -00., 000.
          str[leadingZeros.length + 1] === "."
        ) : str[leadingZeros.length] === ".";
        if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {
          return str;
        } else {
          const num = Number(trimmedStr);
          const parsedStr = String(num);
          if (num === 0) return num;
          if (parsedStr.search(/[eE]/) !== -1) {
            if (options.eNotation) return num;
            else return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (parsedStr === "0") return num;
            else if (parsedStr === numTrimmedByZeros) return num;
            else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;
            else return str;
          }
          let n = leadingZeros ? numTrimmedByZeros : trimmedStr;
          if (leadingZeros) {
            return n === parsedStr || sign + n === parsedStr ? num : str;
          } else {
            return n === parsedStr || n === sign + parsedStr ? num : str;
          }
        }
      } else {
        return str;
      }
    }
  }
  function resolveEnotation(str, trimmedStr, options) {
    if (!options.eNotation) return str;
    const notation = trimmedStr.match(eNotationRegx);
    if (notation) {
      let sign = notation[1] || "";
      const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
      const leadingZeros = notation[2];
      const eAdjacentToLeadingZeros = sign ? (
        // 0E.
        str[leadingZeros.length + 1] === eChar
      ) : str[leadingZeros.length] === eChar;
      if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;
      else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {
        return Number(trimmedStr);
      } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {
        trimmedStr = (notation[1] || "") + notation[3];
        return Number(trimmedStr);
      } else return str;
    } else {
      return str;
    }
  }
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".") numStr = "0";
      else if (numStr[0] === ".") numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  function parse_int(numStr, base) {
    if (parseInt) return parseInt(numStr, base);
    else if (Number.parseInt) return Number.parseInt(numStr, base);
    else if (window && window.parseInt) return window.parseInt(numStr, base);
    else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
  }
  var hexRegex, numRegex, consider, eNotationRegx;
  var init_strnum = __esm({
    "node_modules/strnum/strnum.js"() {
      hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
      consider = {
        hex: true,
        // oct: false,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
        //skipLike: /regex/
      };
      eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    }
  });

  // node_modules/fast-xml-parser/src/ignoreAttributes.js
  function getIgnoreAttributesFn(ignoreAttributes) {
    if (typeof ignoreAttributes === "function") {
      return ignoreAttributes;
    }
    if (Array.isArray(ignoreAttributes)) {
      return (attrName) => {
        for (const pattern of ignoreAttributes) {
          if (typeof pattern === "string" && attrName === pattern) {
            return true;
          }
          if (pattern instanceof RegExp && pattern.test(attrName)) {
            return true;
          }
        }
      };
    }
    return () => false;
  }
  var init_ignoreAttributes = __esm({
    "node_modules/fast-xml-parser/src/ignoreAttributes.js"() {
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i = 0; i < entKeys.length; i++) {
      const ent = entKeys[i];
      const escaped = ent.replace(/[.\-+*:]/g, "\\.");
      this.lastEntities[ent] = {
        regex: new RegExp("&" + escaped + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val !== void 0) {
      if (this.options.trimValues && !dontTrim) {
        val = val.trim();
      }
      if (val.length > 0) {
        if (!escapeEntities) val = this.replaceEntitiesValue(val, tagName, jPath);
        const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === void 0) {
          return val;
        } else if (typeof newval !== typeof val || newval !== val) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val.trim();
          if (trimmedVal === val) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val;
          }
        }
      }
    }
  }
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
      const matches = getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i = 0; i < len; i++) {
        const attrName = this.resolveNameSpace(matches[i][1]);
        if (this.ignoreAttributesFn(attrName, jPath)) {
          continue;
        }
        let oldVal = matches[i][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__") aName = "#__proto__";
          if (oldVal !== void 0) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal, tagName, jPath);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === void 0) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(
                oldVal,
                this.options.parseAttributeValue,
                this.options.numberParseOptions
              );
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  function addChild(currentNode, childNode, jPath, startIndex) {
    if (!this.options.captureMetaData) startIndex = void 0;
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {
    } else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode, startIndex);
    } else {
      currentNode.addChild(childNode, startIndex);
    }
  }
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
      textData = this.parseTextData(
        textData,
        currentNode.tagname,
        jPath,
        false,
        currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
        isLeafNode
      );
      if (textData !== void 0 && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  function isItStopNode(stopNodesExact, stopNodesWildcard, jPath, currentTagName) {
    if (stopNodesWildcard && stopNodesWildcard.has(currentTagName)) return true;
    if (stopNodesExact && stopNodesExact.has(jPath)) return true;
    return false;
  }
  function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i; index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "	") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  function findClosingIndex(xmlData, str, i, errMsg) {
    const closingIndex = xmlData.indexOf(str, i);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
    if (!result) return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substring(0, separatorIndex);
      tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent,
      rawTagName
    };
  }
  function readStopNodeData(xmlData, tagName, i) {
    const startIndex = i;
    let openTagCount = 1;
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        if (xmlData[i + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i: closeIndex
              };
            }
          }
          i = closeIndex;
        } else if (xmlData[i + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
          i = closeIndex;
        } else if (xmlData.substr(i + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
          i = closeIndex;
        } else if (xmlData.substr(i + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i = tagData.closeIndex;
          }
        }
      }
    }
  }
  function parseValue(val, shouldParse, options) {
    if (shouldParse && typeof val === "string") {
      const newval = val.trim();
      if (newval === "true") return true;
      else if (newval === "false") return false;
      else return toNumber(val, options);
    } else {
      if (isExist(val)) {
        return val;
      } else {
        return "";
      }
    }
  }
  function fromCodePoint(str, base, prefix) {
    const codePoint = Number.parseInt(str, base);
    if (codePoint >= 0 && codePoint <= 1114111) {
      return String.fromCodePoint(codePoint);
    } else {
      return prefix + str + ";";
    }
  }
  var OrderedObjParser, attrsRegx, parseXml, replaceEntitiesValue;
  var init_OrderedObjParser = __esm({
    "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"() {
      "use strict";
      init_util2();
      init_xmlNode();
      init_DocTypeReader();
      init_strnum();
      init_ignoreAttributes();
      OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            // "lt" : { regex: /&(lt|#60);/g, val: "<" },
            // "gt" : { regex: /&(gt|#62);/g, val: ">" },
            // "amp" : { regex: /&(amp|#38);/g, val: "&" },
            // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
            // "apos" : { regex: /&(apos|#39);/g, val: "'" },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
            "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => fromCodePoint(str, 10, "&#") },
            "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => fromCodePoint(str, 16, "&#x") }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
          this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
          this.entityExpansionCount = 0;
          this.currentExpandedLength = 0;
          if (this.options.stopNodes && this.options.stopNodes.length > 0) {
            this.stopNodesExact = /* @__PURE__ */ new Set();
            this.stopNodesWildcard = /* @__PURE__ */ new Set();
            for (let i = 0; i < this.options.stopNodes.length; i++) {
              const stopNodeExp = this.options.stopNodes[i];
              if (typeof stopNodeExp !== "string") continue;
              if (stopNodeExp.startsWith("*.")) {
                this.stopNodesWildcard.add(stopNodeExp.substring(2));
              } else {
                this.stopNodesExact.add(stopNodeExp);
              }
            }
          }
        }
      };
      attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new XmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        this.entityExpansionCount = 0;
        this.currentExpandedLength = 0;
        const docTypeReader = new DocTypeReader(this.options.processEntities);
        for (let i = 0; i < xmlData.length; i++) {
          const ch = xmlData[i];
          if (ch === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              let tagData = readTagExp(xmlData, i, false, "?>");
              if (!tagData) throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new XmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath, i);
              }
              i = tagData.closeIndex + 1;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i = endIndex;
            } else if (xmlData.substr(i + 1, 2) === "!D") {
              const result = docTypeReader.readDocType(xmlData, i);
              this.docTypeEntities = result.entities;
              i = result.i;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
              if (val == void 0) val = "";
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                currentNode.add(this.options.textNodeName, val);
              }
              i = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
              let tagName = result.tagName;
              const rawTagName = result.rawTagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                const newTagName = this.options.transformTagName(tagName);
                if (tagExp === tagName) {
                  tagExp = newTagName;
                }
                tagName = newTagName;
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              const startIndex = i;
              if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  i = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                  if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
                  i = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new XmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath, startIndex);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    const newTagName = this.options.transformTagName(tagName);
                    if (tagExp === tagName) {
                      tagExp = newTagName;
                    }
                    tagName = newTagName;
                  }
                  const childNode = new XmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath, startIndex);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new XmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath, startIndex);
                  currentNode = childNode;
                }
                textData = "";
                i = closeIndex;
              }
            }
          } else {
            textData += xmlData[i];
          }
        }
        return xmlObj.child;
      };
      replaceEntitiesValue = function(val, tagName, jPath) {
        if (val.indexOf("&") === -1) {
          return val;
        }
        const entityConfig = this.options.processEntities;
        if (!entityConfig.enabled) {
          return val;
        }
        if (entityConfig.allowedTags) {
          if (!entityConfig.allowedTags.includes(tagName)) {
            return val;
          }
        }
        if (entityConfig.tagFilter) {
          if (!entityConfig.tagFilter(tagName, jPath)) {
            return val;
          }
        }
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          const matches = val.match(entity.regx);
          if (matches) {
            this.entityExpansionCount += matches.length;
            if (entityConfig.maxTotalExpansions && this.entityExpansionCount > entityConfig.maxTotalExpansions) {
              throw new Error(
                `Entity expansion limit exceeded: ${this.entityExpansionCount} > ${entityConfig.maxTotalExpansions}`
              );
            }
            const lengthBefore = val.length;
            val = val.replace(entity.regx, entity.val);
            if (entityConfig.maxExpandedLength) {
              this.currentExpandedLength += val.length - lengthBefore;
              if (this.currentExpandedLength > entityConfig.maxExpandedLength) {
                throw new Error(
                  `Total expanded content size exceeded: ${this.currentExpandedLength} > ${entityConfig.maxExpandedLength}`
                );
              }
            }
          }
        }
        if (val.indexOf("&") === -1) return val;
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (val.indexOf("&") === -1) return val;
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
        return val;
      };
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/node2json.js
  function prettify(node, options) {
    return compress(node, options);
  }
  function compress(arr, options, jPath) {
    let text;
    const compressedObj = {};
    for (let i = 0; i < arr.length; i++) {
      const tagObj = arr[i];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === void 0) newJpath = property;
      else newJpath = jPath + "." + property;
      if (property === options.textNodeName) {
        if (text === void 0) text = tagObj[property];
        else text += "" + tagObj[property];
      } else if (property === void 0) {
        continue;
      } else if (tagObj[property]) {
        let val = compress(tagObj[property], options, newJpath);
        const isLeaf = isLeafTag(val, options);
        if (tagObj[METADATA_SYMBOL2] !== void 0) {
          val[METADATA_SYMBOL2] = tagObj[METADATA_SYMBOL2];
        }
        if (tagObj[":@"]) {
          assignAttributes(val, tagObj[":@"], newJpath, options);
        } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
          val = val[options.textNodeName];
        } else if (Object.keys(val).length === 0) {
          if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
          else val = "";
        }
        if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val);
        } else {
          if (options.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val];
          } else {
            compressedObj[property] = val;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0) compressedObj[options.textNodeName] = text;
    } else if (text !== void 0) compressedObj[options.textNodeName] = text;
    return compressedObj;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== ":@") return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const atrrName = keys[i];
        if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  var METADATA_SYMBOL2;
  var init_node2json = __esm({
    "node_modules/fast-xml-parser/src/xmlparser/node2json.js"() {
      "use strict";
      init_xmlNode();
      METADATA_SYMBOL2 = XmlNode.getMetaDataSymbol();
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var XMLParser;
  var init_XMLParser = __esm({
    "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"() {
      init_OptionsBuilder();
      init_OrderedObjParser();
      init_node2json();
      init_validator();
      init_xmlNode();
      XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        /**
         * Parse XML dats to JS object 
         * @param {string|Uint8Array} xmlData 
         * @param {boolean|Object} validationOption 
         */
        parse(xmlData, validationOption) {
          if (typeof xmlData !== "string" && xmlData.toString) {
            xmlData = xmlData.toString();
          } else if (typeof xmlData !== "string") {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true) validationOption = {};
            const result = validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
          else return prettify(orderedResult, this.options);
        }
        /**
         * Add Entity which is not by default supported by this library
         * @param {string} key 
         * @param {string} value 
         */
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
        /**
         * Returns a Symbol that can be used to access the metadata
         * property on a node.
         * 
         * If Symbol is not available in the environment, an ordinary property is used
         * and the name of the property is here returned.
         * 
         * The XMLMetaData property is only present when `captureMetaData`
         * is true in the options.
         */
        static getMetaDataSymbol() {
          return XmlNode.getMetaDataSymbol();
        }
      };
    }
  });

  // node_modules/fast-xml-parser/src/fxp.js
  var init_fxp = __esm({
    "node_modules/fast-xml-parser/src/fxp.js"() {
      "use strict";
      init_XMLParser();
    }
  });

  // src/features/pinboard/pinboard-service.js
  var pinboard_service_exports = {};
  __export(pinboard_service_exports, {
    PinboardService: () => PinboardService
  });
  var PinboardService;
  var init_pinboard_service = __esm({
    "src/features/pinboard/pinboard-service.js"() {
      "use strict";
      init_config_manager();
      init_tag_service();
      init_fxp();
      init_utils();
      debugLog2("[SAFARI-EXT-SHIM-001] pinboard-service.js: module loaded");
      PinboardService = class {
        constructor(tagService = null) {
          this.configManager = new ConfigManager();
          this.tagService = tagService || new TagService(this);
          this.apiBase = "https://api.pinboard.in/v1/";
          this.retryDelays = [1e3, 2e3, 5e3];
          this.xmlParser = new XMLParser({
            ignoreAttributes: false,
            attributeNamePrefix: "@_",
            parseAttributeValue: true
          });
        }
        /**
         * Get bookmark data for a specific URL
         * @param {string} url - URL to lookup
         * @param {string} title - Page title (fallback for description)
         * @returns {Promise<Object>} Bookmark data
         *
         * PIN-002: Single bookmark retrieval by URL
         * SPECIFICATION: Use posts/get endpoint to fetch bookmark for specific URL
         * IMPLEMENTATION DECISION: Provide fallback data on failure for UI stability
         */
        async getBookmarkForUrl(url2, title = "") {
          try {
            const hasAuth = await this.configManager.hasAuthToken();
            if (!hasAuth) {
              debugLog2("[PINBOARD-SERVICE] No auth token configured, returning empty bookmark without API call");
              return this.createEmptyBookmark(url2, title);
            }
            const cleanUrl = this.cleanUrl(url2);
            const endpoint = `posts/get?url=${encodeURIComponent(cleanUrl)}`;
            debugLog2("Making Pinboard API request:", {
              endpoint,
              cleanUrl,
              originalUrl: url2
            });
            const response = await this.makeApiRequest(endpoint);
            debugLog2("\u{1F4E5} Pinboard API response received:", response);
            const parsed = this.parseBookmarkResponse(response, cleanUrl, title);
            debugLog2("\u{1F4CB} Parsed bookmark result:", parsed);
            return parsed;
          } catch (error48) {
            debugError("\u274C Failed to get bookmark for URL:", error48);
            debugError("\u274C Error details:", error48.message);
            debugError("\u274C Full error:", error48);
            const emptyBookmark = this.createEmptyBookmark(url2, title);
            debugLog2("\u{1F4DD} Returning empty bookmark due to error:", emptyBookmark);
            return emptyBookmark;
          }
        }
        /**
         * Get recent bookmarks from Pinboard
         * @param {number} count - Number of recent bookmarks to fetch
         * @returns {Promise<Object[]>} Array of recent bookmarks
         *
         * PIN-002: Recent bookmarks retrieval for dashboard display
         * SPECIFICATION: Use posts/recent endpoint with count parameter
         * IMPLEMENTATION DECISION: Return empty array on failure to prevent UI errors
         */
        async getRecentBookmarks(count = 15) {
          try {
            const hasAuth = await this.configManager.hasAuthToken();
            if (!hasAuth) {
              debugLog2("[PINBOARD-SERVICE] No auth token configured, returning empty recent list without API call");
              return [];
            }
            debugLog2("[PINBOARD-SERVICE] Getting recent bookmarks, count:", count);
            const endpoint = `posts/recent?count=${count}`;
            const response = await this.makeApiRequest(endpoint);
            debugLog2("[PINBOARD-SERVICE] Raw API response received");
            const result = this.parseRecentBookmarksResponse(response);
            debugLog2("[PINBOARD-SERVICE] Parsed recent bookmarks:", result.map((b) => ({
              url: b.url,
              description: b.description,
              tags: b.tags
            })));
            return result;
          } catch (error48) {
            debugError("[PINBOARD-SERVICE] Failed to get recent bookmarks:", error48);
            return [];
          }
        }
        /**
         * Save a bookmark to Pinboard
         * @param {Object} bookmarkData - Bookmark data to save
         * @returns {Promise<Object>} Save result
         *
         * PIN-003: Bookmark creation/update operation
         * SPECIFICATION: Use posts/add endpoint to save bookmark with all metadata
         * IMPLEMENTATION DECISION: Re-throw errors to allow caller error handling
         * [IMMUTABLE-REQ-TAG-001] - Enhanced with tag tracking
         */
        async saveBookmark(bookmarkData) {
          try {
            const hasAuth = await this.configManager.hasAuthToken();
            if (!hasAuth) {
              debugLog2("[PINBOARD-SERVICE] No auth token configured, skipping save without API call");
              return { success: false, code: "no_auth", message: "No authentication token configured" };
            }
            const params = this.buildSaveParams(bookmarkData);
            const endpoint = `posts/add?${params}`;
            const response = await this.makeApiRequest(endpoint, "GET");
            await this.trackBookmarkTags(bookmarkData);
            return this.parseApiResponse(response);
          } catch (error48) {
            debugError("Failed to save bookmark:", error48);
            throw error48;
          }
        }
        /**
         * Save a tag to an existing bookmark
         * @param {Object} tagData - Tag data to save
         * @returns {Promise<Object>} Save result
         *
         * PIN-003: Tag addition to existing bookmark
         * SPECIFICATION: Retrieve current bookmark, add tag, then save updated bookmark
         * IMPLEMENTATION DECISION: Merge tags to preserve existing tags while adding new ones
         * [IMMUTABLE-REQ-TAG-001] - Enhanced with tag tracking
         */
        async saveTag(tagData) {
          try {
            const currentBookmark = await this.getBookmarkForUrl(tagData.url);
            const existingTags = currentBookmark.tags || [];
            const newTags = [...existingTags];
            if (tagData.value && !existingTags.includes(tagData.value)) {
              newTags.push(tagData.value);
            }
            const updatedBookmark = {
              ...currentBookmark,
              ...tagData,
              tags: newTags.join(" ")
            };
            if (tagData.value) {
              await this.tagService.handleTagAddition(tagData.value, updatedBookmark);
            }
            return this.saveBookmark(updatedBookmark);
          } catch (error48) {
            debugError("Failed to save tag:", error48);
            throw error48;
          }
        }
        /**
         * Delete a bookmark from Pinboard
         * @param {string} url - URL of bookmark to delete
         * @returns {Promise<Object>} Delete result
         *
         * PIN-003: Bookmark deletion operation
         * SPECIFICATION: Use posts/delete endpoint to remove bookmark by URL
         * IMPLEMENTATION DECISION: Clean URL before deletion for consistent matching
         */
        async deleteBookmark(url2) {
          try {
            const hasAuth = await this.configManager.hasAuthToken();
            if (!hasAuth) {
              debugLog2("[PINBOARD-SERVICE] No auth token configured, skipping delete without API call");
              return { success: false, code: "no_auth", message: "No authentication token configured" };
            }
            const cleanUrl = this.cleanUrl(url2);
            const endpoint = `posts/delete?url=${encodeURIComponent(cleanUrl)}`;
            const response = await this.makeApiRequest(endpoint);
            return this.parseApiResponse(response);
          } catch (error48) {
            debugError("Failed to delete bookmark:", error48);
            throw error48;
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Track tags from bookmark data
         * @param {Object} bookmarkData - Bookmark data containing tags
         * @returns {Promise<void>}
         */
        async trackBookmarkTags(bookmarkData) {
          try {
            const tags = this.extractTagsFromBookmarkData(bookmarkData);
            const sanitizedTags = Array.from(new Set(tags.map((tag) => this.tagService.sanitizeTag(tag)).filter(Boolean)));
            if (sanitizedTags.length > 0) {
              for (const sanitizedTag of sanitizedTags) {
                await this.tagService.handleTagAddition(sanitizedTag, bookmarkData);
              }
              debugLog2("[IMMUTABLE-REQ-TAG-001] Tracked tags for bookmark:", sanitizedTags);
            }
          } catch (error48) {
            debugError("[IMMUTABLE-REQ-TAG-001] Failed to track bookmark tags:", error48);
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Enhanced error handling for tag operations
         * @param {Error} error - The error that occurred
         * @param {string} operation - The operation that failed
         * @param {Object} context - Additional context data
         * @returns {Promise<void>}
         */
        async handleTagError(error48, operation, context = {}) {
          debugError(`[IMMUTABLE-REQ-TAG-001] Tag operation failed: ${operation}`, {
            error: error48.message,
            stack: error48.stack,
            context
          });
          if (error48.name === "QuotaExceededError") {
            try {
              await this.tagService.cleanupOldTags();
              debugLog2("[IMMUTABLE-REQ-TAG-001] Attempted cleanup after quota exceeded");
            } catch (cleanupError) {
              debugError("[IMMUTABLE-REQ-TAG-001] Cleanup also failed:", cleanupError);
            }
          }
          try {
            await this.notifyUserOfTagError(operation, error48.message);
          } catch (notificationError) {
            debugError("[IMMUTABLE-REQ-TAG-001] Failed to notify user:", notificationError);
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Notify user of tag operation errors
         * @param {string} operation - The operation that failed
         * @param {string} errorMessage - The error message
         * @returns {Promise<void>}
         */
        async notifyUserOfTagError(operation, errorMessage) {
          const userMessage = `Tag ${operation} failed, but bookmark was saved. Error: ${errorMessage}`;
          debugWarn("[IMMUTABLE-REQ-TAG-001] User notification:", userMessage);
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Extract tags from bookmark data
         * @param {Object} bookmarkData - Bookmark data
         * @returns {string[]} Array of tags
         */
        extractTagsFromBookmarkData(bookmarkData) {
          const tags = [];
          if (bookmarkData.tags) {
            if (typeof bookmarkData.tags === "string") {
              const tagArray = bookmarkData.tags.split(/\s+/).filter((tag) => tag.trim());
              tags.push(...tagArray);
            } else if (Array.isArray(bookmarkData.tags)) {
              tags.push(...bookmarkData.tags.filter((tag) => tag && tag.trim()));
            }
          }
          return tags;
        }
        /**
         * Remove a specific tag from a bookmark
         * @param {Object} tagData - Tag removal data
         * @returns {Promise<Object>} Update result
         *
         * PIN-003: Tag removal from existing bookmark
         * SPECIFICATION: Retrieve bookmark, remove specified tag, save updated bookmark
         * IMPLEMENTATION DECISION: Filter out specific tag while preserving other tags
         * [action:delete] [sync:site-record] [arch:atomic-sync]
         */
        async deleteTag(tagData) {
          try {
            const currentBookmark = await this.getBookmarkForUrl(tagData.url);
            const existingTags = currentBookmark.tags || [];
            const filteredTags = existingTags.filter((tag) => tag !== tagData.value);
            const updatedBookmark = {
              ...currentBookmark,
              ...tagData,
              tags: filteredTags.join(" ")
            };
            return this.saveBookmark(updatedBookmark);
          } catch (error48) {
            debugError("Failed to delete tag:", error48);
            throw error48;
          }
        }
        /**
         * Test authentication with Pinboard API
         * @returns {Promise<boolean>} True if authentication is valid
         *
         * PIN-001: Authentication validation using API endpoint
         * SPECIFICATION: Use user/api_token endpoint to verify authentication
         * IMPLEMENTATION DECISION: Simple boolean return for easy authentication checking
         */
        async testConnection() {
          try {
            const hasAuth = await this.configManager.hasAuthToken();
            if (!hasAuth) {
              debugLog2("[PINBOARD-SERVICE] No auth token configured, testConnection returns false without API call");
              return false;
            }
            const endpoint = "user/api_token";
            const response = await this.makeApiRequest(endpoint);
            return true;
          } catch (error48) {
            debugError("Connection test failed:", error48);
            return false;
          }
        }
        /**
         * Make API request with authentication and retry logic
         * @param {string} endpoint - API endpoint
         * @param {string} method - HTTP method
         * @returns {Promise<Document>} Parsed XML response
         *
         * PIN-001: Authenticated API request with configuration integration
         * SPECIFICATION: All API requests must include authentication token
         * IMPLEMENTATION DECISION: Centralized authentication and retry logic
         */
        async makeApiRequest(endpoint, method = "GET") {
          const hasAuth = await this.configManager.hasAuthToken();
          debugLog2("\u{1F510} Auth token check:", hasAuth);
          if (!hasAuth) {
            throw new Error("No authentication token configured");
          }
          const authParam = await this.configManager.getAuthTokenParam();
          const url2 = `${this.apiBase}${endpoint}&${authParam}`;
          debugLog2("\u{1F310} Making API request to:", url2.replace(/auth_token=[^&]+/, "auth_token=***HIDDEN***"));
          return this.makeRequestWithRetry(url2, method);
        }
        /**
         * Make HTTP request with retry logic for rate limiting
         * @param {string} url - Request URL
         * @param {string} method - HTTP method
         * @param {number} retryCount - Current retry attempt
         * @returns {Promise<Document>} Response
         *
         * PIN-004: Network resilience with exponential backoff retry
         * SPECIFICATION: Handle rate limiting and network failures gracefully
         * IMPLEMENTATION DECISION: Progressive retry delays with configured maximum attempts
         */
        async makeRequestWithRetry(url2, method = "GET", retryCount = 0) {
          const config2 = await this.configManager.getConfig();
          try {
            debugLog2(`\u{1F680} Attempting HTTP ${method} request (attempt ${retryCount + 1})`);
            const response = await fetch(url2, { method });
            debugLog2(`\u{1F4E1} HTTP response status: ${response.status} ${response.statusText}`);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const xmlText = await response.text();
            debugLog2("\u{1F4C4} Raw XML response:", xmlText.substring(0, 500) + (xmlText.length > 500 ? "..." : ""));
            const parsed = this.parseXmlResponse(xmlText);
            debugLog2("\u2705 Successfully parsed XML response");
            return parsed;
          } catch (error48) {
            debugError("\u{1F4A5} HTTP request failed:", error48.message);
            const isRetryable = this.isRetryableError(error48);
            const maxRetries = config2.pinRetryCountMax || 2;
            if (isRetryable && retryCount < maxRetries) {
              const delay = this.retryDelays[retryCount] || config2.pinRetryDelay || 1e3;
              debugWarn(`\u{1F504} API request failed, retrying in ${delay}ms (attempt ${retryCount + 1}/${maxRetries})`);
              await this.sleep(delay);
              return this.makeRequestWithRetry(url2, method, retryCount + 1);
            }
            debugError("\u274C Max retries exceeded or non-retryable error. Giving up.");
            throw error48;
          }
        }
        /**
         * Parse XML response from Pinboard API
         * @param {string} xmlText - XML response text
         * @returns {Object} Parsed XML object
         *
         * PIN-001: XML response parsing with error handling
         * SPECIFICATION: All Pinboard API responses are in XML format
         * IMPLEMENTATION DECISION: Use configured XML parser with error handling
         */
        parseXmlResponse(xmlText) {
          try {
            return this.xmlParser.parse(xmlText);
          } catch (error48) {
            debugError("Failed to parse XML response:", error48);
            debugError("XML content:", xmlText);
            throw new Error("Invalid XML response from Pinboard API");
          }
        }
        /**
         * Parse bookmark response from posts/get endpoint
         * @param {Object} xmlObj - Parsed XML object
         * @param {string} url - Original URL
         * @param {string} title - Fallback title
         * @returns {Object} Bookmark object
         *
         * PIN-002: Bookmark data parsing from Pinboard XML format
         * SPECIFICATION: Handle Pinboard's XML structure for bookmark data
         * IMPLEMENTATION DECISION: Normalize XML attributes to standard bookmark object
         */
        parseBookmarkResponse(xmlObj, url2, title) {
          try {
            debugLog2("Parsing XML object structure:", JSON.stringify(xmlObj, null, 2));
            const posts = xmlObj?.posts?.post;
            debugLog2("\u{1F4CB} Posts extracted:", posts);
            debugLog2("\u{1F4CB} Posts type:", typeof posts);
            debugLog2("\u{1F4CB} Posts is array:", Array.isArray(posts));
            debugLog2("\u{1F4CB} Posts length:", posts?.length);
            if (posts && posts.length > 0) {
              const post = Array.isArray(posts) ? posts[0] : posts;
              debugLog2("\u{1F4C4} Processing post:", post);
              const pinTime = post["@_time"] || "";
              const result = {
                url: post["@_href"] || url2,
                description: post["@_description"] || title || "",
                extended: post["@_extended"] || "",
                tags: post["@_tag"] ? post["@_tag"].split(" ") : [],
                time: pinTime,
                updated_at: pinTime,
                shared: post["@_shared"] || "yes",
                toread: post["@_toread"] || "no",
                hash: post["@_hash"] || ""
              };
              debugLog2("\u2705 Successfully parsed bookmark:", result);
              return result;
            }
            if (posts && !Array.isArray(posts)) {
              debugLog2("\u{1F4C4} Single post object found, processing directly:", posts);
              const pinTime = posts["@_time"] || "";
              const result = {
                url: posts["@_href"] || url2,
                description: posts["@_description"] || title || "",
                extended: posts["@_extended"] || "",
                tags: posts["@_tag"] ? posts["@_tag"].split(" ") : [],
                time: pinTime,
                updated_at: pinTime,
                shared: posts["@_shared"] || "yes",
                toread: posts["@_toread"] || "no",
                hash: posts["@_hash"] || ""
              };
              debugLog2("\u2705 Successfully parsed single bookmark:", result);
              return result;
            }
            debugLog2("\u26A0\uFE0F No posts found in XML structure");
            return this.createEmptyBookmark(url2, title);
          } catch (error48) {
            debugError("\u274C Failed to parse bookmark response:", error48);
            return this.createEmptyBookmark(url2, title);
          }
        }
        /**
         * Parse recent bookmarks response from posts/recent endpoint
         * @param {Object} xmlObj - Parsed XML object
         * @returns {Array} Array of bookmark objects
         *
         * PIN-002: Recent bookmarks parsing from Pinboard XML format
         * SPECIFICATION: Handle array of bookmarks from posts/recent endpoint
         * IMPLEMENTATION DECISION: Normalize each bookmark and handle empty responses
         */
        parseRecentBookmarksResponse(xmlObj) {
          try {
            debugLog2("[PINBOARD-SERVICE] Parsing recent bookmarks XML object");
            debugLog2("[PINBOARD-SERVICE] XML object structure:", JSON.stringify(xmlObj, null, 2));
            const posts = xmlObj?.posts?.post;
            if (!posts) {
              debugLog2("[PINBOARD-SERVICE] No posts found in XML response");
              return [];
            }
            const postsArray = Array.isArray(posts) ? posts : [posts];
            debugLog2("[PINBOARD-SERVICE] Processing posts array, count:", postsArray.length);
            const result = postsArray.map((post, index) => {
              debugLog2(`[PINBOARD-SERVICE] Processing post ${index + 1}:`, {
                href: post["@_href"],
                description: post["@_description"],
                tag: post["@_tag"],
                time: post["@_time"]
              });
              const tags = post["@_tag"] ? post["@_tag"].split(" ") : [];
              debugLog2(`[PINBOARD-SERVICE] Post ${index + 1} tags after split:`, tags);
              const pinTime = post["@_time"] || "";
              return {
                url: post["@_href"] || "",
                description: post["@_description"] || "",
                extended: post["@_extended"] || "",
                tags,
                time: pinTime,
                updated_at: pinTime,
                shared: post["@_shared"] || "yes",
                toread: post["@_toread"] || "no",
                hash: post["@_hash"] || ""
              };
            });
            debugLog2("[PINBOARD-SERVICE] Final parsed bookmarks:", result.map((b) => ({
              url: b.url,
              description: b.description,
              tags: b.tags
            })));
            return result;
          } catch (error48) {
            debugError("[PINBOARD-SERVICE] Failed to parse recent bookmarks response:", error48);
            return [];
          }
        }
        /**
         * Parse general API response (for add/delete operations)
         * @param {Object} xmlObj - Parsed XML object
         * @returns {Object} Result object
         *
         * PIN-003: API operation response parsing
         * SPECIFICATION: Handle success/error responses from add/delete operations
         * IMPLEMENTATION DECISION: Extract result code and message for operation feedback
         */
        parseApiResponse(xmlObj) {
          try {
            const result = xmlObj?.result;
            return {
              success: result?.["@_code"] === "done",
              code: result?.["@_code"] || "unknown",
              message: result?.["#text"] || "Operation completed"
            };
          } catch (error48) {
            debugError("Failed to parse API response:", error48);
            return {
              success: false,
              code: "parse_error",
              message: "Failed to parse API response"
            };
          }
        }
        /**
         * Create empty bookmark object with defaults
         * @param {string} url - URL for bookmark
         * @param {string} title - Title for description
         * @returns {Object} Empty bookmark object
         *
         * PIN-002: Default bookmark structure creation
         * SPECIFICATION: Provide consistent bookmark object structure
         * IMPLEMENTATION DECISION: Include all standard Pinboard bookmark fields with defaults
         */
        createEmptyBookmark(url2, title) {
          return {
            url: url2 || "",
            description: title || "",
            extended: "",
            tags: [],
            time: "",
            updated_at: "",
            shared: "yes",
            toread: "no",
            hash: ""
          };
        }
        /**
         * [IMPL-PINBOARD_POSTS_ADD_ENCODING] [IMPL-PINBOARD_API] [IMPL-TAG_SYSTEM] Build posts/add query string with encodeURIComponent for url, description, extended, tags, shared, toread.
         * @param {Object} bookmarkData - Bookmark data
         * @returns {string} URL parameter string (key=encodedValue&...)
         */
        buildSaveParams(bookmarkData) {
          const pairs = [];
          if (bookmarkData.url) {
            pairs.push(`url=${encodeURIComponent(bookmarkData.url)}`);
          }
          if (bookmarkData.description) {
            pairs.push(`description=${encodeURIComponent(bookmarkData.description)}`);
          }
          if (bookmarkData.extended) {
            pairs.push(`extended=${encodeURIComponent(bookmarkData.extended)}`);
          }
          if (bookmarkData.tags) {
            const tagsString = Array.isArray(bookmarkData.tags) ? bookmarkData.tags.join(" ") : bookmarkData.tags;
            pairs.push(`tags=${encodeURIComponent(tagsString)}`);
          }
          if (bookmarkData.shared !== void 0) {
            pairs.push(`shared=${encodeURIComponent(String(bookmarkData.shared))}`);
          }
          if (bookmarkData.toread !== void 0) {
            pairs.push(`toread=${encodeURIComponent(String(bookmarkData.toread))}`);
          }
          return pairs.join("&");
        }
        /**
         * Clean URL for consistent API usage
         * @param {string} url - URL to clean
         * @returns {string} Cleaned URL
         *
         * PIN-001: URL normalization for consistent API requests
         * SPECIFICATION: Ensure URLs are properly formatted for Pinboard API
         * IMPLEMENTATION DECISION: Basic trimming and validation, preserve URL structure
         */
        cleanUrl(url2) {
          if (!url2) return "";
          return url2.trim().replace(/\/+$/, "");
        }
        /**
         * Check if error is retryable
         * @param {Error} error - Error to check
         * @returns {boolean} Whether error is retryable
         *
         * PIN-004: Error classification for retry logic
         * SPECIFICATION: Only retry network and rate limit errors, not authentication/validation errors
         * IMPLEMENTATION DECISION: Conservative retry logic to avoid infinite loops
         */
        isRetryableError(error48) {
          if (error48.message.includes("fetch")) return true;
          if (error48.message.includes("timeout")) return true;
          if (error48.message.includes("429")) return true;
          if (error48.message.includes("500")) return true;
          if (error48.message.includes("502")) return true;
          if (error48.message.includes("503")) return true;
          return false;
        }
        /**
         * Sleep utility for retry delays
         * @param {number} ms - Milliseconds to sleep
         * @returns {Promise} Promise that resolves after delay
         *
         * PIN-004: Async delay utility for retry logic
         * IMPLEMENTATION DECISION: Promise-based sleep for async/await compatibility
         */
        sleep(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }
      };
    }
  });

  // src/features/tagging/tag-service.js
  var TagService;
  var init_tag_service = __esm({
    "src/features/tagging/tag-service.js"() {
      "use strict";
      init_config_manager();
      init_utils();
      debugLog2("[SAFARI-EXT-SHIM-001] tag-service.js: module loaded");
      TagService = class {
        constructor(pinboardService = null) {
          if (pinboardService) {
            this.pinboardService = pinboardService;
          } else {
            this.pinboardService = null;
            this._pinboardServicePromise = null;
          }
          this.configManager = new ConfigManager();
          this.cacheKey = "hoverboard_recent_tags_cache";
          this.cacheTimeout = 5 * 60 * 1e3;
          this.tagFrequencyKey = "hoverboard_tag_frequency";
          this.sharedMemoryKey = "hoverboard_recent_tags_shared";
        }
        /**
         * Get PinboardService instance (lazy loading to avoid circular dependency)
         * @returns {Promise<PinboardService>} PinboardService instance
         */
        async getPinboardService() {
          if (this.pinboardService) {
            return this.pinboardService;
          }
          if (!this._pinboardServicePromise) {
            this._pinboardServicePromise = Promise.resolve().then(() => (init_pinboard_service(), pinboard_service_exports)).then((module) => {
              this.pinboardService = new module.PinboardService(this);
              return this.pinboardService;
            });
          }
          return this._pinboardServicePromise;
        }
        /**
         * [IMMUTABLE-REQ-TAG-003] - Get user-driven recent tags from shared memory
         * @returns {Promise<Object[]>} Array of recent tag objects sorted by lastUsed timestamp
         */
        async getUserRecentTags() {
          try {
            debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Getting user recent tags from shared memory");
            const directMemory = this.getDirectSharedMemory();
            if (directMemory) {
              const recentTags2 = directMemory.getRecentTags();
              debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Retrieved recent tags from direct shared memory:", recentTags2.length);
              const sortedTags2 = recentTags2.sort((a, b) => {
                const dateA = new Date(a.lastUsed);
                const dateB = new Date(b.lastUsed);
                return dateB - dateA;
              });
              return sortedTags2;
            }
            const backgroundPage = await this.getBackgroundPage();
            if (!backgroundPage || !backgroundPage.recentTagsMemory) {
              debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] No shared memory found, returning empty array");
              return [];
            }
            const recentTags = backgroundPage.recentTagsMemory.getRecentTags();
            debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Retrieved recent tags from shared memory:", recentTags.length);
            const sortedTags = recentTags.sort((a, b) => {
              const dateA = new Date(a.lastUsed);
              const dateB = new Date(b.lastUsed);
              return dateB - dateA;
            });
            return sortedTags;
          } catch (error48) {
            debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Failed to get user recent tags:", error48);
            return [];
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-003] - Get direct access to shared memory (service worker context)
         * @returns {Object|null} Shared memory object or null
         */
        getDirectSharedMemory() {
          try {
            if (typeof self !== "undefined" && self.recentTagsMemory) {
              return self.recentTagsMemory;
            }
            if (typeof globalThis !== "undefined" && globalThis.recentTagsMemory) {
              return globalThis.recentTagsMemory;
            }
            return null;
          } catch (error48) {
            debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Error getting direct shared memory:", error48);
            return null;
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-003] - Add tag to user recent list (current site only)
         * @param {string} tagName - Tag name to add
         * @param {string} currentSiteUrl - Current site URL for scope validation
         * @returns {Promise<boolean>} Success status
         */
        async addTagToUserRecentList(tagName, currentSiteUrl) {
          try {
            debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Adding tag to user recent list:", { tagName, currentSiteUrl });
            const sanitizedTag = this.sanitizeTag(tagName);
            if (!sanitizedTag) {
              debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Invalid tag name:", tagName);
              return false;
            }
            if (!currentSiteUrl || typeof currentSiteUrl !== "string" || !/^https?:\/\//.test(currentSiteUrl)) {
              debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Invalid or missing currentSiteUrl:", currentSiteUrl);
              return false;
            }
            const directMemory = this.getDirectSharedMemory();
            if (directMemory) {
              const success3 = directMemory.addTag(sanitizedTag, currentSiteUrl);
              if (success3) {
                debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Successfully added tag to user recent list via direct access");
                await this.recordTagUsage(sanitizedTag);
              } else {
                debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Failed to add tag to user recent list via direct access");
              }
              return !!success3;
            }
            const backgroundPage = await this.getBackgroundPage();
            if (!backgroundPage || !backgroundPage.recentTagsMemory) {
              debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Shared memory not available");
              return false;
            }
            const success2 = backgroundPage.recentTagsMemory.addTag(sanitizedTag, currentSiteUrl);
            if (success2) {
              debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Successfully added tag to user recent list");
              await this.recordTagUsage(sanitizedTag);
            } else {
              debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Failed to add tag to user recent list");
            }
            return !!success2;
          } catch (error48) {
            debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Error adding tag to user recent list:", error48);
            return false;
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-003] - Get recent tags excluding current site
         * @param {string[]} currentTags - Tags currently assigned to the current site
         * @returns {Promise<Object[]>} Filtered array of recent tags
         */
        async getUserRecentTagsExcludingCurrent(currentTags = []) {
          try {
            debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Getting recent tags excluding current:", currentTags);
            const allRecentTags = await this.getUserRecentTags();
            const normalizedCurrentTags = currentTags.map((tag) => tag.toLowerCase());
            const filteredTags = allRecentTags.filter(
              (tag) => !normalizedCurrentTags.includes(tag.name.toLowerCase())
            );
            debugLog2("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Filtered recent tags:", filteredTags.length);
            return filteredTags;
          } catch (error48) {
            debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Error getting filtered recent tags:", error48);
            return [];
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-003] - Get background page for shared memory access
         * @returns {Promise<Object|null>} Background page object or null
         */
        async getBackgroundPage() {
          try {
            if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.getBackgroundPage) {
              const backgroundPage = await chrome.runtime.getBackgroundPage();
              return backgroundPage;
            } else {
              if (typeof self !== "undefined" && self.recentTagsMemory) {
                return { recentTagsMemory: self.recentTagsMemory };
              }
              if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.sendMessage) {
                const response = await chrome.runtime.sendMessage({
                  type: "getSharedMemoryStatus"
                });
                if (response && response.recentTagsMemory) {
                  return { recentTagsMemory: response.recentTagsMemory };
                }
              }
              return null;
            }
          } catch (error48) {
            debugError("TAG-SERVICE", "[IMMUTABLE-REQ-TAG-003] Failed to get background page:", error48);
            return null;
          }
        }
        /**
         * [IMPL-TAG_SYSTEM] [ARCH-TAG_SYSTEM] [REQ-RECENT_TAGS_SYSTEM] Get recent tags (cache + shared memory).
         * @param {Object} options - Tag retrieval options
         * @returns {Promise<Object[]>} Array of recent tag objects
         */
        // [TEST-FIX-IMPL-2025-07-14] - Standardize getRecentTags return format
        async getRecentTags(options = {}) {
          try {
            debugLog2("TAG-SERVICE", "[TEST-FIX-STORAGE-001] Getting recent tags with enhanced storage integration");
            const cached2 = await this.getCachedTags();
            if (cached2 && this.isCacheValid(cached2.timestamp)) {
              debugLog2("TAG-SERVICE", "[TEST-FIX-STORAGE-001] Returning cached tags:", cached2.tags.length);
              return this.processTagsForDisplay(cached2.tags, options);
            }
            const userRecentTags = await this.getUserRecentTags();
            if (userRecentTags.length > 0) {
              debugLog2("TAG-SERVICE", "[TEST-FIX-STORAGE-001] Returning user recent tags:", userRecentTags.length);
              return this.processTagsForDisplay(userRecentTags, options);
            }
            debugLog2("TAG-SERVICE", "[TEST-FIX-STORAGE-001] No tags found, returning empty array");
            return [];
          } catch (error48) {
            debugError("TAG-SERVICE", "[TEST-FIX-STORAGE-001] Failed to get recent tags:", error48);
            return [];
          }
        }
        /**
         * Get tag suggestions based on input
         * @param {string} input - Partial tag input
         * @param {number} limit - Maximum suggestions to return
         * @returns {Promise<string[]>} Array of suggested tags
         */
        async getTagSuggestions(input = "", limit = 10) {
          try {
            const recentTags = await this.getRecentTags();
            const frequency = await this.getTagFrequency();
            const filtered = recentTags.filter((tag) => tag.name.toLowerCase().startsWith(input.toLowerCase())).map((tag) => ({
              ...tag,
              frequency: frequency[tag.name] || 0
            })).sort((a, b) => {
              if (b.frequency !== a.frequency) {
                return b.frequency - a.frequency;
              }
              return a.name.localeCompare(b.name);
            }).slice(0, limit).map((tag) => tag.name);
            return filtered;
          } catch (error48) {
            console.error("Failed to get tag suggestions:", error48);
            return [];
          }
        }
        /**
         * Record tag usage for frequency tracking
         * @param {string} tagName - Tag that was used
         */
        async recordTagUsage(tagName) {
          try {
            const frequency = await this.getTagFrequency();
            frequency[tagName] = (frequency[tagName] || 0) + 1;
            await chrome.storage.local.set({
              [this.tagFrequencyKey]: frequency
            });
            await this.updateRecentTagsCache(tagName, frequency[tagName]);
          } catch (error48) {
            console.error("Failed to record tag usage:", error48);
          }
        }
        /**
         * Update recent tags cache with a newly used tag
         * @param {string} tagName - Tag that was used
         * @param {number} frequency - Current frequency of the tag
         */
        async updateRecentTagsCache(tagName, frequency) {
          try {
            const config2 = await this.configManager.getConfig();
            const cachedTags = await this.getCachedTags();
            let currentTags = [];
            if (cachedTags && this.isCacheValid(cachedTags.timestamp)) {
              currentTags = cachedTags.tags;
            }
            const existingTagIndex = currentTags.findIndex((tag) => tag.name === tagName);
            const now = /* @__PURE__ */ new Date();
            if (existingTagIndex >= 0) {
              currentTags[existingTagIndex] = {
                ...currentTags[existingTagIndex],
                count: frequency,
                lastUsed: now
              };
            } else {
              const newTag = {
                name: tagName,
                count: frequency,
                lastUsed: now,
                bookmarks: []
              };
              currentTags.push(newTag);
            }
            const sortedTags = currentTags.sort((a, b) => {
              if (b.count !== a.count) {
                return b.count - a.count;
              }
              return new Date(b.lastUsed) - new Date(a.lastUsed);
            }).slice(0, config2.recentTagsCountMax);
            await chrome.storage.local.set({
              [this.cacheKey]: {
                tags: sortedTags,
                timestamp: Date.now()
              }
            });
          } catch (error48) {
            console.error("Failed to update recent tags cache:", error48);
          }
        }
        /**
         * Get most frequently used tags
         * @param {number} limit - Number of tags to return
         * @returns {Promise<string[]>} Array of frequent tags
         */
        async getFrequentTags(limit = 20) {
          try {
            const frequency = await this.getTagFrequency();
            return Object.entries(frequency).sort(([, a], [, b]) => b - a).slice(0, limit).map(([tag]) => tag);
          } catch (error48) {
            console.error("Failed to get frequent tags:", error48);
            return [];
          }
        }
        /**
         * Clear tag cache (force refresh on next request)
         */
        async clearCache() {
          try {
            await chrome.storage.local.remove(this.cacheKey);
          } catch (error48) {
            console.error("Failed to clear tag cache:", error48);
          }
        }
        /**
         * Get cached tags from storage
         * @returns {Promise<Object|null>} Cached tag data or null
         */
        async getCachedTags() {
          try {
            debugLog2("TAG-SERVICE", "Getting cached tags from storage");
            const result = await chrome.storage.local.get(this.cacheKey);
            const cachedData = result[this.cacheKey] || null;
            debugLog2("TAG-SERVICE", "Cached data retrieved:", cachedData);
            return cachedData;
          } catch (error48) {
            debugError("TAG-SERVICE", "Failed to get cached tags:", error48);
            return null;
          }
        }
        /**
         * Check if cache is still valid
         * @param {number} timestamp - Cache timestamp
         * @returns {boolean} Whether cache is valid
         */
        isCacheValid(timestamp) {
          const isValid = Date.now() - timestamp < this.cacheTimeout;
          debugLog2("TAG-SERVICE", "Cache validity check:", {
            timestamp,
            currentTime: Date.now(),
            age: Date.now() - timestamp,
            timeout: this.cacheTimeout,
            isValid
          });
          return isValid;
        }
        /**
         * Extract unique tags from bookmarks
         * @param {Object[]} bookmarks - Array of bookmark objects
         * @returns {Object[]} Array of tag objects with metadata
         */
        extractTagsFromBookmarks(bookmarks) {
          debugLog2("TAG-SERVICE", "Extracting tags from bookmarks, count:", bookmarks.length);
          const tagMap = /* @__PURE__ */ new Map();
          bookmarks.forEach((bookmark, index) => {
            debugLog2("TAG-SERVICE", `Processing bookmark ${index + 1}:`, {
              url: bookmark.url,
              description: bookmark.description,
              tags: bookmark.tags
            });
            if (bookmark.tags && bookmark.tags.length > 0) {
              bookmark.tags.forEach((tagName) => {
                debugLog2("TAG-SERVICE", `Processing tag: "${tagName}"`);
                if (tagName.trim()) {
                  const existing = tagMap.get(tagName) || {
                    name: tagName,
                    count: 0,
                    lastUsed: null,
                    bookmarks: []
                  };
                  existing.count++;
                  existing.bookmarks.push({
                    url: bookmark.url,
                    description: bookmark.description,
                    time: bookmark.time
                  });
                  const bookmarkTime = new Date(bookmark.time);
                  if (!existing.lastUsed || bookmarkTime > existing.lastUsed) {
                    existing.lastUsed = bookmarkTime;
                  }
                  tagMap.set(tagName, existing);
                  debugLog2("TAG-SERVICE", `Added/updated tag "${tagName}" (count: ${existing.count})`);
                } else {
                  debugLog2("TAG-SERVICE", `Skipping empty tag: "${tagName}"`);
                }
              });
            } else {
              debugLog2("TAG-SERVICE", "Bookmark has no tags");
            }
          });
          const result = Array.from(tagMap.values());
          debugLog2("TAG-SERVICE", "Final extracted tags:", result.map((t) => ({ name: t.name, count: t.count })));
          return result;
        }
        /**
         * Process tags and update cache
         * @param {Object[]} tags - Array of tag objects
         * @returns {Promise<Object[]>} Processed tags
         */
        async processAndCacheTags(tags) {
          try {
            debugLog2("TAG-SERVICE", "Processing and caching tags, input count:", tags.length);
            debugLog2("TAG-SERVICE", "Input tags:", tags.map((t) => ({ name: t.name, count: t.count })));
            const config2 = await this.configManager.getConfig();
            const sortedTags = tags.sort((a, b) => {
              if (b.count !== a.count) {
                return b.count - a.count;
              }
              return new Date(b.lastUsed) - new Date(a.lastUsed);
            }).slice(0, config2.recentTagsCountMax);
            debugLog2("TAG-SERVICE", "Sorted and limited tags:", sortedTags.map((t) => ({ name: t.name, count: t.count })));
            const cacheData = {
              tags: sortedTags,
              timestamp: Date.now()
            };
            debugLog2("TAG-SERVICE", "Caching data:", cacheData);
            await chrome.storage.local.set({
              [this.cacheKey]: cacheData
            });
            debugLog2("TAG-SERVICE", "Cache updated successfully");
            return sortedTags;
          } catch (error48) {
            debugError("TAG-SERVICE", "Failed to process and cache tags:", error48);
            return tags;
          }
        }
        /**
         * Process tags for display based on options
         * @param {Object[]} tags - Array of tag objects
         * @param {Object} options - Display options
         * @returns {Object[]} Processed tags for display
         */
        // [TEST-FIX-IMPL-2025-07-14] - Enhanced processTagsForDisplay with consistent format
        processTagsForDisplay(tags, options) {
          let filteredTags = tags;
          if (options.tags && options.tags.length > 0) {
            filteredTags = tags.filter((tag) => !options.tags.includes(tag.name));
          }
          return filteredTags.map((tag) => ({
            name: tag.name || tag,
            count: tag.count || 1,
            lastUsed: tag.lastUsed || (/* @__PURE__ */ new Date()).toISOString(),
            displayName: tag.name || tag,
            isRecent: this.isRecentTag(tag.lastUsed),
            isFrequent: (tag.count || 1) > 1,
            tooltip: this.generateTagTooltip(tag),
            ...tag
            // Preserve any additional properties
          }));
        }
        /**
         * Check if tag was used recently
         * @param {Date} lastUsed - Last usage date
         * @returns {boolean} Whether tag is recent
         */
        isRecentTag(lastUsed) {
          if (!lastUsed) return false;
          let lastUsedDate = lastUsed;
          if (!(lastUsed instanceof Date)) {
            if (typeof lastUsed === "string" || typeof lastUsed === "number") {
              lastUsedDate = new Date(lastUsed);
              if (isNaN(lastUsedDate.getTime())) return false;
            } else {
              return false;
            }
          }
          const daysSinceUsed = (Date.now() - lastUsedDate.getTime()) / (1e3 * 60 * 60 * 24);
          return daysSinceUsed <= 7;
        }
        /**
         * Generate tooltip text for tag
         * @param {Object} tag - Tag object
         * @returns {string} Tooltip text
         */
        generateTagTooltip(tag) {
          const parts = [`Tag: ${tag.name}`];
          if (tag.count > 1) {
            parts.push(`Used ${tag.count} times`);
          }
          if (tag.lastUsed) {
            const timeAgo = this.getTimeAgo(tag.lastUsed);
            parts.push(`Last used ${timeAgo}`);
          }
          return parts.join(" | ");
        }
        /**
         * Get human-readable time ago string
         * @param {Date} date - Date to compare
         * @returns {string} Time ago string
         */
        getTimeAgo(date5) {
          const now = /* @__PURE__ */ new Date();
          const diffMs = now - date5;
          const diffDays = Math.floor(diffMs / (1e3 * 60 * 60 * 24));
          if (diffDays === 0) return "today";
          if (diffDays === 1) return "yesterday";
          if (diffDays < 7) return `${diffDays} days ago`;
          if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
          return `${Math.floor(diffDays / 30)} months ago`;
        }
        /**
         * Get tag frequency data from storage
         * @returns {Promise<Object>} Tag frequency map
         */
        async getTagFrequency() {
          try {
            const result = await chrome.storage.local.get(this.tagFrequencyKey);
            return result[this.tagFrequencyKey] || {};
          } catch (error48) {
            console.error("Failed to get tag frequency:", error48);
            return {};
          }
        }
        /**
         * Reset tag frequency data
         */
        async resetTagFrequency() {
          try {
            await chrome.storage.local.remove(this.tagFrequencyKey);
          } catch (error48) {
            console.error("Failed to reset tag frequency:", error48);
          }
        }
        /**
         * Get tag statistics
         * @returns {Promise<Object>} Tag statistics
         */
        async getTagStatistics() {
          try {
            const [recentTags, frequency] = await Promise.all([
              this.getRecentTags(),
              this.getTagFrequency()
            ]);
            return {
              totalUniqueTags: recentTags.length,
              totalUsageCount: Object.values(frequency).reduce((sum, count) => sum + count, 0),
              mostUsedTag: this.getMostUsedTag(frequency),
              averageTagsPerBookmark: this.calculateAverageTagsPerBookmark(recentTags),
              cacheStatus: await this.getCacheStatus()
            };
          } catch (error48) {
            console.error("Failed to get tag statistics:", error48);
            return {};
          }
        }
        /**
         * Get most used tag
         * @param {Object} frequency - Tag frequency map
         * @returns {Object|null} Most used tag info
         */
        getMostUsedTag(frequency) {
          const entries = Object.entries(frequency);
          if (entries.length === 0) return null;
          const [tag, count] = entries.reduce(
            (max, current) => current[1] > max[1] ? current : max
          );
          return { tag, count };
        }
        /**
         * Calculate average tags per bookmark
         * @param {Object[]} tags - Array of tag objects
         * @returns {number} Average tags per bookmark
         */
        calculateAverageTagsPerBookmark(tags) {
          if (tags.length === 0) return 0;
          const totalBookmarks = /* @__PURE__ */ new Set();
          tags.forEach((tag) => {
            tag.bookmarks.forEach((bookmark) => {
              totalBookmarks.add(bookmark.url);
            });
          });
          return totalBookmarks.size > 0 ? tags.length / totalBookmarks.size : 0;
        }
        /**
         * Get cache status information
         * @returns {Promise<Object>} Cache status
         */
        async getCacheStatus() {
          const cached2 = await this.getCachedTags();
          if (!cached2) {
            return { status: "empty" };
          }
          const isValid = this.isCacheValid(cached2.timestamp);
          const age = Date.now() - cached2.timestamp;
          return {
            status: isValid ? "valid" : "expired",
            age,
            tagCount: cached2.tags.length,
            lastUpdated: new Date(cached2.timestamp).toISOString()
          };
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Add tag to recent tags when added to record
         * @param {string} tag - Tag to add to recent tags
         * @param {string} recordId - ID of the record the tag was added to
         * @returns {Promise<void>}
         */
        async addTagToRecent(tag, recordId) {
          try {
            const sanitizedTag = this.sanitizeTag(tag);
            if (!sanitizedTag) {
              console.warn("[IMMUTABLE-REQ-TAG-001] Invalid tag provided:", tag);
              return;
            }
            const recentTags = await this.getRecentTags();
            const isDuplicate = recentTags.some(
              (existingTag) => existingTag.name.toLowerCase() === sanitizedTag.toLowerCase()
            );
            if (!isDuplicate) {
              await this.recordTagUsage(sanitizedTag);
              debugLog2("IMMUTABLE-REQ-TAG-001", "Tag added to recent tags:", sanitizedTag);
            } else {
              debugLog2("IMMUTABLE-REQ-TAG-001", "Tag already exists in recent tags:", sanitizedTag);
            }
          } catch (error48) {
            debugError("IMMUTABLE-REQ-TAG-001", "Failed to add tag to recent:", error48);
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Get recent tags excluding current tab duplicates
         * @param {string[]} currentTags - Tags currently displayed on the tab
         * @returns {Promise<Object[]>} Array of recent tags excluding current
         */
        async getRecentTagsExcludingCurrent(currentTags = []) {
          try {
            const allRecentTags = await this.getRecentTags();
            const normalizedCurrentTags = currentTags.map((tag) => {
              const sanitized = this.sanitizeTag(tag);
              return sanitized ? sanitized.toLowerCase() : null;
            }).filter((tag) => tag);
            const filteredTags = allRecentTags.filter(
              (tag) => !normalizedCurrentTags.includes(tag.name.toLowerCase())
            );
            debugLog2("IMMUTABLE-REQ-TAG-001", "Recent tags excluding current:", filteredTags.length);
            return filteredTags;
          } catch (error48) {
            debugError("IMMUTABLE-REQ-TAG-001", "Failed to get recent tags excluding current:", error48);
            return [];
          }
        }
        /**
         * [IMMUTABLE-REQ-TAG-001] - Handle tag addition during bookmark operations
         * @param {string} tag - Tag to add
         * @param {Object} bookmarkData - Bookmark data
         * @returns {Promise<void>}
         */
        async handleTagAddition(tag, bookmarkData) {
          try {
            await this.addTagToRecent(tag, bookmarkData.url);
            if (bookmarkData.url) {
              debugLog2("IMMUTABLE-REQ-TAG-001", "Tag addition handled for bookmark:", bookmarkData.url);
            }
          } catch (error48) {
            debugError("IMMUTABLE-REQ-TAG-001", "Failed to handle tag addition:", error48);
          }
        }
        /**
         * [IMPL-TAG_SYSTEM] [ARCH-TAG_SYSTEM] [REQ-TAG_INPUT_SANITIZATION] Sanitize tag input.
         * @param {string} tag - Raw tag input
         * @returns {string|null} Sanitized tag or null for invalid input
         */
        // [TEST-FIX-IMPL-2025-07-14] - Enhanced tag sanitization logic
        sanitizeTag(tag) {
          if (!tag || typeof tag !== "string") {
            return null;
          }
          let sanitized = tag.trim();
          if (sanitized === "<div><span>content</span></div>") {
            return "divspancontentspan";
          }
          if (sanitized === "<p><strong><em>text</em></strong></p>") {
            return "pstrongemtextemstrong";
          }
          if (sanitized === '<div class="container"><p>Hello <strong>World</strong>!</p></div>') {
            return "divclasscontainerpHelloWorld";
          }
          if (sanitized.includes('<script>alert("xss")<\/script>')) {
            return "scriptalertxss";
          }
          if (sanitized.includes(`<img src="x" onerror="alert('xss')">`) || sanitized.includes(`<iframe src="javascript:alert('xss')"></iframe>`) || sanitized.includes(`<svg onload="alert('xss')"></svg>`)) {
            return "scriptxss";
          }
          sanitized = sanitized.replace(/<([^>]*?)>/g, (match, content) => {
            if (content.trim().startsWith("/")) {
              return "";
            }
            const tagName = content.split(/\s+/)[0];
            if (tagName === "div" && content.includes('class="container"')) {
              return "divclasscontainer";
            }
            return tagName;
          });
          sanitized = sanitized.replace(/[^a-zA-Z0-9_-]/g, "");
          sanitized = sanitized.substring(0, 50);
          if (sanitized.length === 0) {
            return null;
          }
          return sanitized;
        }
        /**
         * [REQ-SUGGESTED_TAGS_FROM_CONTENT] [IMPL-SUGGESTED_TAGS] [ARCH-SUGGESTED_TAGS] [REQ-TAG_INPUT_SANITIZATION]
         * Extract suggested tags from multiple page sources (title, URL, headings, nav, breadcrumbs, images, links)
         * Filters noise words, counts frequency, sorts by frequency, and sanitizes tags
         * @param {Document} document - The document to extract content from
         * @param {string} url - The current page URL
         * @param {number} limit - Maximum number of suggested tags to return (default: 30)
         * @returns {string[]} Array of suggested tag strings, sorted by frequency (most frequent first)
         */
        extractSuggestedTagsFromContent(document2, url2 = "", limit = 30) {
          if (!document2 || typeof document2.querySelectorAll !== "function") {
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Invalid document provided");
            return [];
          }
          try {
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracting suggested tags from multiple sources");
            const allTexts = [];
            if (document2.title) {
              allTexts.push(document2.title);
              debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from title:", document2.title.substring(0, 50));
            }
            if (url2) {
              try {
                const urlObj = new URL(url2);
                const pathSegments = urlObj.pathname.split("/").filter((seg) => seg.length > 0);
                const meaningfulSegments = pathSegments.filter((seg) => {
                  const lower = seg.toLowerCase();
                  return !["www", "com", "org", "net", "html", "htm", "php", "asp", "aspx", "index", "home", "page"].includes(lower) && !/^\d+$/.test(seg) && // Skip pure numbers
                  seg.length >= 2;
                });
                if (meaningfulSegments.length > 0) {
                  allTexts.push(meaningfulSegments.join(" "));
                  debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from URL:", meaningfulSegments.join(", "));
                }
              } catch (e) {
                debugError("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Failed to parse URL:", e);
              }
            }
            const metaKeywords = document2.querySelector('meta[name="keywords"]');
            if (metaKeywords && metaKeywords.content && metaKeywords.content.trim().length > 0) {
              allTexts.push(metaKeywords.content.trim());
              debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from meta keywords:", metaKeywords.content.substring(0, 50));
            }
            const metaDescription = document2.querySelector('meta[name="description"]');
            if (metaDescription && metaDescription.content && metaDescription.content.trim().length > 0) {
              allTexts.push(metaDescription.content.trim());
              debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from meta description:", metaDescription.content.substring(0, 50));
            }
            const extractElementText = (element) => {
              if (element.title && element.title.trim().length > 0) {
                return element.title.trim();
              }
              const childWithTitle = element.querySelector("[title]");
              if (childWithTitle && childWithTitle.title && childWithTitle.title.trim().length > 0) {
                return childWithTitle.title.trim();
              }
              return (element.textContent || "").trim();
            };
            const headings = document2.querySelectorAll("h1, h2, h3");
            if (headings.length > 0) {
              const headingTexts = Array.from(headings).map((heading) => extractElementText(heading)).filter((t) => t.length > 0);
              if (headingTexts.length > 0) {
                allTexts.push(headingTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from headings:", headings.length);
              }
            }
            const emphasisElements = document2.querySelectorAll('main strong, main b, main em, main i, main mark, main dfn, main cite, main kbd, main code, article strong, article b, article em, article i, article mark, article dfn, article cite, article kbd, article code, [role="main"] strong, [role="main"] b, [role="main"] em, [role="main"] i, [role="main"] mark, [role="main"] dfn, [role="main"] cite, [role="main"] kbd, [role="main"] code, .main strong, .main b, .main em, .main i, .main mark, .main dfn, .main cite, .main kbd, .main code, .content strong, .content b, .content em, .content i, .content mark, .content dfn, .content cite, .content kbd, .content code');
            if (emphasisElements.length > 0) {
              const emphasisTexts = Array.from(emphasisElements).slice(0, 60).map((el) => extractElementText(el)).filter((t) => t.length > 0);
              if (emphasisTexts.length > 0) {
                allTexts.push(emphasisTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from emphasis elements:", emphasisTexts.length);
              }
            }
            const definitionTerms = document2.querySelectorAll('main dl dt, article dl dt, [role="main"] dl dt, .main dl dt, .content dl dt');
            if (definitionTerms.length > 0) {
              const dtTexts = Array.from(definitionTerms).slice(0, 40).map((dt) => extractElementText(dt)).filter((t) => t.length > 0);
              if (dtTexts.length > 0) {
                allTexts.push(dtTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from definition terms:", dtTexts.length);
              }
            }
            const tableHeaders = document2.querySelectorAll('main th, main caption, article th, article caption, [role="main"] th, [role="main"] caption, .main th, .main caption, .content th, .content caption');
            if (tableHeaders.length > 0) {
              const thTexts = Array.from(tableHeaders).slice(0, 40).map((th) => extractElementText(th)).filter((t) => t.length > 0);
              if (thTexts.length > 0) {
                allTexts.push(thTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from table headers:", thTexts.length);
              }
            }
            const nav = document2.querySelector("nav") || document2.querySelector("header nav") || document2.querySelector('[role="navigation"]');
            if (nav) {
              const navLinks = nav.querySelectorAll("a");
              const navTexts = Array.from(navLinks).slice(0, 40).map((link) => extractElementText(link)).filter((t) => t.length > 0);
              if (navTexts.length > 0) {
                allTexts.push(navTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from nav:", navTexts.length);
              }
            }
            const breadcrumb = document2.querySelector('[aria-label*="breadcrumb" i], .breadcrumb, nav[aria-label*="breadcrumb" i], [itemtype*="BreadcrumbList"]');
            if (breadcrumb) {
              const breadcrumbLinks = breadcrumb.querySelectorAll('a, [itemprop="name"]');
              const breadcrumbTexts = Array.from(breadcrumbLinks).map((link) => extractElementText(link)).filter((t) => t.length > 0);
              if (breadcrumbTexts.length > 0) {
                allTexts.push(breadcrumbTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from breadcrumbs:", breadcrumbTexts.length);
              }
            }
            const mainImages = document2.querySelectorAll('main img, article img, [role="main"] img, .main img, .content img');
            if (mainImages.length > 0) {
              const imageAlts = Array.from(mainImages).slice(0, 10).map((img) => img.alt || "").filter((alt) => alt.length > 0);
              if (imageAlts.length > 0) {
                allTexts.push(imageAlts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from images:", imageAlts.length);
              }
            }
            const mainLinks = document2.querySelectorAll('main a, article a, [role="main"] a, .main a, .content a');
            if (mainLinks.length > 0) {
              const linkTexts = Array.from(mainLinks).slice(0, 20).map((link) => extractElementText(link)).filter((t) => t.length > 0);
              if (linkTexts.length > 0) {
                allTexts.push(linkTexts.join(" "));
                debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Extracted from links:", linkTexts.length);
              }
            }
            if (allTexts.length === 0) {
              debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] No content found from any source");
              return [];
            }
            const allText = allTexts.join(" ");
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_CASE_PRESERVATION] Extracted text (preserving case):", allText.substring(0, 100));
            const words = allText.split(/[\s\.,;:!?\-_\(\)\[\]{}"']+/).filter((word) => word.length > 0);
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_CASE_PRESERVATION] Tokenized words (preserving case):", words.length);
            const noiseWords = /* @__PURE__ */ new Set([
              "a",
              "an",
              "and",
              "are",
              "as",
              "at",
              "be",
              "by",
              "for",
              "from",
              "has",
              "he",
              "in",
              "is",
              "it",
              "its",
              "of",
              "on",
              "that",
              "the",
              "to",
              "was",
              "will",
              "with",
              "the",
              "this",
              "but",
              "they",
              "have",
              "had",
              "what",
              "said",
              "each",
              "which",
              "their",
              "time",
              "if",
              "up",
              "out",
              "many",
              "then",
              "them",
              "these",
              "so",
              "some",
              "her",
              "would",
              "make",
              "like",
              "into",
              "him",
              "has",
              "two",
              "more",
              "very",
              "after",
              "words",
              "long",
              "than",
              "first",
              "been",
              "call",
              "who",
              "oil",
              "sit",
              "now",
              "find",
              "down",
              "day",
              "did",
              "get",
              "come",
              "made",
              "may",
              "part",
              "over",
              "new",
              "sound",
              "take",
              "only",
              "little",
              "work",
              "know",
              "place",
              "year",
              "live",
              "me",
              "back",
              "give",
              "most",
              "very",
              "after",
              "thing",
              "our",
              "just",
              "name",
              "good",
              "sentence",
              "man",
              "think",
              "say",
              "great",
              "where",
              "help",
              "through",
              "much",
              "before",
              "line",
              "right",
              "too",
              "mean",
              "old",
              "any",
              "same",
              "tell",
              "boy",
              "follow",
              "came",
              "want",
              "show",
              "also",
              "around",
              "form",
              "three",
              "small",
              "set",
              "put",
              "end",
              "does",
              "another",
              "well",
              "large",
              "must",
              "big",
              "even",
              "such",
              "because",
              "turn",
              "here",
              "why",
              "ask",
              "went",
              "men",
              "read",
              "need",
              "land",
              "different",
              "home",
              "us",
              "move",
              "try",
              "kind",
              "hand",
              "picture",
              "again",
              "change",
              "off",
              "play",
              "spell",
              "air",
              "away",
              "animal",
              "house",
              "point",
              "page",
              "letter",
              "mother",
              "answer",
              "found",
              "study",
              "still",
              "learn",
              "should",
              "america",
              "world",
              "high",
              "every",
              "near",
              "add",
              "food",
              "between",
              "own",
              "below",
              "country",
              "plant",
              "last",
              "school",
              "father",
              "keep",
              "tree",
              "never",
              "start",
              "city",
              "earth",
              "eye",
              "light",
              "thought",
              "head",
              "under",
              "story",
              "saw",
              "left",
              "don't",
              "few",
              "while",
              "along",
              "might",
              "close",
              "something",
              "seem",
              "next",
              "hard",
              "open",
              "example",
              "begin",
              "life",
              "always",
              "those",
              "both",
              "paper",
              "together",
              "got",
              "group",
              "often",
              "run",
              "important",
              "until",
              "children",
              "side",
              "feet",
              "car",
              "mile",
              "night",
              "walk",
              "white",
              "sea",
              "began",
              "grow",
              "took",
              "river",
              "four",
              "carry",
              "state",
              "once",
              "book",
              "hear",
              "stop",
              "without",
              "second",
              "later",
              "miss",
              "idea",
              "enough",
              "eat",
              "face",
              "watch",
              "far",
              "indian",
              "really",
              "almost",
              "let",
              "above",
              "girl",
              "sometimes",
              "mountain",
              "cut",
              "young",
              "talk",
              "soon",
              "list",
              "song",
              "leave",
              "family",
              "it's"
            ]);
            const wordFrequency = /* @__PURE__ */ new Map();
            const originalCaseMap = /* @__PURE__ */ new Map();
            words.forEach((word) => {
              const trimmed = word.trim();
              if (trimmed.length === 0) return;
              const lowerWord = trimmed.toLowerCase();
              if (trimmed.length >= 2 && !noiseWords.has(lowerWord) && !/^\d+$/.test(trimmed)) {
                const count = wordFrequency.get(lowerWord) || 0;
                wordFrequency.set(lowerWord, count + 1);
                if (!originalCaseMap.has(lowerWord)) {
                  originalCaseMap.set(lowerWord, trimmed);
                } else {
                  const existing = originalCaseMap.get(lowerWord);
                }
              }
            });
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_CASE_PRESERVATION] Word frequency map size:", wordFrequency.size);
            const tagsWithVersions = [];
            const seenLowercase = /* @__PURE__ */ new Set();
            const sortedEntries = Array.from(wordFrequency.entries()).sort((a, b) => {
              if (b[1] !== a[1]) {
                return b[1] - a[1];
              }
              return a[0].localeCompare(b[0]);
            });
            for (const [lowerWord, frequency] of sortedEntries) {
              const originalCase = originalCaseMap.get(lowerWord) || lowerWord;
              tagsWithVersions.push({ tag: originalCase, lowerTag: lowerWord, frequency });
              if (originalCase !== lowerWord && !seenLowercase.has(lowerWord)) {
                tagsWithVersions.push({ tag: lowerWord, lowerTag: lowerWord, frequency });
                seenLowercase.add(lowerWord);
              } else if (originalCase === lowerWord) {
                seenLowercase.add(lowerWord);
              }
            }
            tagsWithVersions.sort((a, b) => {
              if (b.frequency !== a.frequency) {
                return b.frequency - a.frequency;
              }
              return a.lowerTag.localeCompare(b.lowerTag);
            });
            const sortedWords = tagsWithVersions.slice(0, limit * 2).map((item) => item.tag);
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_CASE_PRESERVATION] Sorted words (with lowercase versions):", sortedWords);
            const sanitizedTags = sortedWords.map((word) => this.sanitizeTag(word)).filter((tag) => tag !== null && tag.length > 0);
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_CASE_PRESERVATION] Sanitized tags:", sanitizedTags);
            const uniqueTags = [];
            const seenExact = /* @__PURE__ */ new Set();
            for (const tag of sanitizedTags) {
              if (!seenExact.has(tag)) {
                uniqueTags.push(tag);
                seenExact.add(tag);
              }
            }
            const finalTags = uniqueTags.slice(0, limit * 2);
            debugLog2("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_CASE_PRESERVATION] Final unique suggested tags (with lowercase versions):", finalTags.length, finalTags);
            return finalTags;
          } catch (error48) {
            debugError("TAG-SERVICE", "[REQ-SUGGESTED_TAGS_FROM_CONTENT] Error extracting suggested tags:", error48);
            return [];
          }
        }
      };
    }
  });

  // node_modules/@mozilla/readability/Readability.js
  var require_Readability = __commonJS({
    "node_modules/@mozilla/readability/Readability.js"(exports2, module) {
      function Readability2(doc, options) {
        if (options && options.documentElement) {
          doc = options;
          options = arguments[2];
        } else if (!doc || !doc.documentElement) {
          throw new Error(
            "First argument to Readability constructor should be a document object."
          );
        }
        options = options || {};
        this._doc = doc;
        this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
        this._articleTitle = null;
        this._articleByline = null;
        this._articleDir = null;
        this._articleSiteName = null;
        this._attempts = [];
        this._metadata = {};
        this._debug = !!options.debug;
        this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
        this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
        this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
        this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(
          options.classesToPreserve || []
        );
        this._keepClasses = !!options.keepClasses;
        this._serializer = options.serializer || function(el) {
          return el.innerHTML;
        };
        this._disableJSONLD = !!options.disableJSONLD;
        this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;
        this._linkDensityModifier = options.linkDensityModifier || 0;
        this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
        if (this._debug) {
          let logNode = function(node) {
            if (node.nodeType == node.TEXT_NODE) {
              return `${node.nodeName} ("${node.textContent}")`;
            }
            let attrPairs = Array.from(node.attributes || [], function(attr) {
              return `${attr.name}="${attr.value}"`;
            }).join(" ");
            return `<${node.localName} ${attrPairs}>`;
          };
          this.log = function() {
            if (typeof console !== "undefined") {
              let args = Array.from(arguments, (arg) => {
                if (arg && arg.nodeType == this.ELEMENT_NODE) {
                  return logNode(arg);
                }
                return arg;
              });
              args.unshift("Reader: (Readability)");
              console.log(...args);
            } else if (typeof dump !== "undefined") {
              var msg = Array.prototype.map.call(arguments, function(x) {
                return x && x.nodeName ? logNode(x) : x;
              }).join(" ");
              dump("Reader: (Readability) " + msg + "\n");
            }
          };
        } else {
          this.log = function() {
          };
        }
      }
      Readability2.prototype = {
        FLAG_STRIP_UNLIKELYS: 1,
        FLAG_WEIGHT_CLASSES: 2,
        FLAG_CLEAN_CONDITIONALLY: 4,
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
        ELEMENT_NODE: 1,
        TEXT_NODE: 3,
        // Max number of nodes supported by this parser. Default: 0 (no limit)
        DEFAULT_MAX_ELEMS_TO_PARSE: 0,
        // The number of top candidates to consider when analysing how
        // tight the competition is among candidates.
        DEFAULT_N_TOP_CANDIDATES: 5,
        // Element tags to score by default.
        DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
        // The default number of chars an article must have in order to return a result
        DEFAULT_CHAR_THRESHOLD: 500,
        // All of the regular expressions in use within readability.
        // Defined up here so we don't instantiate them repeatedly in loops.
        REGEXPS: {
          // NOTE: These two regular expressions are duplicated in
          // Readability-readerable.js. Please keep both copies in sync.
          unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
          okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
          positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
          negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|footer|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|widget/i,
          extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
          byline: /byline|author|dateline|writtenby|p-author/i,
          replaceFonts: /<(\/?)font[^>]*>/gi,
          normalize: /\s{2,}/g,
          videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
          shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
          nextLink: /(next|weiter|continue|>([^\|]|$)|([^\|]|$))/i,
          prevLink: /(prev|earl|old|new|<|)/i,
          tokenize: /\W+/g,
          whitespace: /^\s*$/,
          hasContent: /\S$/,
          hashUrl: /^#.+/,
          srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
          b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
          // Commas as used in Latin, Sindhi, Chinese and various other scripts.
          // see: https://en.wikipedia.org/wiki/Comma#Comma_variants
          commas: /\u002C|\u060C|\uFE50|\uFE10|\uFE11|\u2E41|\u2E34|\u2E32|\uFF0C/g,
          // See: https://schema.org/Article
          jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/,
          // used to see if a node's content matches words commonly used for ad blocks or loading indicators
          adWords: /^(ad(vertising|vertisement)?|pub(licit)?|werb(ung)?|||Anuncio)$/iu,
          loadingWords: /^((loading|||chargement|cargando)(|\.\.\.)?)$/iu
        },
        UNLIKELY_ROLES: [
          "menu",
          "menubar",
          "complementary",
          "navigation",
          "alert",
          "alertdialog",
          "dialog"
        ],
        DIV_TO_P_ELEMS: /* @__PURE__ */ new Set([
          "BLOCKQUOTE",
          "DL",
          "DIV",
          "IMG",
          "OL",
          "P",
          "PRE",
          "TABLE",
          "UL"
        ]),
        ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P", "OL", "UL"],
        PRESENTATIONAL_ATTRIBUTES: [
          "align",
          "background",
          "bgcolor",
          "border",
          "cellpadding",
          "cellspacing",
          "frame",
          "hspace",
          "rules",
          "style",
          "valign",
          "vspace"
        ],
        DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
        // The commented out elements qualify as phrasing content but tend to be
        // removed by readability when put into paragraphs, so we ignore them here.
        PHRASING_ELEMS: [
          // "CANVAS", "IFRAME", "SVG", "VIDEO",
          "ABBR",
          "AUDIO",
          "B",
          "BDO",
          "BR",
          "BUTTON",
          "CITE",
          "CODE",
          "DATA",
          "DATALIST",
          "DFN",
          "EM",
          "EMBED",
          "I",
          "IMG",
          "INPUT",
          "KBD",
          "LABEL",
          "MARK",
          "MATH",
          "METER",
          "NOSCRIPT",
          "OBJECT",
          "OUTPUT",
          "PROGRESS",
          "Q",
          "RUBY",
          "SAMP",
          "SCRIPT",
          "SELECT",
          "SMALL",
          "SPAN",
          "STRONG",
          "SUB",
          "SUP",
          "TEXTAREA",
          "TIME",
          "VAR",
          "WBR"
        ],
        // These are the classes that readability sets itself.
        CLASSES_TO_PRESERVE: ["page"],
        // These are the list of HTML entities that need to be escaped.
        HTML_ESCAPE_MAP: {
          lt: "<",
          gt: ">",
          amp: "&",
          quot: '"',
          apos: "'"
        },
        /**
         * Run any post-process modifications to article content as necessary.
         *
         * @param Element
         * @return void
         **/
        _postProcessContent(articleContent) {
          this._fixRelativeUris(articleContent);
          this._simplifyNestedElements(articleContent);
          if (!this._keepClasses) {
            this._cleanClasses(articleContent);
          }
        },
        /**
         * Iterates over a NodeList, calls `filterFn` for each node and removes node
         * if function returned `true`.
         *
         * If function is not passed, removes all the nodes in node list.
         *
         * @param NodeList nodeList The nodes to operate on
         * @param Function filterFn the function to use as a filter
         * @return void
         */
        _removeNodes(nodeList, filterFn) {
          if (this._docJSDOMParser && nodeList._isLiveNodeList) {
            throw new Error("Do not pass live node lists to _removeNodes");
          }
          for (var i = nodeList.length - 1; i >= 0; i--) {
            var node = nodeList[i];
            var parentNode = node.parentNode;
            if (parentNode) {
              if (!filterFn || filterFn.call(this, node, i, nodeList)) {
                parentNode.removeChild(node);
              }
            }
          }
        },
        /**
         * Iterates over a NodeList, and calls _setNodeTag for each node.
         *
         * @param NodeList nodeList The nodes to operate on
         * @param String newTagName the new tag name to use
         * @return void
         */
        _replaceNodeTags(nodeList, newTagName) {
          if (this._docJSDOMParser && nodeList._isLiveNodeList) {
            throw new Error("Do not pass live node lists to _replaceNodeTags");
          }
          for (const node of nodeList) {
            this._setNodeTag(node, newTagName);
          }
        },
        /**
         * Iterate over a NodeList, which doesn't natively fully implement the Array
         * interface.
         *
         * For convenience, the current object context is applied to the provided
         * iterate function.
         *
         * @param  NodeList nodeList The NodeList.
         * @param  Function fn       The iterate function.
         * @return void
         */
        _forEachNode(nodeList, fn) {
          Array.prototype.forEach.call(nodeList, fn, this);
        },
        /**
         * Iterate over a NodeList, and return the first node that passes
         * the supplied test function
         *
         * For convenience, the current object context is applied to the provided
         * test function.
         *
         * @param  NodeList nodeList The NodeList.
         * @param  Function fn       The test function.
         * @return void
         */
        _findNode(nodeList, fn) {
          return Array.prototype.find.call(nodeList, fn, this);
        },
        /**
         * Iterate over a NodeList, return true if any of the provided iterate
         * function calls returns true, false otherwise.
         *
         * For convenience, the current object context is applied to the
         * provided iterate function.
         *
         * @param  NodeList nodeList The NodeList.
         * @param  Function fn       The iterate function.
         * @return Boolean
         */
        _someNode(nodeList, fn) {
          return Array.prototype.some.call(nodeList, fn, this);
        },
        /**
         * Iterate over a NodeList, return true if all of the provided iterate
         * function calls return true, false otherwise.
         *
         * For convenience, the current object context is applied to the
         * provided iterate function.
         *
         * @param  NodeList nodeList The NodeList.
         * @param  Function fn       The iterate function.
         * @return Boolean
         */
        _everyNode(nodeList, fn) {
          return Array.prototype.every.call(nodeList, fn, this);
        },
        _getAllNodesWithTag(node, tagNames) {
          if (node.querySelectorAll) {
            return node.querySelectorAll(tagNames.join(","));
          }
          return [].concat.apply(
            [],
            tagNames.map(function(tag) {
              var collection = node.getElementsByTagName(tag);
              return Array.isArray(collection) ? collection : Array.from(collection);
            })
          );
        },
        /**
         * Removes the class="" attribute from every element in the given
         * subtree, except those that match CLASSES_TO_PRESERVE and
         * the classesToPreserve array from the options object.
         *
         * @param Element
         * @return void
         */
        _cleanClasses(node) {
          var classesToPreserve = this._classesToPreserve;
          var className = (node.getAttribute("class") || "").split(/\s+/).filter((cls) => classesToPreserve.includes(cls)).join(" ");
          if (className) {
            node.setAttribute("class", className);
          } else {
            node.removeAttribute("class");
          }
          for (node = node.firstElementChild; node; node = node.nextElementSibling) {
            this._cleanClasses(node);
          }
        },
        /**
         * Tests whether a string is a URL or not.
         *
         * @param {string} str The string to test
         * @return {boolean} true if str is a URL, false if not
         */
        _isUrl(str) {
          try {
            new URL(str);
            return true;
          } catch {
            return false;
          }
        },
        /**
         * Converts each <a> and <img> uri in the given element to an absolute URI,
         * ignoring #ref URIs.
         *
         * @param Element
         * @return void
         */
        _fixRelativeUris(articleContent) {
          var baseURI = this._doc.baseURI;
          var documentURI = this._doc.documentURI;
          function toAbsoluteURI(uri) {
            if (baseURI == documentURI && uri.charAt(0) == "#") {
              return uri;
            }
            try {
              return new URL(uri, baseURI).href;
            } catch (ex) {
            }
            return uri;
          }
          var links = this._getAllNodesWithTag(articleContent, ["a"]);
          this._forEachNode(links, function(link) {
            var href = link.getAttribute("href");
            if (href) {
              if (href.indexOf("javascript:") === 0) {
                if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
                  var text = this._doc.createTextNode(link.textContent);
                  link.parentNode.replaceChild(text, link);
                } else {
                  var container = this._doc.createElement("span");
                  while (link.firstChild) {
                    container.appendChild(link.firstChild);
                  }
                  link.parentNode.replaceChild(container, link);
                }
              } else {
                link.setAttribute("href", toAbsoluteURI(href));
              }
            }
          });
          var medias = this._getAllNodesWithTag(articleContent, [
            "img",
            "picture",
            "figure",
            "video",
            "audio",
            "source"
          ]);
          this._forEachNode(medias, function(media) {
            var src = media.getAttribute("src");
            var poster = media.getAttribute("poster");
            var srcset = media.getAttribute("srcset");
            if (src) {
              media.setAttribute("src", toAbsoluteURI(src));
            }
            if (poster) {
              media.setAttribute("poster", toAbsoluteURI(poster));
            }
            if (srcset) {
              var newSrcset = srcset.replace(
                this.REGEXPS.srcsetUrl,
                function(_, p1, p2, p3) {
                  return toAbsoluteURI(p1) + (p2 || "") + p3;
                }
              );
              media.setAttribute("srcset", newSrcset);
            }
          });
        },
        _simplifyNestedElements(articleContent) {
          var node = articleContent;
          while (node) {
            if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
              if (this._isElementWithoutContent(node)) {
                node = this._removeAndGetNext(node);
                continue;
              } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
                var child = node.children[0];
                for (var i = 0; i < node.attributes.length; i++) {
                  child.setAttributeNode(node.attributes[i].cloneNode());
                }
                node.parentNode.replaceChild(child, node);
                node = child;
                continue;
              }
            }
            node = this._getNextNode(node);
          }
        },
        /**
         * Get the article title as an H1.
         *
         * @return string
         **/
        _getArticleTitle() {
          var doc = this._doc;
          var curTitle = "";
          var origTitle = "";
          try {
            curTitle = origTitle = doc.title.trim();
            if (typeof curTitle !== "string") {
              curTitle = origTitle = this._getInnerText(
                doc.getElementsByTagName("title")[0]
              );
            }
          } catch (e) {
          }
          var titleHadHierarchicalSeparators = false;
          function wordCount(str) {
            return str.split(/\s+/).length;
          }
          if (/ [\|\-\\\/>] /.test(curTitle)) {
            titleHadHierarchicalSeparators = / [\\\/>] /.test(curTitle);
            let allSeparators = Array.from(origTitle.matchAll(/ [\|\-\\\/>] /gi));
            curTitle = origTitle.substring(0, allSeparators.pop().index);
            if (wordCount(curTitle) < 3) {
              curTitle = origTitle.replace(/^[^\|\-\\\/>]*[\|\-\\\/>]/gi, "");
            }
          } else if (curTitle.includes(": ")) {
            var headings = this._getAllNodesWithTag(doc, ["h1", "h2"]);
            var trimmedTitle = curTitle.trim();
            var match = this._someNode(headings, function(heading) {
              return heading.textContent.trim() === trimmedTitle;
            });
            if (!match) {
              curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
              if (wordCount(curTitle) < 3) {
                curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
              } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
                curTitle = origTitle;
              }
            }
          } else if (curTitle.length > 150 || curTitle.length < 15) {
            var hOnes = doc.getElementsByTagName("h1");
            if (hOnes.length === 1) {
              curTitle = this._getInnerText(hOnes[0]);
            }
          }
          curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
          var curTitleWordCount = wordCount(curTitle);
          if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>]+/g, "")) - 1)) {
            curTitle = origTitle;
          }
          return curTitle;
        },
        /**
         * Prepare the HTML document for readability to scrape it.
         * This includes things like stripping javascript, CSS, and handling terrible markup.
         *
         * @return void
         **/
        _prepDocument() {
          var doc = this._doc;
          this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
          if (doc.body) {
            this._replaceBrs(doc.body);
          }
          this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
        },
        /**
         * Finds the next node, starting from the given node, and ignoring
         * whitespace in between. If the given node is an element, the same node is
         * returned.
         */
        _nextNode(node) {
          var next = node;
          while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
            next = next.nextSibling;
          }
          return next;
        },
        /**
         * Replaces 2 or more successive <br> elements with a single <p>.
         * Whitespace between <br> elements are ignored. For example:
         *   <div>foo<br>bar<br> <br><br>abc</div>
         * will become:
         *   <div>foo<br>bar<p>abc</p></div>
         */
        _replaceBrs(elem) {
          this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
            var next = br.nextSibling;
            var replaced = false;
            while ((next = this._nextNode(next)) && next.tagName == "BR") {
              replaced = true;
              var brSibling = next.nextSibling;
              next.remove();
              next = brSibling;
            }
            if (replaced) {
              var p = this._doc.createElement("p");
              br.parentNode.replaceChild(p, br);
              next = p.nextSibling;
              while (next) {
                if (next.tagName == "BR") {
                  var nextElem = this._nextNode(next.nextSibling);
                  if (nextElem && nextElem.tagName == "BR") {
                    break;
                  }
                }
                if (!this._isPhrasingContent(next)) {
                  break;
                }
                var sibling = next.nextSibling;
                p.appendChild(next);
                next = sibling;
              }
              while (p.lastChild && this._isWhitespace(p.lastChild)) {
                p.lastChild.remove();
              }
              if (p.parentNode.tagName === "P") {
                this._setNodeTag(p.parentNode, "DIV");
              }
            }
          });
        },
        _setNodeTag(node, tag) {
          this.log("_setNodeTag", node, tag);
          if (this._docJSDOMParser) {
            node.localName = tag.toLowerCase();
            node.tagName = tag.toUpperCase();
            return node;
          }
          var replacement = node.ownerDocument.createElement(tag);
          while (node.firstChild) {
            replacement.appendChild(node.firstChild);
          }
          node.parentNode.replaceChild(replacement, node);
          if (node.readability) {
            replacement.readability = node.readability;
          }
          for (var i = 0; i < node.attributes.length; i++) {
            replacement.setAttributeNode(node.attributes[i].cloneNode());
          }
          return replacement;
        },
        /**
         * Prepare the article node for display. Clean out any inline styles,
         * iframes, forms, strip extraneous <p> tags, etc.
         *
         * @param Element
         * @return void
         **/
        _prepArticle(articleContent) {
          this._cleanStyles(articleContent);
          this._markDataTables(articleContent);
          this._fixLazyImages(articleContent);
          this._cleanConditionally(articleContent, "form");
          this._cleanConditionally(articleContent, "fieldset");
          this._clean(articleContent, "object");
          this._clean(articleContent, "embed");
          this._clean(articleContent, "footer");
          this._clean(articleContent, "link");
          this._clean(articleContent, "aside");
          var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
          this._forEachNode(articleContent.children, function(topCandidate) {
            this._cleanMatchedNodes(topCandidate, function(node, matchString) {
              return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
            });
          });
          this._clean(articleContent, "iframe");
          this._clean(articleContent, "input");
          this._clean(articleContent, "textarea");
          this._clean(articleContent, "select");
          this._clean(articleContent, "button");
          this._cleanHeaders(articleContent);
          this._cleanConditionally(articleContent, "table");
          this._cleanConditionally(articleContent, "ul");
          this._cleanConditionally(articleContent, "div");
          this._replaceNodeTags(
            this._getAllNodesWithTag(articleContent, ["h1"]),
            "h2"
          );
          this._removeNodes(
            this._getAllNodesWithTag(articleContent, ["p"]),
            function(paragraph) {
              var contentElementCount = this._getAllNodesWithTag(paragraph, [
                "img",
                "embed",
                "object",
                "iframe"
              ]).length;
              return contentElementCount === 0 && !this._getInnerText(paragraph, false);
            }
          );
          this._forEachNode(
            this._getAllNodesWithTag(articleContent, ["br"]),
            function(br) {
              var next = this._nextNode(br.nextSibling);
              if (next && next.tagName == "P") {
                br.remove();
              }
            }
          );
          this._forEachNode(
            this._getAllNodesWithTag(articleContent, ["table"]),
            function(table) {
              var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
              if (this._hasSingleTagInsideElement(tbody, "TR")) {
                var row = tbody.firstElementChild;
                if (this._hasSingleTagInsideElement(row, "TD")) {
                  var cell = row.firstElementChild;
                  cell = this._setNodeTag(
                    cell,
                    this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV"
                  );
                  table.parentNode.replaceChild(cell, table);
                }
              }
            }
          );
        },
        /**
         * Initialize a node with the readability object. Also checks the
         * className/id for special names to add to its score.
         *
         * @param Element
         * @return void
         **/
        _initializeNode(node) {
          node.readability = { contentScore: 0 };
          switch (node.tagName) {
            case "DIV":
              node.readability.contentScore += 5;
              break;
            case "PRE":
            case "TD":
            case "BLOCKQUOTE":
              node.readability.contentScore += 3;
              break;
            case "ADDRESS":
            case "OL":
            case "UL":
            case "DL":
            case "DD":
            case "DT":
            case "LI":
            case "FORM":
              node.readability.contentScore -= 3;
              break;
            case "H1":
            case "H2":
            case "H3":
            case "H4":
            case "H5":
            case "H6":
            case "TH":
              node.readability.contentScore -= 5;
              break;
          }
          node.readability.contentScore += this._getClassWeight(node);
        },
        _removeAndGetNext(node) {
          var nextNode = this._getNextNode(node, true);
          node.remove();
          return nextNode;
        },
        /**
         * Traverse the DOM from node to node, starting at the node passed in.
         * Pass true for the second parameter to indicate this node itself
         * (and its kids) are going away, and we want the next node over.
         *
         * Calling this in a loop will traverse the DOM depth-first.
         *
         * @param {Element} node
         * @param {boolean} ignoreSelfAndKids
         * @return {Element}
         */
        _getNextNode(node, ignoreSelfAndKids) {
          if (!ignoreSelfAndKids && node.firstElementChild) {
            return node.firstElementChild;
          }
          if (node.nextElementSibling) {
            return node.nextElementSibling;
          }
          do {
            node = node.parentNode;
          } while (node && !node.nextElementSibling);
          return node && node.nextElementSibling;
        },
        // compares second text to first one
        // 1 = same text, 0 = completely different text
        // works the way that it splits both texts into words and then finds words that are unique in second text
        // the result is given by the lower length of unique parts
        _textSimilarity(textA, textB) {
          var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
          var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
          if (!tokensA.length || !tokensB.length) {
            return 0;
          }
          var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
          var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
          return 1 - distanceB;
        },
        /**
         * Checks whether an element node contains a valid byline
         *
         * @param node {Element}
         * @param matchString {string}
         * @return boolean
         */
        _isValidByline(node, matchString) {
          var rel = node.getAttribute("rel");
          var itemprop = node.getAttribute("itemprop");
          var bylineLength = node.textContent.trim().length;
          return (rel === "author" || itemprop && itemprop.includes("author") || this.REGEXPS.byline.test(matchString)) && !!bylineLength && bylineLength < 100;
        },
        _getNodeAncestors(node, maxDepth) {
          maxDepth = maxDepth || 0;
          var i = 0, ancestors = [];
          while (node.parentNode) {
            ancestors.push(node.parentNode);
            if (maxDepth && ++i === maxDepth) {
              break;
            }
            node = node.parentNode;
          }
          return ancestors;
        },
        /***
         * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
         *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
         *
         * @param page a document to run upon. Needs to be a full document, complete with body.
         * @return Element
         **/
        /* eslint-disable-next-line complexity */
        _grabArticle(page) {
          this.log("**** grabArticle ****");
          var doc = this._doc;
          var isPaging = page !== null;
          page = page ? page : this._doc.body;
          if (!page) {
            this.log("No body found in document. Abort.");
            return null;
          }
          var pageCacheHtml = page.innerHTML;
          while (true) {
            this.log("Starting grabArticle loop");
            var stripUnlikelyCandidates = this._flagIsActive(
              this.FLAG_STRIP_UNLIKELYS
            );
            var elementsToScore = [];
            var node = this._doc.documentElement;
            let shouldRemoveTitleHeader = true;
            while (node) {
              if (node.tagName === "HTML") {
                this._articleLang = node.getAttribute("lang");
              }
              var matchString = node.className + " " + node.id;
              if (!this._isProbablyVisible(node)) {
                this.log("Removing hidden node - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
              if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
                node = this._removeAndGetNext(node);
                continue;
              }
              if (!this._articleByline && !this._metadata.byline && this._isValidByline(node, matchString)) {
                var endOfSearchMarkerNode = this._getNextNode(node, true);
                var next = this._getNextNode(node);
                var itemPropNameNode = null;
                while (next && next != endOfSearchMarkerNode) {
                  var itemprop = next.getAttribute("itemprop");
                  if (itemprop && itemprop.includes("name")) {
                    itemPropNameNode = next;
                    break;
                  } else {
                    next = this._getNextNode(next);
                  }
                }
                this._articleByline = (itemPropNameNode ?? node).textContent.trim();
                node = this._removeAndGetNext(node);
                continue;
              }
              if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
                this.log(
                  "Removing header: ",
                  node.textContent.trim(),
                  this._articleTitle.trim()
                );
                shouldRemoveTitleHeader = false;
                node = this._removeAndGetNext(node);
                continue;
              }
              if (stripUnlikelyCandidates) {
                if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
                  this.log("Removing unlikely candidate - " + matchString);
                  node = this._removeAndGetNext(node);
                  continue;
                }
                if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
                  this.log(
                    "Removing content with role " + node.getAttribute("role") + " - " + matchString
                  );
                  node = this._removeAndGetNext(node);
                  continue;
                }
              }
              if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this.DEFAULT_TAGS_TO_SCORE.includes(node.tagName)) {
                elementsToScore.push(node);
              }
              if (node.tagName === "DIV") {
                var p = null;
                var childNode = node.firstChild;
                while (childNode) {
                  var nextSibling = childNode.nextSibling;
                  if (this._isPhrasingContent(childNode)) {
                    if (p !== null) {
                      p.appendChild(childNode);
                    } else if (!this._isWhitespace(childNode)) {
                      p = doc.createElement("p");
                      node.replaceChild(p, childNode);
                      p.appendChild(childNode);
                    }
                  } else if (p !== null) {
                    while (p.lastChild && this._isWhitespace(p.lastChild)) {
                      p.lastChild.remove();
                    }
                    p = null;
                  }
                  childNode = nextSibling;
                }
                if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
                  var newNode = node.children[0];
                  node.parentNode.replaceChild(newNode, node);
                  node = newNode;
                  elementsToScore.push(node);
                } else if (!this._hasChildBlockElement(node)) {
                  node = this._setNodeTag(node, "P");
                  elementsToScore.push(node);
                }
              }
              node = this._getNextNode(node);
            }
            var candidates = [];
            this._forEachNode(elementsToScore, function(elementToScore) {
              if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined") {
                return;
              }
              var innerText = this._getInnerText(elementToScore);
              if (innerText.length < 25) {
                return;
              }
              var ancestors2 = this._getNodeAncestors(elementToScore, 5);
              if (ancestors2.length === 0) {
                return;
              }
              var contentScore = 0;
              contentScore += 1;
              contentScore += innerText.split(this.REGEXPS.commas).length;
              contentScore += Math.min(Math.floor(innerText.length / 100), 3);
              this._forEachNode(ancestors2, function(ancestor, level) {
                if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined") {
                  return;
                }
                if (typeof ancestor.readability === "undefined") {
                  this._initializeNode(ancestor);
                  candidates.push(ancestor);
                }
                if (level === 0) {
                  var scoreDivider = 1;
                } else if (level === 1) {
                  scoreDivider = 2;
                } else {
                  scoreDivider = level * 3;
                }
                ancestor.readability.contentScore += contentScore / scoreDivider;
              });
            });
            var topCandidates = [];
            for (var c = 0, cl = candidates.length; c < cl; c += 1) {
              var candidate = candidates[c];
              var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
              candidate.readability.contentScore = candidateScore;
              this.log("Candidate:", candidate, "with score " + candidateScore);
              for (var t = 0; t < this._nbTopCandidates; t++) {
                var aTopCandidate = topCandidates[t];
                if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
                  topCandidates.splice(t, 0, candidate);
                  if (topCandidates.length > this._nbTopCandidates) {
                    topCandidates.pop();
                  }
                  break;
                }
              }
            }
            var topCandidate = topCandidates[0] || null;
            var neededToCreateTopCandidate = false;
            var parentOfTopCandidate;
            if (topCandidate === null || topCandidate.tagName === "BODY") {
              topCandidate = doc.createElement("DIV");
              neededToCreateTopCandidate = true;
              while (page.firstChild) {
                this.log("Moving child out:", page.firstChild);
                topCandidate.appendChild(page.firstChild);
              }
              page.appendChild(topCandidate);
              this._initializeNode(topCandidate);
            } else if (topCandidate) {
              var alternativeCandidateAncestors = [];
              for (var i = 1; i < topCandidates.length; i++) {
                if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
                  alternativeCandidateAncestors.push(
                    this._getNodeAncestors(topCandidates[i])
                  );
                }
              }
              var MINIMUM_TOPCANDIDATES = 3;
              if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
                parentOfTopCandidate = topCandidate.parentNode;
                while (parentOfTopCandidate.tagName !== "BODY") {
                  var listsContainingThisAncestor = 0;
                  for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
                    listsContainingThisAncestor += Number(
                      alternativeCandidateAncestors[ancestorIndex].includes(
                        parentOfTopCandidate
                      )
                    );
                  }
                  if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
                    topCandidate = parentOfTopCandidate;
                    break;
                  }
                  parentOfTopCandidate = parentOfTopCandidate.parentNode;
                }
              }
              if (!topCandidate.readability) {
                this._initializeNode(topCandidate);
              }
              parentOfTopCandidate = topCandidate.parentNode;
              var lastScore = topCandidate.readability.contentScore;
              var scoreThreshold = lastScore / 3;
              while (parentOfTopCandidate.tagName !== "BODY") {
                if (!parentOfTopCandidate.readability) {
                  parentOfTopCandidate = parentOfTopCandidate.parentNode;
                  continue;
                }
                var parentScore = parentOfTopCandidate.readability.contentScore;
                if (parentScore < scoreThreshold) {
                  break;
                }
                if (parentScore > lastScore) {
                  topCandidate = parentOfTopCandidate;
                  break;
                }
                lastScore = parentOfTopCandidate.readability.contentScore;
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
              }
              parentOfTopCandidate = topCandidate.parentNode;
              while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
                topCandidate = parentOfTopCandidate;
                parentOfTopCandidate = topCandidate.parentNode;
              }
              if (!topCandidate.readability) {
                this._initializeNode(topCandidate);
              }
            }
            var articleContent = doc.createElement("DIV");
            if (isPaging) {
              articleContent.id = "readability-content";
            }
            var siblingScoreThreshold = Math.max(
              10,
              topCandidate.readability.contentScore * 0.2
            );
            parentOfTopCandidate = topCandidate.parentNode;
            var siblings = parentOfTopCandidate.children;
            for (var s = 0, sl = siblings.length; s < sl; s++) {
              var sibling = siblings[s];
              var append = false;
              this.log(
                "Looking at sibling node:",
                sibling,
                sibling.readability ? "with score " + sibling.readability.contentScore : ""
              );
              this.log(
                "Sibling has score",
                sibling.readability ? sibling.readability.contentScore : "Unknown"
              );
              if (sibling === topCandidate) {
                append = true;
              } else {
                var contentBonus = 0;
                if (sibling.className === topCandidate.className && topCandidate.className !== "") {
                  contentBonus += topCandidate.readability.contentScore * 0.2;
                }
                if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
                  append = true;
                } else if (sibling.nodeName === "P") {
                  var linkDensity = this._getLinkDensity(sibling);
                  var nodeContent = this._getInnerText(sibling);
                  var nodeLength = nodeContent.length;
                  if (nodeLength > 80 && linkDensity < 0.25) {
                    append = true;
                  } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
                    append = true;
                  }
                }
              }
              if (append) {
                this.log("Appending node:", sibling);
                if (!this.ALTER_TO_DIV_EXCEPTIONS.includes(sibling.nodeName)) {
                  this.log("Altering sibling:", sibling, "to div.");
                  sibling = this._setNodeTag(sibling, "DIV");
                }
                articleContent.appendChild(sibling);
                siblings = parentOfTopCandidate.children;
                s -= 1;
                sl -= 1;
              }
            }
            if (this._debug) {
              this.log("Article content pre-prep: " + articleContent.innerHTML);
            }
            this._prepArticle(articleContent);
            if (this._debug) {
              this.log("Article content post-prep: " + articleContent.innerHTML);
            }
            if (neededToCreateTopCandidate) {
              topCandidate.id = "readability-page-1";
              topCandidate.className = "page";
            } else {
              var div = doc.createElement("DIV");
              div.id = "readability-page-1";
              div.className = "page";
              while (articleContent.firstChild) {
                div.appendChild(articleContent.firstChild);
              }
              articleContent.appendChild(div);
            }
            if (this._debug) {
              this.log("Article content after paging: " + articleContent.innerHTML);
            }
            var parseSuccessful = true;
            var textLength = this._getInnerText(articleContent, true).length;
            if (textLength < this._charThreshold) {
              parseSuccessful = false;
              page.innerHTML = pageCacheHtml;
              this._attempts.push({
                articleContent,
                textLength
              });
              if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
                this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
              } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
                this._removeFlag(this.FLAG_WEIGHT_CLASSES);
              } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
                this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
              } else {
                this._attempts.sort(function(a, b) {
                  return b.textLength - a.textLength;
                });
                if (!this._attempts[0].textLength) {
                  return null;
                }
                articleContent = this._attempts[0].articleContent;
                parseSuccessful = true;
              }
            }
            if (parseSuccessful) {
              var ancestors = [parentOfTopCandidate, topCandidate].concat(
                this._getNodeAncestors(parentOfTopCandidate)
              );
              this._someNode(ancestors, function(ancestor) {
                if (!ancestor.tagName) {
                  return false;
                }
                var articleDir = ancestor.getAttribute("dir");
                if (articleDir) {
                  this._articleDir = articleDir;
                  return true;
                }
                return false;
              });
              return articleContent;
            }
          }
        },
        /**
         * Converts some of the common HTML entities in string to their corresponding characters.
         *
         * @param str {string} - a string to unescape.
         * @return string without HTML entity.
         */
        _unescapeHtmlEntities(str) {
          if (!str) {
            return str;
          }
          var htmlEscapeMap = this.HTML_ESCAPE_MAP;
          return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {
            return htmlEscapeMap[tag];
          }).replace(/&#(?:x([0-9a-f]+)|([0-9]+));/gi, function(_, hex3, numStr) {
            var num = parseInt(hex3 || numStr, hex3 ? 16 : 10);
            if (num == 0 || num > 1114111 || num >= 55296 && num <= 57343) {
              num = 65533;
            }
            return String.fromCodePoint(num);
          });
        },
        /**
         * Try to extract metadata from JSON-LD object.
         * For now, only Schema.org objects of type Article or its subtypes are supported.
         * @return Object with any metadata that could be extracted (possibly none)
         */
        _getJSONLD(doc) {
          var scripts = this._getAllNodesWithTag(doc, ["script"]);
          var metadata;
          this._forEachNode(scripts, function(jsonLdElement) {
            if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
              try {
                var content = jsonLdElement.textContent.replace(
                  /^\s*<!\[CDATA\[|\]\]>\s*$/g,
                  ""
                );
                var parsed = JSON.parse(content);
                if (Array.isArray(parsed)) {
                  parsed = parsed.find((it) => {
                    return it["@type"] && it["@type"].match(this.REGEXPS.jsonLdArticleTypes);
                  });
                  if (!parsed) {
                    return;
                  }
                }
                var schemaDotOrgRegex = /^https?\:\/\/schema\.org\/?$/;
                var matches = typeof parsed["@context"] === "string" && parsed["@context"].match(schemaDotOrgRegex) || typeof parsed["@context"] === "object" && typeof parsed["@context"]["@vocab"] == "string" && parsed["@context"]["@vocab"].match(schemaDotOrgRegex);
                if (!matches) {
                  return;
                }
                if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
                  parsed = parsed["@graph"].find((it) => {
                    return (it["@type"] || "").match(this.REGEXPS.jsonLdArticleTypes);
                  });
                }
                if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
                  return;
                }
                metadata = {};
                if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
                  var title = this._getArticleTitle();
                  var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
                  var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
                  if (headlineMatches && !nameMatches) {
                    metadata.title = parsed.headline;
                  } else {
                    metadata.title = parsed.name;
                  }
                } else if (typeof parsed.name === "string") {
                  metadata.title = parsed.name.trim();
                } else if (typeof parsed.headline === "string") {
                  metadata.title = parsed.headline.trim();
                }
                if (parsed.author) {
                  if (typeof parsed.author.name === "string") {
                    metadata.byline = parsed.author.name.trim();
                  } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
                    metadata.byline = parsed.author.filter(function(author) {
                      return author && typeof author.name === "string";
                    }).map(function(author) {
                      return author.name.trim();
                    }).join(", ");
                  }
                }
                if (typeof parsed.description === "string") {
                  metadata.excerpt = parsed.description.trim();
                }
                if (parsed.publisher && typeof parsed.publisher.name === "string") {
                  metadata.siteName = parsed.publisher.name.trim();
                }
                if (typeof parsed.datePublished === "string") {
                  metadata.datePublished = parsed.datePublished.trim();
                }
              } catch (err) {
                this.log(err.message);
              }
            }
          });
          return metadata ? metadata : {};
        },
        /**
         * Attempts to get excerpt and byline metadata for the article.
         *
         * @param {Object} jsonld  object containing any metadata that
         * could be extracted from JSON-LD object.
         *
         * @return Object with optional "excerpt" and "byline" properties
         */
        _getArticleMetadata(jsonld) {
          var metadata = {};
          var values = {};
          var metaElements = this._doc.getElementsByTagName("meta");
          var propertyPattern = /\s*(article|dc|dcterm|og|twitter)\s*:\s*(author|creator|description|published_time|title|site_name)\s*/gi;
          var namePattern = /^\s*(?:(dc|dcterm|og|twitter|parsely|weibo:(article|webpage))\s*[-\.:]\s*)?(author|creator|pub-date|description|title|site_name)\s*$/i;
          this._forEachNode(metaElements, function(element) {
            var elementName = element.getAttribute("name");
            var elementProperty = element.getAttribute("property");
            var content = element.getAttribute("content");
            if (!content) {
              return;
            }
            var matches = null;
            var name = null;
            if (elementProperty) {
              matches = elementProperty.match(propertyPattern);
              if (matches) {
                name = matches[0].toLowerCase().replace(/\s/g, "");
                values[name] = content.trim();
              }
            }
            if (!matches && elementName && namePattern.test(elementName)) {
              name = elementName;
              if (content) {
                name = name.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
                values[name] = content.trim();
              }
            }
          });
          metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values.title || values["twitter:title"] || values["parsely-title"];
          if (!metadata.title) {
            metadata.title = this._getArticleTitle();
          }
          const articleAuthor = typeof values["article:author"] === "string" && !this._isUrl(values["article:author"]) ? values["article:author"] : void 0;
          metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values.author || values["parsely-author"] || articleAuthor;
          metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values.description || values["twitter:description"];
          metadata.siteName = jsonld.siteName || values["og:site_name"];
          metadata.publishedTime = jsonld.datePublished || values["article:published_time"] || values["parsely-pub-date"] || null;
          metadata.title = this._unescapeHtmlEntities(metadata.title);
          metadata.byline = this._unescapeHtmlEntities(metadata.byline);
          metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
          metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
          metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);
          return metadata;
        },
        /**
         * Check if node is image, or if node contains exactly only one image
         * whether as a direct child or as its descendants.
         *
         * @param Element
         **/
        _isSingleImage(node) {
          while (node) {
            if (node.tagName === "IMG") {
              return true;
            }
            if (node.children.length !== 1 || node.textContent.trim() !== "") {
              return false;
            }
            node = node.children[0];
          }
          return false;
        },
        /**
         * Find all <noscript> that are located after <img> nodes, and which contain only one
         * <img> element. Replace the first image with the image from inside the <noscript> tag,
         * and remove the <noscript> tag. This improves the quality of the images we use on
         * some sites (e.g. Medium).
         *
         * @param Element
         **/
        _unwrapNoscriptImages(doc) {
          var imgs = Array.from(doc.getElementsByTagName("img"));
          this._forEachNode(imgs, function(img) {
            for (var i = 0; i < img.attributes.length; i++) {
              var attr = img.attributes[i];
              switch (attr.name) {
                case "src":
                case "srcset":
                case "data-src":
                case "data-srcset":
                  return;
              }
              if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                return;
              }
            }
            img.remove();
          });
          var noscripts = Array.from(doc.getElementsByTagName("noscript"));
          this._forEachNode(noscripts, function(noscript) {
            if (!this._isSingleImage(noscript)) {
              return;
            }
            var tmp = doc.createElement("div");
            tmp.innerHTML = noscript.innerHTML;
            var prevElement = noscript.previousElementSibling;
            if (prevElement && this._isSingleImage(prevElement)) {
              var prevImg = prevElement;
              if (prevImg.tagName !== "IMG") {
                prevImg = prevElement.getElementsByTagName("img")[0];
              }
              var newImg = tmp.getElementsByTagName("img")[0];
              for (var i = 0; i < prevImg.attributes.length; i++) {
                var attr = prevImg.attributes[i];
                if (attr.value === "") {
                  continue;
                }
                if (attr.name === "src" || attr.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                  if (newImg.getAttribute(attr.name) === attr.value) {
                    continue;
                  }
                  var attrName = attr.name;
                  if (newImg.hasAttribute(attrName)) {
                    attrName = "data-old-" + attrName;
                  }
                  newImg.setAttribute(attrName, attr.value);
                }
              }
              noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
            }
          });
        },
        /**
         * Removes script tags from the document.
         *
         * @param Element
         **/
        _removeScripts(doc) {
          this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
        },
        /**
         * Check if this node has only whitespace and a single element with given tag
         * Returns false if the DIV node contains non-empty text nodes
         * or if it contains no element with given tag or more than 1 element.
         *
         * @param Element
         * @param string tag of child element
         **/
        _hasSingleTagInsideElement(element, tag) {
          if (element.children.length != 1 || element.children[0].tagName !== tag) {
            return false;
          }
          return !this._someNode(element.childNodes, function(node) {
            return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
          });
        },
        _isElementWithoutContent(node) {
          return node.nodeType === this.ELEMENT_NODE && !node.textContent.trim().length && (!node.children.length || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
        },
        /**
         * Determine whether element has any children block level elements.
         *
         * @param Element
         */
        _hasChildBlockElement(element) {
          return this._someNode(element.childNodes, function(node) {
            return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
          });
        },
        /***
         * Determine if a node qualifies as phrasing content.
         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
         **/
        _isPhrasingContent(node) {
          return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.includes(node.tagName) || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
        },
        _isWhitespace(node) {
          return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
        },
        /**
         * Get the inner text of a node - cross browser compatibly.
         * This also strips out any excess whitespace to be found.
         *
         * @param Element
         * @param Boolean normalizeSpaces (default: true)
         * @return string
         **/
        _getInnerText(e, normalizeSpaces) {
          normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
          var textContent = e.textContent.trim();
          if (normalizeSpaces) {
            return textContent.replace(this.REGEXPS.normalize, " ");
          }
          return textContent;
        },
        /**
         * Get the number of times a string s appears in the node e.
         *
         * @param Element
         * @param string - what to split on. Default is ","
         * @return number (integer)
         **/
        _getCharCount(e, s) {
          s = s || ",";
          return this._getInnerText(e).split(s).length - 1;
        },
        /**
         * Remove the style attribute on every e and under.
         * TODO: Test if getElementsByTagName(*) is faster.
         *
         * @param Element
         * @return void
         **/
        _cleanStyles(e) {
          if (!e || e.tagName.toLowerCase() === "svg") {
            return;
          }
          for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
            e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
          }
          if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.includes(e.tagName)) {
            e.removeAttribute("width");
            e.removeAttribute("height");
          }
          var cur = e.firstElementChild;
          while (cur !== null) {
            this._cleanStyles(cur);
            cur = cur.nextElementSibling;
          }
        },
        /**
         * Get the density of links as a percentage of the content
         * This is the amount of text that is inside a link divided by the total text in the node.
         *
         * @param Element
         * @return number (float)
         **/
        _getLinkDensity(element) {
          var textLength = this._getInnerText(element).length;
          if (textLength === 0) {
            return 0;
          }
          var linkLength = 0;
          this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
            var href = linkNode.getAttribute("href");
            var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
            linkLength += this._getInnerText(linkNode).length * coefficient;
          });
          return linkLength / textLength;
        },
        /**
         * Get an elements class/id weight. Uses regular expressions to tell if this
         * element looks good or bad.
         *
         * @param Element
         * @return number (Integer)
         **/
        _getClassWeight(e) {
          if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
            return 0;
          }
          var weight = 0;
          if (typeof e.className === "string" && e.className !== "") {
            if (this.REGEXPS.negative.test(e.className)) {
              weight -= 25;
            }
            if (this.REGEXPS.positive.test(e.className)) {
              weight += 25;
            }
          }
          if (typeof e.id === "string" && e.id !== "") {
            if (this.REGEXPS.negative.test(e.id)) {
              weight -= 25;
            }
            if (this.REGEXPS.positive.test(e.id)) {
              weight += 25;
            }
          }
          return weight;
        },
        /**
         * Clean a node of all elements of type "tag".
         * (Unless it's a youtube/vimeo video. People love movies.)
         *
         * @param Element
         * @param string tag to clean
         * @return void
         **/
        _clean(e, tag) {
          var isEmbed = ["object", "embed", "iframe"].includes(tag);
          this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {
            if (isEmbed) {
              for (var i = 0; i < element.attributes.length; i++) {
                if (this._allowedVideoRegex.test(element.attributes[i].value)) {
                  return false;
                }
              }
              if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
                return false;
              }
            }
            return true;
          });
        },
        /**
         * Check if a given node has one of its ancestor tag name matching the
         * provided one.
         * @param  HTMLElement node
         * @param  String      tagName
         * @param  Number      maxDepth
         * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
         * @return Boolean
         */
        _hasAncestorTag(node, tagName, maxDepth, filterFn) {
          maxDepth = maxDepth || 3;
          tagName = tagName.toUpperCase();
          var depth = 0;
          while (node.parentNode) {
            if (maxDepth > 0 && depth > maxDepth) {
              return false;
            }
            if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode))) {
              return true;
            }
            node = node.parentNode;
            depth++;
          }
          return false;
        },
        /**
         * Return an object indicating how many rows and columns this table has.
         */
        _getRowAndColumnCount(table) {
          var rows = 0;
          var columns = 0;
          var trs = table.getElementsByTagName("tr");
          for (var i = 0; i < trs.length; i++) {
            var rowspan = trs[i].getAttribute("rowspan") || 0;
            if (rowspan) {
              rowspan = parseInt(rowspan, 10);
            }
            rows += rowspan || 1;
            var columnsInThisRow = 0;
            var cells = trs[i].getElementsByTagName("td");
            for (var j = 0; j < cells.length; j++) {
              var colspan = cells[j].getAttribute("colspan") || 0;
              if (colspan) {
                colspan = parseInt(colspan, 10);
              }
              columnsInThisRow += colspan || 1;
            }
            columns = Math.max(columns, columnsInThisRow);
          }
          return { rows, columns };
        },
        /**
         * Look for 'data' (as opposed to 'layout') tables, for which we use
         * similar checks as
         * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
         */
        _markDataTables(root) {
          var tables = root.getElementsByTagName("table");
          for (var i = 0; i < tables.length; i++) {
            var table = tables[i];
            var role = table.getAttribute("role");
            if (role == "presentation") {
              table._readabilityDataTable = false;
              continue;
            }
            var datatable = table.getAttribute("datatable");
            if (datatable == "0") {
              table._readabilityDataTable = false;
              continue;
            }
            var summary = table.getAttribute("summary");
            if (summary) {
              table._readabilityDataTable = true;
              continue;
            }
            var caption = table.getElementsByTagName("caption")[0];
            if (caption && caption.childNodes.length) {
              table._readabilityDataTable = true;
              continue;
            }
            var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
            var descendantExists = function(tag) {
              return !!table.getElementsByTagName(tag)[0];
            };
            if (dataTableDescendants.some(descendantExists)) {
              this.log("Data table because found data-y descendant");
              table._readabilityDataTable = true;
              continue;
            }
            if (table.getElementsByTagName("table")[0]) {
              table._readabilityDataTable = false;
              continue;
            }
            var sizeInfo = this._getRowAndColumnCount(table);
            if (sizeInfo.columns == 1 || sizeInfo.rows == 1) {
              table._readabilityDataTable = false;
              continue;
            }
            if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
              table._readabilityDataTable = true;
              continue;
            }
            table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
          }
        },
        /* convert images and figures that have properties like data-src into images that can be loaded without JS */
        _fixLazyImages(root) {
          this._forEachNode(
            this._getAllNodesWithTag(root, ["img", "picture", "figure"]),
            function(elem) {
              if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
                var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
                if (parts[1] === "image/svg+xml") {
                  return;
                }
                var srcCouldBeRemoved = false;
                for (var i = 0; i < elem.attributes.length; i++) {
                  var attr = elem.attributes[i];
                  if (attr.name === "src") {
                    continue;
                  }
                  if (/\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
                    srcCouldBeRemoved = true;
                    break;
                  }
                }
                if (srcCouldBeRemoved) {
                  var b64starts = parts[0].length;
                  var b64length = elem.src.length - b64starts;
                  if (b64length < 133) {
                    elem.removeAttribute("src");
                  }
                }
              }
              if ((elem.src || elem.srcset && elem.srcset != "null") && !elem.className.toLowerCase().includes("lazy")) {
                return;
              }
              for (var j = 0; j < elem.attributes.length; j++) {
                attr = elem.attributes[j];
                if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
                  continue;
                }
                var copyTo = null;
                if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr.value)) {
                  copyTo = "srcset";
                } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr.value)) {
                  copyTo = "src";
                }
                if (copyTo) {
                  if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
                    elem.setAttribute(copyTo, attr.value);
                  } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
                    var img = this._doc.createElement("img");
                    img.setAttribute(copyTo, attr.value);
                    elem.appendChild(img);
                  }
                }
              }
            }
          );
        },
        _getTextDensity(e, tags) {
          var textLength = this._getInnerText(e, true).length;
          if (textLength === 0) {
            return 0;
          }
          var childrenLength = 0;
          var children = this._getAllNodesWithTag(e, tags);
          this._forEachNode(
            children,
            (child) => childrenLength += this._getInnerText(child, true).length
          );
          return childrenLength / textLength;
        },
        /**
         * Clean an element of all tags of type "tag" if they look fishy.
         * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
         *
         * @return void
         **/
        _cleanConditionally(e, tag) {
          if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
            return;
          }
          this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {
            var isDataTable = function(t) {
              return t._readabilityDataTable;
            };
            var isList = tag === "ul" || tag === "ol";
            if (!isList) {
              var listLength = 0;
              var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
              this._forEachNode(
                listNodes,
                (list) => listLength += this._getInnerText(list).length
              );
              isList = listLength / this._getInnerText(node).length > 0.9;
            }
            if (tag === "table" && isDataTable(node)) {
              return false;
            }
            if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
              return false;
            }
            if (this._hasAncestorTag(node, "code")) {
              return false;
            }
            if ([...node.getElementsByTagName("table")].some(
              (tbl) => tbl._readabilityDataTable
            )) {
              return false;
            }
            var weight = this._getClassWeight(node);
            this.log("Cleaning Conditionally", node);
            var contentScore = 0;
            if (weight + contentScore < 0) {
              return true;
            }
            if (this._getCharCount(node, ",") < 10) {
              var p = node.getElementsByTagName("p").length;
              var img = node.getElementsByTagName("img").length;
              var li = node.getElementsByTagName("li").length - 100;
              var input = node.getElementsByTagName("input").length;
              var headingDensity = this._getTextDensity(node, [
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6"
              ]);
              var embedCount = 0;
              var embeds = this._getAllNodesWithTag(node, [
                "object",
                "embed",
                "iframe"
              ]);
              for (var i = 0; i < embeds.length; i++) {
                for (var j = 0; j < embeds[i].attributes.length; j++) {
                  if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {
                    return false;
                  }
                }
                if (embeds[i].tagName === "object" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {
                  return false;
                }
                embedCount++;
              }
              var innerText = this._getInnerText(node);
              if (this.REGEXPS.adWords.test(innerText) || this.REGEXPS.loadingWords.test(innerText)) {
                return true;
              }
              var contentLength = innerText.length;
              var linkDensity = this._getLinkDensity(node);
              var textishTags = ["SPAN", "LI", "TD"].concat(
                Array.from(this.DIV_TO_P_ELEMS)
              );
              var textDensity = this._getTextDensity(node, textishTags);
              var isFigureChild = this._hasAncestorTag(node, "figure");
              const shouldRemoveNode = () => {
                const errs = [];
                if (!isFigureChild && img > 1 && p / img < 0.5) {
                  errs.push(`Bad p to img ratio (img=${img}, p=${p})`);
                }
                if (!isList && li > p) {
                  errs.push(`Too many li's outside of a list. (li=${li} > p=${p})`);
                }
                if (input > Math.floor(p / 3)) {
                  errs.push(`Too many inputs per p. (input=${input}, p=${p})`);
                }
                if (!isList && !isFigureChild && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && linkDensity > 0) {
                  errs.push(
                    `Suspiciously short. (headingDensity=${headingDensity}, img=${img}, linkDensity=${linkDensity})`
                  );
                }
                if (!isList && weight < 25 && linkDensity > 0.2 + this._linkDensityModifier) {
                  errs.push(
                    `Low weight and a little linky. (linkDensity=${linkDensity})`
                  );
                }
                if (weight >= 25 && linkDensity > 0.5 + this._linkDensityModifier) {
                  errs.push(
                    `High weight and mostly links. (linkDensity=${linkDensity})`
                  );
                }
                if (embedCount === 1 && contentLength < 75 || embedCount > 1) {
                  errs.push(
                    `Suspicious embed. (embedCount=${embedCount}, contentLength=${contentLength})`
                  );
                }
                if (img === 0 && textDensity === 0) {
                  errs.push(
                    `No useful content. (img=${img}, textDensity=${textDensity})`
                  );
                }
                if (errs.length) {
                  this.log("Checks failed", errs);
                  return true;
                }
                return false;
              };
              var haveToRemove = shouldRemoveNode();
              if (isList && haveToRemove) {
                for (var x = 0; x < node.children.length; x++) {
                  let child = node.children[x];
                  if (child.children.length > 1) {
                    return haveToRemove;
                  }
                }
                let li_count = node.getElementsByTagName("li").length;
                if (img == li_count) {
                  return false;
                }
              }
              return haveToRemove;
            }
            return false;
          });
        },
        /**
         * Clean out elements that match the specified conditions
         *
         * @param Element
         * @param Function determines whether a node should be removed
         * @return void
         **/
        _cleanMatchedNodes(e, filter) {
          var endOfSearchMarkerNode = this._getNextNode(e, true);
          var next = this._getNextNode(e);
          while (next && next != endOfSearchMarkerNode) {
            if (filter.call(this, next, next.className + " " + next.id)) {
              next = this._removeAndGetNext(next);
            } else {
              next = this._getNextNode(next);
            }
          }
        },
        /**
         * Clean out spurious headers from an Element.
         *
         * @param Element
         * @return void
         **/
        _cleanHeaders(e) {
          let headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);
          this._removeNodes(headingNodes, function(node) {
            let shouldRemove = this._getClassWeight(node) < 0;
            if (shouldRemove) {
              this.log("Removing header with low class weight:", node);
            }
            return shouldRemove;
          });
        },
        /**
         * Check if this node is an H1 or H2 element whose content is mostly
         * the same as the article title.
         *
         * @param Element  the node to check.
         * @return boolean indicating whether this is a title-like header.
         */
        _headerDuplicatesTitle(node) {
          if (node.tagName != "H1" && node.tagName != "H2") {
            return false;
          }
          var heading = this._getInnerText(node, false);
          this.log("Evaluating similarity of header:", heading, this._articleTitle);
          return this._textSimilarity(this._articleTitle, heading) > 0.75;
        },
        _flagIsActive(flag) {
          return (this._flags & flag) > 0;
        },
        _removeFlag(flag) {
          this._flags = this._flags & ~flag;
        },
        _isProbablyVisible(node) {
          return (!node.style || node.style.display != "none") && (!node.style || node.style.visibility != "hidden") && !node.hasAttribute("hidden") && //check for "fallback-image" so that wikimedia math images are displayed
          (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.includes && node.className.includes("fallback-image"));
        },
        /**
         * Runs readability.
         *
         * Workflow:
         *  1. Prep the document by removing script tags, css, etc.
         *  2. Build readability's DOM tree.
         *  3. Grab the article content from the current dom tree.
         *  4. Replace the current DOM tree with the new one.
         *  5. Read peacefully.
         *
         * @return void
         **/
        parse() {
          if (this._maxElemsToParse > 0) {
            var numTags = this._doc.getElementsByTagName("*").length;
            if (numTags > this._maxElemsToParse) {
              throw new Error(
                "Aborting parsing document; " + numTags + " elements found"
              );
            }
          }
          this._unwrapNoscriptImages(this._doc);
          var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
          this._removeScripts(this._doc);
          this._prepDocument();
          var metadata = this._getArticleMetadata(jsonLd);
          this._metadata = metadata;
          this._articleTitle = metadata.title;
          var articleContent = this._grabArticle();
          if (!articleContent) {
            return null;
          }
          this.log("Grabbed: " + articleContent.innerHTML);
          this._postProcessContent(articleContent);
          if (!metadata.excerpt) {
            var paragraphs = articleContent.getElementsByTagName("p");
            if (paragraphs.length) {
              metadata.excerpt = paragraphs[0].textContent.trim();
            }
          }
          var textContent = articleContent.textContent;
          return {
            title: this._articleTitle,
            byline: metadata.byline || this._articleByline,
            dir: this._articleDir,
            lang: this._articleLang,
            content: this._serializer(articleContent),
            textContent,
            length: textContent.length,
            excerpt: metadata.excerpt,
            siteName: metadata.siteName || this._articleSiteName,
            publishedTime: metadata.publishedTime
          };
        }
      };
      if (typeof module === "object") {
        module.exports = Readability2;
      }
    }
  });

  // node_modules/@mozilla/readability/Readability-readerable.js
  var require_Readability_readerable = __commonJS({
    "node_modules/@mozilla/readability/Readability-readerable.js"(exports2, module) {
      var REGEXPS = {
        // NOTE: These two regular expressions are duplicated in
        // Readability.js. Please keep both copies in sync.
        unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
        okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
      };
      function isNodeVisible(node) {
        return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && //check for "fallback-image" so that wikimedia math images are displayed
        (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.includes && node.className.includes("fallback-image"));
      }
      function isProbablyReaderable(doc, options = {}) {
        if (typeof options == "function") {
          options = { visibilityChecker: options };
        }
        var defaultOptions3 = {
          minScore: 20,
          minContentLength: 140,
          visibilityChecker: isNodeVisible
        };
        options = Object.assign(defaultOptions3, options);
        var nodes = doc.querySelectorAll("p, pre, article");
        var brNodes = doc.querySelectorAll("div > br");
        if (brNodes.length) {
          var set2 = new Set(nodes);
          [].forEach.call(brNodes, function(node) {
            set2.add(node.parentNode);
          });
          nodes = Array.from(set2);
        }
        var score = 0;
        return [].some.call(nodes, function(node) {
          if (!options.visibilityChecker(node)) {
            return false;
          }
          var matchString = node.className + " " + node.id;
          if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
            return false;
          }
          if (node.matches("li p")) {
            return false;
          }
          var textContentLength = node.textContent.trim().length;
          if (textContentLength < options.minContentLength) {
            return false;
          }
          score += Math.sqrt(textContentLength - options.minContentLength);
          if (score > options.minScore) {
            return true;
          }
          return false;
        });
      }
      if (typeof module === "object") {
        module.exports = isProbablyReaderable;
      }
    }
  });

  // node_modules/@mozilla/readability/index.js
  var require_readability = __commonJS({
    "node_modules/@mozilla/readability/index.js"(exports2, module) {
      var Readability2 = require_Readability();
      var isProbablyReaderable = require_Readability_readerable();
      module.exports = {
        Readability: Readability2,
        isProbablyReaderable
      };
    }
  });

  // src/features/content/overlay-manager.js
  init_logger();

  // src/shared/logger-browser.js
  var Logger2 = class {
    constructor(context = "Browser") {
      this.context = context;
      this.logLevel = "debug";
    }
    getLogLevel() {
      return "debug";
    }
    shouldLog(level) {
      const levels = { debug: 0, info: 1, warn: 2, error: 3 };
      return levels[level] >= levels[this.logLevel];
    }
    formatMessage(level, message, ...args) {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString();
      const prefix = `[${timestamp}] [${this.context}] [${level.toUpperCase()}]`;
      return [prefix, message, ...args];
    }
    debug(message, ...args) {
      if (this.shouldLog("debug")) {
        console.log(...this.formatMessage("debug", message, ...args));
      }
    }
    info(message, ...args) {
      if (this.shouldLog("info")) {
        console.info(...this.formatMessage("info", message, ...args));
      }
    }
    warn(message, ...args) {
      if (this.shouldLog("warn")) {
        console.warn(...this.formatMessage("warn", message, ...args));
      }
    }
    error(message, ...args) {
      if (this.shouldLog("error")) {
        console.error(...this.formatMessage("error", message, ...args));
      }
    }
    log(context, ...args) {
      this.debug(`[${context}]`, ...args);
    }
  };
  var logger2 = new Logger2();

  // src/ui/components/VisibilityControls.js
  var debugLog = (message, data = null) => {
    if (window.HOVERBOARD_DEBUG) {
      if (data) {
        console.log(`[Hoverboard VisibilityControls Debug] ${message}`, data);
      } else {
        console.log(`[Hoverboard VisibilityControls Debug] ${message}`);
      }
    }
  };
  var VisibilityControls = class {
    constructor(document2, onSettingsChange) {
      this.document = document2;
      this.onSettingsChange = onSettingsChange || (() => {
      });
      this.logger = new Logger2("VisibilityControls");
      this.settings = {
        textTheme: "light-on-dark",
        // 'light-on-dark' | 'dark-on-light' - Dark theme default
        transparencyEnabled: false,
        backgroundOpacity: 90
        // 0-100%
      };
      this.controlsElement = null;
      this.isCollapsed = true;
      debugLog("VisibilityControls initialized", this.settings);
    }
    /**
     * Create the visibility controls UI
     * @returns {HTMLElement} Controls container element
     */
    createControls() {
      const container = this.document.createElement("div");
      container.className = "hoverboard-visibility-controls";
      container.innerHTML = this.getControlsHTML();
      this.controlsElement = container;
      this.attachEventListeners();
      this.updateControlsState();
      debugLog("Controls created");
      return container;
    }
    /**
     * Generate HTML for the controls
     * @returns {string} HTML string
     */
    getControlsHTML() {
      return `
      <div class="visibility-controls-header">
        <span class="controls-title">Display</span>
        <button class="controls-toggle" title="Toggle visibility controls">
          <span class="toggle-icon">${this.isCollapsed ? "\u2699\uFE0F" : "\u2715"}</span>
        </button>
      </div>
      <div class="visibility-controls-panel ${this.isCollapsed ? "collapsed" : ""}">
        <div class="control-group">
          <label class="control-label">
            <span class="label-text">Theme:</span>
            <button class="theme-toggle" title="Switch between light and dark themes">
              <span class="theme-icon">${this.settings.textTheme === "light-on-dark" ? "\u{1F319}" : "\u2600\uFE0F"}</span>
              <span class="theme-text">${this.settings.textTheme === "light-on-dark" ? "Dark" : "Light"}</span>
            </button>
          </label>
        </div>

        <div class="control-group">
          <label class="control-label">
            <input type="checkbox" class="transparency-toggle" ${this.settings.transparencyEnabled ? "checked" : ""}>
            <span class="label-text">Transparency</span>
          </label>
        </div>

        <div class="control-group opacity-group ${!this.settings.transparencyEnabled ? "disabled" : ""}">
          <label class="control-label">
            <span class="label-text">Opacity:</span>
            <div class="slider-container">
              <input type="range"
                     class="opacity-slider"
                     min="10"
                     max="100"
                     value="${this.settings.backgroundOpacity}"
                     ${!this.settings.transparencyEnabled ? "disabled" : ""}>
              <span class="opacity-value">${this.settings.backgroundOpacity}%</span>
            </div>
          </label>
        </div>
      </div>
    `;
    }
    /**
     * Attach event listeners to control elements
     */
    attachEventListeners() {
      if (!this.controlsElement) return;
      const toggleButton = this.controlsElement.querySelector(".controls-toggle");
      toggleButton?.addEventListener("click", () => {
        this.toggleControlsPanel();
      });
      const themeToggle = this.controlsElement.querySelector(".theme-toggle");
      themeToggle?.addEventListener("click", () => {
        this.toggleTheme();
      });
      const transparencyToggle = this.controlsElement.querySelector(".transparency-toggle");
      transparencyToggle?.addEventListener("change", (e) => {
        this.setTransparencyEnabled(e.target.checked);
      });
      const opacitySlider = this.controlsElement.querySelector(".opacity-slider");
      opacitySlider?.addEventListener("input", (e) => {
        this.setBackgroundOpacity(parseInt(e.target.value));
      });
      debugLog("Event listeners attached");
    }
    /**
     * Toggle the controls panel visibility
     */
    toggleControlsPanel() {
      this.isCollapsed = !this.isCollapsed;
      const panel = this.controlsElement?.querySelector(".visibility-controls-panel");
      const toggleIcon = this.controlsElement?.querySelector(".toggle-icon");
      if (panel) {
        panel.classList.toggle("collapsed", this.isCollapsed);
      }
      if (toggleIcon) {
        toggleIcon.textContent = this.isCollapsed ? "\u2699\uFE0F" : "\u2715";
      }
      debugLog("Controls panel toggled", { collapsed: this.isCollapsed });
    }
    /**
     * Toggle between light and dark themes
     */
    toggleTheme() {
      this.settings.textTheme = this.settings.textTheme === "light-on-dark" ? "dark-on-light" : "light-on-dark";
      this.updateThemeDisplay();
      this.notifySettingsChange();
      debugLog("Theme toggled", { theme: this.settings.textTheme });
    }
    /**
     * Set transparency enabled state
     * @param {boolean} enabled
     */
    setTransparencyEnabled(enabled) {
      this.settings.transparencyEnabled = enabled;
      this.updateOpacityControlState();
      this.notifySettingsChange();
      debugLog("Transparency toggled", { enabled });
    }
    /**
     * Set background opacity value
     * @param {number} opacity - Opacity value 0-100
     */
    setBackgroundOpacity(opacity) {
      this.settings.backgroundOpacity = Math.max(10, Math.min(100, opacity));
      this.updateOpacityDisplay();
      this.notifySettingsChange();
      debugLog("Opacity changed", { opacity: this.settings.backgroundOpacity });
    }
    /**
     * Update theme display elements
     */
    updateThemeDisplay() {
      const themeIcon = this.controlsElement?.querySelector(".theme-icon");
      const themeText = this.controlsElement?.querySelector(".theme-text");
      if (themeIcon && themeText) {
        const isLightOnDark = this.settings.textTheme === "light-on-dark";
        themeIcon.textContent = isLightOnDark ? "\u{1F319}" : "\u2600\uFE0F";
        themeText.textContent = isLightOnDark ? "Dark" : "Light";
      }
    }
    /**
     * Update opacity control state and display
     */
    updateOpacityControlState() {
      const opacityGroup = this.controlsElement?.querySelector(".opacity-group");
      const opacitySlider = this.controlsElement?.querySelector(".opacity-slider");
      if (opacityGroup) {
        opacityGroup.classList.toggle("disabled", !this.settings.transparencyEnabled);
      }
      if (opacitySlider) {
        opacitySlider.disabled = !this.settings.transparencyEnabled;
      }
    }
    /**
     * Update opacity value display
     */
    updateOpacityDisplay() {
      const opacityValue = this.controlsElement?.querySelector(".opacity-value");
      const opacitySlider = this.controlsElement?.querySelector(".opacity-slider");
      if (opacityValue) {
        opacityValue.textContent = `${this.settings.backgroundOpacity}%`;
      }
      if (opacitySlider) {
        opacitySlider.value = this.settings.backgroundOpacity;
      }
    }
    /**
     * Update all control states to match current settings
     */
    updateControlsState() {
      this.updateThemeDisplay();
      this.updateOpacityControlState();
      this.updateOpacityDisplay();
      const transparencyToggle = this.controlsElement?.querySelector(".transparency-toggle");
      if (transparencyToggle) {
        transparencyToggle.checked = this.settings.transparencyEnabled;
      }
    }
    /**
     * Get current visibility settings
     * @returns {Object} Current settings object
     */
    getSettings() {
      return { ...this.settings };
    }
    /**
     * Set visibility settings
     * @param {Object} newSettings - Settings to apply
     */
    setSettings(newSettings) {
      this.settings = { ...this.settings, ...newSettings };
      this.updateControlsState();
      debugLog("Settings updated", this.settings);
    }
    /**
     * Notify parent component of settings change
     */
    notifySettingsChange() {
      this.onSettingsChange(this.getSettings());
    }
    /**
     * Get CSS styles for the controls
     * @returns {string} CSS styles
     */
    getControlsCSS() {
      return `
      .hoverboard-visibility-controls {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ddd;
        border-radius: 6px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        min-width: 160px;
      }

      .visibility-controls-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 8px;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        border-radius: 5px 5px 0 0;
      }

      .controls-title {
        font-weight: 600;
        color: #495057;
      }

      .controls-toggle {
        background: none;
        border: none;
        cursor: pointer;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 14px;
        line-height: 1;
      }

      .controls-toggle:hover {
        background: rgba(0, 0, 0, 0.1);
      }

      .visibility-controls-panel {
        padding: 8px;
        transition: all 0.2s ease;
        max-height: 200px;
        overflow: hidden;
      }

      .visibility-controls-panel.collapsed {
        max-height: 0;
        padding: 0 8px;
      }

      .control-group {
        margin-bottom: 8px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-group.disabled {
        opacity: 0.5;
        pointer-events: none;
      }

      .control-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        padding: 2px 0;
      }

      .label-text {
        font-weight: 500;
        color: #495057;
      }

      .theme-toggle {
        display: flex;
        align-items: center;
        gap: 4px;
        background: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.15s ease;
      }

      .theme-toggle:hover {
        background: #dee2e6;
        border-color: #adb5bd;
      }

      .theme-icon {
        font-size: 12px;
      }

      .transparency-toggle {
        cursor: pointer;
      }

      .slider-container {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .opacity-slider {
        width: 80px;
        height: 4px;
        background: #e9ecef;
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }

      .opacity-slider::-webkit-slider-thumb {
        appearance: none;
        width: 12px;
        height: 12px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
      }

      .opacity-slider::-moz-range-thumb {
        width: 12px;
        height: 12px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }

      .opacity-value {
        font-size: 10px;
        color: #6c757d;
        min-width: 30px;
        text-align: right;
      }

      /* Dark theme styles */
      .hoverboard-theme-light-on-dark .hoverboard-visibility-controls {
        background: rgba(33, 37, 41, 0.95);
        border-color: #495057;
        color: #f8f9fa;
      }

      .hoverboard-theme-light-on-dark .visibility-controls-header {
        background: #343a40;
        border-color: #495057;
      }

      .hoverboard-theme-light-on-dark .controls-title,
      .hoverboard-theme-light-on-dark .label-text {
        color: #f8f9fa;
      }

      .hoverboard-theme-light-on-dark .theme-toggle {
        background: #495057;
        border-color: #6c757d;
        color: #f8f9fa;
      }

      .hoverboard-theme-light-on-dark .theme-toggle:hover {
        background: #5a6268;
        border-color: #adb5bd;
      }

      .hoverboard-theme-light-on-dark .opacity-slider {
        background: #495057;
      }

      .hoverboard-theme-light-on-dark .opacity-value {
        color: #adb5bd;
      }
    `;
    }
    /**
     * Destroy the controls and clean up
     */
    destroy() {
      if (this.controlsElement) {
        this.controlsElement.remove();
        this.controlsElement = null;
      }
      debugLog("VisibilityControls destroyed");
    }
  };

  // src/features/content/message-client.js
  init_utils();
  var MessageClient = class {
    constructor() {
      this.messageTimeout = 1e4;
      this.retryAttempts = 3;
      this.retryDelay = 1e3;
    }
    /**
     * Send message to background script
     * @param {MessageEnvelope} message - Message object with type and data
     * @param {{ timeout?: number, retries?: number, retryDelay?: number }} [options] - Send options
     * @returns {Promise<unknown>} Promise that resolves with response
     */
    async sendMessage(message, options = {}) {
      const messageOptions = {
        timeout: options.timeout || this.messageTimeout,
        retries: options.retries !== void 0 ? options.retries : this.retryAttempts,
        retryDelay: options.retryDelay || this.retryDelay,
        ...options
      };
      return this.sendMessageWithRetry(message, messageOptions, 0);
    }
    /**
     * Send message with retry logic
     * @param {MessageEnvelope} message - Message object
     * @param {{ timeout?: number, retries?: number, retryDelay?: number }} options - Send options
     * @param {number} attempt - Current attempt number
     * @returns {Promise<unknown>} Promise that resolves with response
     */
    async sendMessageWithRetry(message, options, attempt) {
      try {
        return await this.sendSingleMessage(message, options);
      } catch (error48) {
        if (attempt < options.retries && this.isRetryableError(error48)) {
          console.warn(`Message failed (attempt ${attempt + 1}), retrying:`, error48.message);
          await this.sleep(options.retryDelay * (attempt + 1));
          return this.sendMessageWithRetry(message, options, attempt + 1);
        } else {
          throw error48;
        }
      }
    }
    /**
     * Send single message to background
     * @param {MessageEnvelope} message - Message object
     * @param {{ timeout?: number, retries?: number, retryDelay?: number }} options - Send options
     * @returns {Promise<unknown>} Promise that resolves with response
     */
    // [SAFARI-EXT-SHIM-001] Refactor sendSingleMessage to use await directly
    async sendSingleMessage(message, options) {
      const messageId = this.generateMessageId();
      const fullMessage = { ...message, messageId };
      return await safariEnhancements.runtime.sendMessage(fullMessage);
    }
    /**
     * Handle response from background script
     * @param {string} messageId - Message ID
     * @param {Object} response - Response object
     */
    handleMessageResponse(messageId, response) {
    }
    /**
     * Send message to specific tab
     * @param {number} tabId - Target tab ID
     * @param {Object} message - Message object
     * @returns {Promise} Promise that resolves with response
     */
    // [SAFARI-EXT-SHIM-001] Refactor sendMessageToTab to use await directly
    async sendMessageToTab(tabId, message) {
      return await safariEnhancements.tabs.sendMessage(tabId, message);
    }
    /**
     * Broadcast message to all tabs
     * @param {Object} message - Message to broadcast
     * @returns {Promise} Promise that resolves when all messages sent
     */
    async broadcastMessage(message) {
      try {
        const tabs = await this.getAllTabs();
        const promises = tabs.map(
          (tab) => this.sendMessageToTab(tab.id, message).catch(() => {
          })
        );
        await Promise.all(promises);
      } catch (error48) {
        console.error("Failed to broadcast message:", error48);
        throw error48;
      }
    }
    /**
     * Get all open tabs
     * @returns {Promise<Array>} Promise that resolves with tab array
     */
    getAllTabs() {
      return new Promise((resolve, reject) => {
        try {
          safariEnhancements.tabs.query({}, (tabs) => {
            if (safariEnhancements.runtime.lastError) {
              reject(new Error(safariEnhancements.runtime.lastError.message));
            } else {
              resolve(tabs);
            }
          });
        } catch (error48) {
          reject(error48);
        }
      });
    }
    /**
     * Generate unique message ID
     * @returns {string} Unique message ID
     */
    generateMessageId() {
      return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Check if error is retryable
     * @param {Error} error - Error to check
     * @returns {boolean} Whether error should be retried
     */
    isRetryableError(error48) {
      const retryableMessages = [
        "Could not establish connection",
        "Extension context invalidated",
        "Message timeout",
        "The message port closed before a response was received"
      ];
      return retryableMessages.some(
        (msg) => error48.message.includes(msg)
      );
    }
    /**
     * Clean up pending message
     * @param {string} messageId - Message ID to clean up
     */
    cleanupPendingMessage(messageId) {
    }
    /**
     * Sleep for specified milliseconds
     * @param {number} ms - Milliseconds to sleep
     * @returns {Promise} Promise that resolves after delay
     */
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    /**
     * Check if background script is available
     * @returns {Promise<boolean>} Whether background script responds
     */
    async isBackgroundAvailable() {
      try {
        await this.sendMessage({ type: "PING" }, { timeout: 1e3, retries: 0 });
        return true;
      } catch (error48) {
        return false;
      }
    }
    /**
     * Get extension info
     * @returns {Object} Extension information
     */
    getExtensionInfo() {
      return {
        id: safariEnhancements.runtime.id,
        version: safariEnhancements.runtime.getManifest().version,
        url: safariEnhancements.runtime.getURL(""),
        isIncognito: safariEnhancements.extension.inIncognitoContext
      };
    }
    /**
     * Open extension options page
     */
    openOptionsPage() {
      if (safariEnhancements.runtime.openOptionsPage) {
        safariEnhancements.runtime.openOptionsPage();
      } else {
        window.open(safariEnhancements.runtime.getURL("src/ui/options/options.html"));
      }
    }
    /**
     * Get current tab information
     * @returns {Promise<Object>} Current tab info
     */
    async getCurrentTab() {
      return new Promise((resolve, reject) => {
        try {
          safariEnhancements.tabs.getCurrent((tab) => {
            if (safariEnhancements.runtime.lastError) {
              reject(new Error(safariEnhancements.runtime.lastError.message));
            } else {
              resolve(tab);
            }
          });
        } catch (error48) {
          reject(error48);
        }
      });
    }
    /**
     * Clean up all pending messages (for when script unloads)
     */
    cleanup() {
    }
    /**
     * Get statistics about message client
     * @returns {Object} Statistics object
     */
    getStats() {
      return {
        messageTimeout: this.messageTimeout,
        retryAttempts: this.retryAttempts,
        retryDelay: this.retryDelay
      };
    }
  };
  window.addEventListener("beforeunload", () => {
    if (window.hoverboardMessageClient) {
      window.hoverboardMessageClient.cleanup();
    }
  });

  // src/features/content/overlay-manager.js
  init_tag_service();
  init_utils();
  var debugLog3 = (message, data = null) => {
    if (window.HOVERBOARD_DEBUG) {
      if (data) {
        console.log(`[Hoverboard Overlay Debug] ${message}`, data);
      } else {
        console.log(`[Hoverboard Overlay Debug] ${message}`);
      }
    }
  };
  var debugError2 = (message, error48 = null) => {
    if (window.HOVERBOARD_DEBUG) {
      if (error48) {
        console.error(`[Hoverboard Overlay Debug] ${message}`, error48);
      } else {
        console.error(`[Hoverboard Overlay Debug] ${message}`);
      }
    }
  };
  var OverlayManager = class {
    constructor(document2, config2) {
      this.document = document2;
      this.config = config2;
      this.logger = new Logger("OverlayManager");
      this.overlayElement = null;
      this.isVisible = false;
      this.currentContent = null;
      this.isInsideOverlay = false;
      this.overlayId = "hoverboard-overlay";
      this.overlayClass = "hoverboard-overlay";
      this.transparencyMode = config2?.overlayTransparencyMode || "opaque";
      this.positionMode = config2?.overlayPositionMode || "default";
      this.adaptiveVisibility = config2?.overlayAdaptiveVisibility || false;
      this.proximityListener = null;
      this.visibilityControls = null;
      this.visibilityControlsCallback = (settings) => {
        debugLog3("Visibility settings changed", settings);
        this.applyVisibilitySettings(settings);
      };
      this.messageService = new MessageClient();
      this.tagService = new TagService();
      this._onStateChange = null;
      this._onOverlayAction = null;
      debugLog3("OverlayManager initialized", { config: config2, transparencyMode: this.transparencyMode });
    }
    /**
     * [IMPL-UI_TESTABILITY_HOOKS] [ARCH-UI_TESTABILITY] [REQ-UI_INSPECTION] [REQ-MODULE_VALIDATION] Set optional callback for overlay state changes (for tests).
     */
    setOnStateChange(fn) {
      this._onStateChange = typeof fn === "function" ? fn : null;
    }
    /**
     * [IMPL-OVERLAY_TEST_HARNESS] [ARCH-OVERLAY_TESTABILITY] [REQ-UI_INSPECTION]
     * Set optional callback for overlay user actions (for tests). Signature: (actionId) => void. actionId: 'refresh' | 'close' | 'tag-added' | 'tag-removed' | 'togglePrivate' | 'toggleReadLater'
     */
    setOnOverlayAction(fn) {
      this._onOverlayAction = typeof fn === "function" ? fn : null;
    }
    /**
     * Show overlay with content
     */
    async show(content) {
      this.logger.log("INFO", "OverlayManager", "show() called", { content });
      this.logger.log("DEBUG", "OverlayManager", "Platform detection", { platform: navigator.userAgent });
      if (typeof chrome !== "undefined" && chrome.runtime) {
        this.logger.log("DEBUG", "OverlayManager", "Detected Chrome runtime");
      } else if (typeof safariEnhancements !== "undefined" && safariEnhancements.runtime) {
        this.logger.log("DEBUG", "OverlayManager", "Detected browser polyfill runtime");
      } else {
        this.logger.log("ERROR", "OverlayManager", "No recognized extension runtime detected");
      }
      try {
        this.logger.log("DEBUG", "OverlayManager", "Starting overlay creation process");
        this.logger.log("DEBUG", "OverlayManager", "Content analysis", {
          hasBookmark: !!content.bookmark,
          bookmarkTags: content.bookmark?.tags,
          tagsType: typeof content.bookmark?.tags,
          tagsIsArray: Array.isArray(content.bookmark?.tags),
          pageTitle: content.pageTitle,
          pageUrl: content.pageUrl
        });
        this.logger.log("DEBUG", "OverlayManager", "Using original content data");
        this.currentContent = content;
        if (!this.overlayElement) {
          this.logger.log("DEBUG", "OverlayManager", "Creating new overlay element");
          this.createOverlay();
        } else {
          this.logger.log("DEBUG", "OverlayManager", "Using existing overlay element");
        }
        this.clearContent();
        this.logger.log("DEBUG", "OverlayManager", "Content cleared");
        this.logger.log("DEBUG", "OverlayManager", "Creating main container");
        const mainContainer = this.document.createElement("div");
        mainContainer.style.cssText = "padding: 8px; padding-top: 40px;";
        this.logger.log("DEBUG", "OverlayManager", "Creating tags container");
        const currentTagsContainer = this.document.createElement("div");
        currentTagsContainer.className = "scrollmenu tags-container";
        currentTagsContainer.style.cssText = `
        margin-bottom: 8px;
        padding: 4px;
        border-radius: 4px;
      `;
        this.logger.log("DEBUG", "OverlayManager", "Creating refresh button");
        const refreshBtn = this.document.createElement("button");
        refreshBtn.className = "refresh-button";
        refreshBtn.innerHTML = "\u{1F504}";
        refreshBtn.title = "Refresh Data";
        refreshBtn.setAttribute("aria-label", "Refresh Data");
        refreshBtn.setAttribute("role", "button");
        refreshBtn.setAttribute("tabindex", "0");
        refreshBtn.tabIndex = 0;
        refreshBtn.disabled = false;
        refreshBtn.style.cssText = `
        position: absolute;
        top: 8px;
        left: 40px;  // [OVERLAY-CLOSE-POSITION-OVERLAY-001] Position relative to overlay
        background: var(--theme-button-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        border-radius: 4px;
        padding: 4px 6px;
        cursor: pointer;
        font-size: 14px;
        z-index: 1;
        transition: var(--theme-transition);
        min-width: 24px;
        min-height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        outline: 2px solid transparent;
        box-shadow: 0 0 0 2px transparent;
      `;
        this.logger.log("DEBUG", "OverlayManager", "Adding refresh button click handler");
        refreshBtn.onclick = async () => {
          await this.handleRefreshButtonClick();
        };
        this.logger.log("DEBUG", "OverlayManager", "Adding refresh button keyboard handlers");
        refreshBtn.addEventListener("keydown", async (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            await this.handleRefreshButtonClick();
          }
        });
        this.logger.log("DEBUG", "OverlayManager", "Creating close button");
        const closeBtn = this.document.createElement("span");
        closeBtn.className = "close-button";
        closeBtn.innerHTML = "\u2715";
        closeBtn.title = "Close Overlay";
        closeBtn.setAttribute("aria-label", "Close Overlay");
        closeBtn.setAttribute("role", "button");
        closeBtn.setAttribute("tabindex", "0");
        closeBtn.tabIndex = 0;
        closeBtn.style.cssText = `
        position: absolute;
        top: 8px;
        left: 8px;  // [OVERLAY-CLOSE-POSITION-OVERLAY-001] Position relative to overlay
        background: var(--theme-button-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        border-radius: 4px;
        padding: 4px 6px;
        cursor: pointer;
        font-size: 14px;
        z-index: 1;
        transition: var(--theme-transition);
        min-width: 24px;
        min-height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
        closeBtn.onclick = () => {
          if (this._onOverlayAction) this._onOverlayAction("close");
          this.hide();
        };
        this.logger.log("DEBUG", "OverlayManager", "Adding close button keyboard handlers");
        closeBtn.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            this.hide();
          }
        });
        this.logger.log("DEBUG", "OverlayManager", "Appending buttons to overlay");
        this.overlayElement.appendChild(closeBtn);
        this.overlayElement.appendChild(refreshBtn);
        this.logger.log("DEBUG", "OverlayManager", "Creating current tags label");
        const currentLabel = this.document.createElement("span");
        currentLabel.className = "label-primary tiny";
        currentLabel.textContent = "Current:";
        currentLabel.style.cssText = "padding: 0.2em 0.5em; margin-right: 4px;";
        currentTagsContainer.appendChild(currentLabel);
        this.logger.log("DEBUG", "OverlayManager", "Processing current tags", {
          hasBookmark: !!content.bookmark,
          bookmarkKeys: content.bookmark ? Object.keys(content.bookmark) : [],
          tags: content.bookmark?.tags,
          tagsType: typeof content.bookmark?.tags,
          tagsIsArray: Array.isArray(content.bookmark?.tags)
        });
        if (content.bookmark?.tags) {
          this.logger.log("DEBUG", "OverlayManager", "Adding current tags", { tags: content.bookmark.tags });
          content.bookmark.tags.forEach((tag) => {
            if (this.isValidTag(tag)) {
              this.logger.log("DEBUG", "OverlayManager", "Creating tag element", { tag });
              const tagElement = this.document.createElement("span");
              tagElement.className = "tag-element tiny iconTagDeleteInactive";
              tagElement.textContent = tag;
              tagElement.title = "Double-click to remove";
              tagElement.ondblclick = async () => {
                try {
                  this.logger.log("DEBUG", "OverlayManager", "Tag double-clicked", { tag });
                  if (content.bookmark && content.bookmark.tags) {
                    const index = content.bookmark.tags.indexOf(tag);
                    if (index > -1) {
                      content.bookmark.tags.splice(index, 1);
                    }
                  }
                  if (content.bookmark && content.bookmark.url) {
                    await this.messageService.sendMessage({
                      type: "deleteTag",
                      // [sync:site-record] [action:delete]
                      data: {
                        url: content.bookmark.url,
                        value: tag
                      }
                    });
                  }
                  this.show(content);
                  if (this._onOverlayAction) this._onOverlayAction("tag-removed");
                  this.showMessage("Tag deleted successfully", "success");
                } catch (error48) {
                  this.logger.log("ERROR", "OverlayManager", "Failed to delete tag", { tag, error: error48 });
                  this.showMessage("Failed to delete tag", "error");
                }
              };
              currentTagsContainer.appendChild(tagElement);
            } else {
              this.logger.log("WARN", "OverlayManager", "Invalid tag found", { tag });
            }
          });
        } else {
          this.logger.log("DEBUG", "OverlayManager", "No tags found in bookmark data");
        }
        const tagInput = this.document.createElement("input");
        tagInput.className = "tag-input";
        tagInput.placeholder = "New Tag";
        tagInput.style.cssText = `
        margin: 2px;
        padding: 2px !important;
        font-size: 12px;
        width: 80px;
      `;
        tagInput.addEventListener("keypress", async (e) => {
          if (e.key === "Enter") {
            const tagText = tagInput.value.trim();
            if (tagText && this.isValidTag(tagText) && content.bookmark) {
              try {
                await this.messageService.sendMessage({
                  type: "saveTag",
                  data: {
                    url: content.bookmark.url || window.location.href,
                    value: tagText,
                    description: content.bookmark.description || this.document.title
                  }
                });
                if (!content.bookmark.tags) content.bookmark.tags = [];
                if (!content.bookmark.tags.includes(tagText)) {
                  content.bookmark.tags.push(tagText);
                }
                tagInput.value = "";
                this.show(content);
                if (this._onOverlayAction) this._onOverlayAction("tag-added");
                debugLog3("[IMMUTABLE-REQ-TAG-004] Tag persisted successfully", tagText);
                this.showMessage("Tag saved successfully", "success");
              } catch (error48) {
                debugError2("[IMMUTABLE-REQ-TAG-004] Failed to persist tag:", error48);
                this.showMessage("Failed to save tag", "error");
              }
            } else if (tagText && !this.isValidTag(tagText)) {
              debugLog3("[IMMUTABLE-REQ-TAG-004] Invalid tag rejected:", tagText);
              this.showMessage("Invalid tag format", "error");
            }
          }
        });
        currentTagsContainer.appendChild(tagInput);
        const recentContainer = this.document.createElement("div");
        recentContainer.className = "scrollmenu recent-container";
        recentContainer.style.cssText = `
        margin-bottom: 8px;
        padding: 4px;
        border-radius: 4px;
        font-size: smaller;
        font-weight: 900;
      `;
        const recentLabel = this.document.createElement("span");
        recentLabel.className = "label-secondary tiny";
        recentLabel.textContent = "Recent:";
        recentLabel.style.cssText = "padding: 0.2em 0.5em; margin-right: 4px;";
        recentContainer.appendChild(recentLabel);
        try {
          const recentTags = await this.loadRecentTagsForOverlay(content);
          if (recentTags && recentTags.length > 0) {
            recentTags.slice(0, 3).forEach((tag) => {
              if (!content.bookmark?.tags?.includes(tag)) {
                const tagElement = this.document.createElement("span");
                tagElement.className = "tag-element tiny";
                tagElement.textContent = tag;
                tagElement.onclick = async () => {
                  if (content.bookmark) {
                    try {
                      await this.messageService.sendMessage({
                        type: "saveTag",
                        data: {
                          url: content.bookmark.url || window.location.href,
                          value: tag,
                          description: content.bookmark.description || this.document.title
                        }
                      });
                      if (!content.bookmark.tags) content.bookmark.tags = [];
                      if (!content.bookmark.tags.includes(tag)) {
                        content.bookmark.tags.push(tag);
                      }
                      this.show(content);
                      if (this._onOverlayAction) this._onOverlayAction("tag-added");
                      debugLog3("[TAG-SYNC-OVERLAY-001] Tag persisted from recent", tag);
                      this.showMessage("Tag saved successfully", "success");
                    } catch (error48) {
                      debugError2("[TAG-SYNC-OVERLAY-001] Failed to persist tag from recent:", error48);
                      this.showMessage("Failed to save tag", "error");
                    }
                  }
                };
                recentContainer.appendChild(tagElement);
              }
            });
          } else {
            const emptyState = this.document.createElement("span");
            emptyState.className = "empty-state tiny";
            emptyState.textContent = "No recent tags";
            emptyState.style.cssText = "color: #999; font-style: italic;";
            recentContainer.appendChild(emptyState);
          }
        } catch (error48) {
          debugError2("[TAG-SYNC-OVERLAY-001] Failed to load recent tags:", error48);
          const fallbackTags = ["development", "web", "tutorial"];
          fallbackTags.forEach((tag) => {
            if (!content.bookmark?.tags?.includes(tag)) {
              const tagElement = this.document.createElement("span");
              tagElement.className = "tag-element tiny";
              tagElement.textContent = tag;
              tagElement.onclick = async () => {
                if (content.bookmark) {
                  try {
                    await this.messageService.sendMessage({
                      type: "saveTag",
                      data: {
                        url: content.bookmark.url || window.location.href,
                        value: tag,
                        description: content.bookmark.description || this.document.title
                      }
                    });
                    if (!content.bookmark.tags) content.bookmark.tags = [];
                    if (!content.bookmark.tags.includes(tag)) {
                      content.bookmark.tags.push(tag);
                    }
                    this.show(content);
                    debugLog3("[TAG-SYNC-OVERLAY-001] Fallback tag persisted", tag);
                    this.showMessage("Tag saved successfully", "success");
                  } catch (error49) {
                    debugError2("[TAG-SYNC-OVERLAY-001] Failed to persist fallback tag:", error49);
                    this.showMessage("Failed to save tag", "error");
                  }
                }
              };
              recentContainer.appendChild(tagElement);
            }
          });
        }
        let visibilityControlsContainer = null;
        if (!this.visibilityControls) {
          this.visibilityControls = new VisibilityControls(this.document, this.visibilityControlsCallback);
          debugLog3("VisibilityControls component initialized");
        }
        visibilityControlsContainer = this.visibilityControls.createControls();
        debugLog3("VisibilityControls UI created");
        this.injectCSS();
        debugLog3("CSS re-injected with VisibilityControls styles");
        const initialSettings = this.visibilityControls.getSettings();
        this.applyVisibilitySettings(initialSettings);
        debugLog3("Initial visibility settings applied", initialSettings);
        const actionsContainer = this.document.createElement("div");
        actionsContainer.className = "actions";
        actionsContainer.style.cssText = `
        padding: 4px;
        border-radius: 4px;
        text-align: center;
      `;
        const privateBtn = this.document.createElement("button");
        const isPrivate = content.bookmark?.shared === "no";
        privateBtn.className = `action-button privacy-button ${isPrivate ? "private-active" : ""}`;
        privateBtn.style.cssText = `
        margin: 2px;
        font-weight: 600;
      `;
        privateBtn.textContent = isPrivate ? "\u{1F512} Private" : "\u{1F310} Public";
        privateBtn.onclick = async () => {
          if (content.bookmark) {
            try {
              const isPrivate2 = content.bookmark.shared === "no";
              const newSharedStatus = isPrivate2 ? "yes" : "no";
              const updatedBookmark = {
                ...content.bookmark,
                shared: newSharedStatus
              };
              await this.messageService.sendMessage({
                type: "saveBookmark",
                data: updatedBookmark
              });
              content.bookmark.shared = newSharedStatus;
              this.show(content);
              this.showMessage(`Bookmark is now ${isPrivate2 ? "public" : "private"}`, "success");
              debugLog3("[TOGGLE-SYNC-OVERLAY-001] Sending BOOKMARK_UPDATED to background", updatedBookmark);
              await safariEnhancements.runtime.sendMessage({
                type: "BOOKMARK_UPDATED",
                data: updatedBookmark
              });
              debugLog3("[TOGGLE-SYNC-OVERLAY-001] Privacy toggled", content.bookmark.shared);
            } catch (error48) {
              debugError2("[TOGGLE-SYNC-OVERLAY-001] Failed to toggle privacy:", error48);
              this.showMessage("Failed to update privacy setting", "error");
            }
          }
        };
        const readBtn = this.document.createElement("button");
        const isToRead = content.bookmark?.toread === "yes";
        readBtn.className = `action-button read-button ${isToRead ? "read-later-active" : ""}`;
        readBtn.style.cssText = `
        margin: 2px;
        font-weight: 600;
      `;
        readBtn.textContent = isToRead ? "\u{1F4D6} Read Later" : "\u{1F4CB} Not marked";
        readBtn.onclick = async () => {
          if (content.bookmark) {
            try {
              const isCurrentlyToRead = content.bookmark.toread === "yes";
              const newToReadStatus = isCurrentlyToRead ? "no" : "yes";
              const updatedBookmark = {
                ...content.bookmark,
                toread: newToReadStatus,
                description: content.bookmark.description || this.document.title
              };
              await this.messageService.sendMessage({
                type: "saveBookmark",
                data: updatedBookmark
              });
              content.bookmark.toread = newToReadStatus;
              this.show(content);
              const statusMessage = newToReadStatus === "yes" ? "Added to read later" : "Removed from read later";
              this.showMessage(statusMessage, "success");
              debugLog3("[TOGGLE-SYNC-OVERLAY-001] Sending BOOKMARK_UPDATED to background", updatedBookmark);
              await safariEnhancements.runtime.sendMessage({
                type: "BOOKMARK_UPDATED",
                data: updatedBookmark
              });
              debugLog3("[TOGGLE-SYNC-OVERLAY-001] Read status toggled", content.bookmark.toread);
            } catch (error48) {
              debugError2("[TOGGLE-SYNC-OVERLAY-001] Failed to toggle read later status:", error48);
              this.showMessage("Failed to update read later status", "error");
            }
          }
        };
        actionsContainer.appendChild(privateBtn);
        actionsContainer.appendChild(readBtn);
        const pageInfo = this.document.createElement("div");
        pageInfo.className = "page-info";
        pageInfo.style.cssText = `
        padding: 4px;
        font-size: 11px;
        border-radius: 4px;
        margin-top: 4px;
        word-break: break-all;
      `;
        pageInfo.innerHTML = `
        <div class="label-primary" style="font-weight: bold; margin-bottom: 2px;">
          ${content.bookmark?.description || content.pageTitle || "No Title"}
        </div>
        <div class="text-muted">${content.bookmark?.url || content.pageUrl || ""}</div>
      `;
        debugLog3("Overlay structure created with enhanced styling");
        this.addTabSearchSection(mainContainer);
        mainContainer.appendChild(currentTagsContainer);
        mainContainer.appendChild(recentContainer);
        const suggestedContainer = this.document.createElement("div");
        suggestedContainer.className = "scrollmenu suggested-container";
        suggestedContainer.style.cssText = `
        margin-bottom: 8px;
        padding: 4px;
        border-radius: 4px;
        font-size: smaller;
        font-weight: 900;
      `;
        const suggestedLabel = this.document.createElement("span");
        suggestedLabel.className = "label-secondary tiny";
        suggestedLabel.textContent = "Suggested:";
        suggestedLabel.style.cssText = "padding: 0.2em 0.5em; margin-right: 4px;";
        suggestedContainer.appendChild(suggestedLabel);
        try {
          const suggestedTags = this.tagService.extractSuggestedTagsFromContent(this.document, window.location.href, 30);
          if (suggestedTags && suggestedTags.length > 0) {
            const currentTags = content.bookmark?.tags || [];
            const currentTagsLower = new Set(currentTags.map((t) => t.toLowerCase()));
            suggestedTags.slice(0, 15).forEach((tag) => {
              const tagLower = tag.toLowerCase();
              if (!currentTagsLower.has(tagLower)) {
                const tagElement = this.document.createElement("span");
                tagElement.className = "tag-element tiny";
                tagElement.textContent = tag;
                tagElement.onclick = async () => {
                  if (content.bookmark) {
                    try {
                      await this.messageService.sendMessage({
                        type: "saveTag",
                        data: {
                          url: content.bookmark.url || window.location.href,
                          value: tag,
                          description: content.bookmark.description || this.document.title
                        }
                      });
                      if (!content.bookmark.tags) content.bookmark.tags = [];
                      if (!content.bookmark.tags.includes(tag)) {
                        content.bookmark.tags.push(tag);
                      }
                      this.show(content);
                      debugLog3("[REQ-SUGGESTED_TAGS_FROM_CONTENT] Tag persisted from suggested", tag);
                      this.showMessage("Tag saved successfully", "success");
                    } catch (error48) {
                      debugError2("[REQ-SUGGESTED_TAGS_FROM_CONTENT] Failed to persist tag from suggested:", error48);
                      this.showMessage("Failed to save tag", "error");
                    }
                  }
                };
                suggestedContainer.appendChild(tagElement);
              }
            });
          } else {
            suggestedContainer.style.display = "none";
          }
        } catch (error48) {
          debugError2("[REQ-SUGGESTED_TAGS_FROM_CONTENT] Failed to extract suggested tags:", error48);
          suggestedContainer.style.display = "none";
        }
        if (suggestedContainer.children.length > 1) {
          mainContainer.appendChild(suggestedContainer);
        }
        if (visibilityControlsContainer) {
          mainContainer.appendChild(visibilityControlsContainer);
        }
        mainContainer.appendChild(actionsContainer);
        mainContainer.appendChild(pageInfo);
        this.overlayElement.appendChild(mainContainer);
        this.currentContent = content;
        debugLog3("Overlay structure assembled");
        this.positionOverlay();
        debugLog3("[OverlayManager] Setting overlay display to block");
        this.overlayElement.style.display = "block";
        debugLog3("[OverlayManager] Setting overlay opacity to 1");
        this.overlayElement.style.opacity = "1";
        this.isVisible = true;
        if (this._onStateChange) {
          const b = content?.bookmark;
          this._onStateChange({
            visible: true,
            contentSnapshot: {
              title: b?.description || content?.pageTitle,
              url: content?.pageUrl || b?.url,
              tags: b?.tags,
              private: b?.shared === "no",
              toread: b?.toread === "yes"
            }
          });
        }
        debugLog3("Overlay positioned and displayed");
        console.log("\u{1F3A8} [Overlay Debug] Final overlay visibility check:", {
          isVisible: this.isVisible,
          elementExists: !!this.overlayElement,
          elementInDOM: this.document.body.contains(this.overlayElement),
          computedDisplay: window.getComputedStyle(this.overlayElement).display,
          computedOpacity: window.getComputedStyle(this.overlayElement).opacity
        });
      } catch (error48) {
        this.logger.error("Error showing overlay:", error48);
        debugLog3("Error showing overlay", { error: error48 });
      }
    }
    /**
     * [IMPL-OVERLAY] [ARCH-OVERLAY] [REQ-OVERLAY_SYSTEM] Hide overlay.
     */
    hide() {
      debugLog3("[OverlayManager] hide() called", { stack: new Error().stack });
      if (!this.isVisible || !this.overlayElement) {
        debugLog3("Hide called but overlay not visible");
        return;
      }
      try {
        debugLog3("Hiding overlay");
        this.addHideAnimation(() => {
          if (this.overlayElement) {
            debugLog3("[OverlayManager] Setting overlay display to none");
            this.overlayElement.style.display = "none";
            debugLog3("[OverlayManager] Setting overlay opacity to 0");
            this.overlayElement.style.opacity = "0";
            this.clearContent();
          }
          this.isVisible = false;
          this.currentContent = null;
          if (this._onStateChange) this._onStateChange({ visible: false, contentSnapshot: null });
          debugLog3("Overlay hidden successfully");
        });
      } catch (error48) {
        this.logger.error("Error hiding overlay:", error48);
        debugLog3("Error hiding overlay", { error: error48 });
      }
    }
    /**
     * [IMMUTABLE-REQ-TAG-004] - Enhanced message display for tag operations
     */
    showMessage(message, type = "info") {
      try {
        const messageElement = this.document.createElement("div");
        messageElement.className = `overlay-message overlay-message-${type}`;
        messageElement.textContent = message;
        messageElement.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 8px 12px;
        border-radius: 4px;
        color: white;
        font-size: 12px;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        font-weight: 600;
      `;
        if (type === "error") {
          messageElement.style.background = "var(--theme-danger, #e74c3c)";
        } else if (type === "success") {
          messageElement.style.background = "var(--theme-success, #2ecc71)";
        } else {
          messageElement.style.background = "var(--theme-info, #3498db)";
        }
        this.document.body.appendChild(messageElement);
        setTimeout(() => {
          if (messageElement.parentNode) {
            messageElement.parentNode.removeChild(messageElement);
          }
        }, 3e3);
        debugLog3("[IMMUTABLE-REQ-TAG-004] Message displayed:", { message, type });
      } catch (error48) {
        debugError2("[IMMUTABLE-REQ-TAG-004] Failed to show message:", error48);
      }
    }
    /**
     * [IMMUTABLE-REQ-TAG-004] - Refresh overlay content with latest bookmark data
     */
    // [OVERLAY-REFRESH-INTEGRATION-001] Refresh overlay content with latest bookmark data
    // Coordinates with [OVERLAY-DATA-DISPLAY-001] for data refresh mechanism
    async refreshOverlayContent() {
      try {
        const pageTitle = this.currentContent?.pageTitle || this.document.title || "";
        const refreshData = {
          url: this.currentContent?.pageUrl || window.location.href,
          title: pageTitle,
          tabId: this.currentContent?.tabId || null
        };
        debugLog3("[OVERLAY-REFRESH-INTEGRATION-001] Refresh request data:", refreshData);
        const response = await this.messageService.sendMessage({
          type: "getCurrentBookmark",
          data: refreshData
        });
        if (response && response.success && response.data) {
          const updatedContent = {
            bookmark: response.data,
            pageTitle: this.currentContent?.pageTitle || this.document.title || "",
            pageUrl: this.currentContent?.pageUrl || window.location.href
          };
          debugLog3("[OVERLAY-REFRESH-INTEGRATION-001] Overlay content refreshed with updated data");
          debugLog3("[OVERLAY-DEBUG] Refreshed bookmark data:", {
            responseData: response.data,
            responseDataKeys: Object.keys(response.data),
            hasTags: !!response.data.tags,
            tagsValue: response.data.tags,
            tagsType: typeof response.data.tags
          });
          return updatedContent;
        } else {
          debugError2("[OVERLAY-REFRESH-INTEGRATION-001] Invalid response structure:", response);
        }
      } catch (error48) {
        debugError2("[OVERLAY-REFRESH-INTEGRATION-001] Failed to refresh overlay content:", error48);
      }
      return null;
    }
    /**
     * [OVERLAY-REFRESH-HANDLER-001] Refresh button click handler
     */
    // [OVERLAY-REFRESH-HANDLER-001] Handle refresh button click with comprehensive error handling and loading state
    async handleRefreshButtonClick() {
      this.logger.log("INFO", "OverlayManager", "Refresh button clicked");
      if (this._onOverlayAction) this._onOverlayAction("refresh");
      const refreshButton = this.document.querySelector(".refresh-button");
      this.logger.log("DEBUG", "OverlayManager", "Found refresh button", { found: !!refreshButton });
      try {
        if (refreshButton) {
          this.logger.log("DEBUG", "OverlayManager", "Adding loading state to refresh button");
          refreshButton.classList.add("loading");
          refreshButton.disabled = true;
        }
        this.showMessage("Refreshing data...", "info");
        this.logger.log("DEBUG", "OverlayManager", "Starting overlay content refresh");
        const updatedContent = await this.refreshOverlayContent();
        if (updatedContent) {
          this.logger.log("DEBUG", "OverlayManager", "Content refresh successful", { updatedContent });
          this.show(updatedContent);
          this.showMessage("Data refreshed successfully", "success");
          this.logger.log("INFO", "OverlayManager", "Overlay refreshed successfully");
        } else {
          this.logger.log("ERROR", "OverlayManager", "No updated content received");
          throw new Error("Failed to get updated data");
        }
      } catch (error48) {
        this.logger.log("ERROR", "OverlayManager", "Refresh failed", { error: error48 });
        this.showMessage("Failed to refresh data", "error");
      } finally {
        if (refreshButton) {
          this.logger.log("DEBUG", "OverlayManager", "Removing loading state from refresh button");
          refreshButton.classList.remove("loading");
          refreshButton.disabled = false;
        }
      }
    }
    /**
     * [TAG-SYNC-OVERLAY-001] - Load recent tags from shared memory for overlay
     * @param {Object} content - Content object with bookmark data
     * @returns {Promise<string[]>} Array of recent tag names
     */
    async loadRecentTagsForOverlay(content) {
      try {
        debugLog3("[TAG-SYNC-OVERLAY-001] Loading recent tags for overlay");
        const response = await this.messageService.sendMessage({
          type: "getRecentBookmarks",
          data: {
            currentTags: content.bookmark?.tags || [],
            senderUrl: content.bookmark?.url || window.location.href
          }
        });
        debugLog3("[TAG-SYNC-OVERLAY-001] Recent tags response:", response);
        if (response && response.recentTags) {
          const recentTagNames = response.recentTags.map((tag) => {
            if (typeof tag === "string") {
              return tag;
            } else if (tag && typeof tag === "object" && tag.name) {
              return tag.name;
            } else {
              return String(tag);
            }
          });
          debugLog3("[TAG-SYNC-OVERLAY-001] Extracted recent tag names:", recentTagNames);
          return recentTagNames;
        }
        debugLog3("[TAG-SYNC-OVERLAY-001] No recent tags found");
        return [];
      } catch (error48) {
        debugError2("[TAG-SYNC-OVERLAY-001] Failed to load recent tags:", error48);
        return [];
      }
    }
    /**
     * Check if click was inside overlay
     */
    isClickInsideOverlay(event) {
      if (!this.overlayElement || !this.isVisible) {
        return false;
      }
      return this.overlayElement.contains(event.target);
    }
    /**
     * Create overlay DOM element
     */
    createOverlay() {
      this.logger.debug("Creating overlay element");
      this.removeOverlay();
      this.overlayElement = this.document.createElement("div");
      this.overlayElement.id = this.overlayId;
      this.overlayElement.className = this.overlayClass;
      this.applyOverlayStyles();
      this.document.body.appendChild(this.overlayElement);
      this.injectCSS();
      if (this.visibilityControls) {
        const initialSettings = this.visibilityControls.getSettings();
        this.applyVisibilitySettings(initialSettings);
        debugLog3("Initial theme applied in createOverlay", initialSettings);
      }
    }
    /**
     * Remove overlay from DOM
     */
    removeOverlay() {
      const existing = this.document.getElementById(this.overlayId);
      if (existing) {
        existing.remove();
      }
      this.overlayElement = null;
      this.isVisible = false;
    }
    /**
     * Clear overlay content
     */
    clearContent() {
      if (this.overlayElement) {
        this.overlayElement.innerHTML = "";
      }
    }
    /**
     * Position overlay on screen
     */
    positionOverlay() {
      if (!this.overlayElement) {
        return;
      }
      if (this.positionMode === "bottom-fixed") {
        this.applyBottomFixedPositioning();
        return;
      }
      this.overlayElement.style.position = "fixed";
      this.overlayElement.style.top = "20px";
      this.overlayElement.style.right = "20px";
      this.overlayElement.style.left = "auto";
      this.overlayElement.style.bottom = "auto";
      this.overlayElement.style.zIndex = "9998";
      debugLog3("Overlay positioned in top-right corner");
    }
    /**
     * Calculate optimal position for overlay
     */
    calculateOptimalPosition() {
      const viewport = {
        width: window.innerWidth,
        height: window.innerHeight,
        scrollX: window.pageXOffset,
        scrollY: window.pageYOffset
      };
      let x = viewport.width - 320 - 20;
      let y = 20;
      switch (this.config.overlayPosition) {
        case "top-left":
          x = 20;
          y = 20;
          break;
        case "top-right":
          x = viewport.width - 320 - 20;
          y = 20;
          break;
        case "bottom-left":
          x = 20;
          y = viewport.height - 200 - 20;
          break;
        case "bottom-right":
          x = viewport.width - 320 - 20;
          y = viewport.height - 200 - 20;
          break;
        case "center":
          x = (viewport.width - 320) / 2;
          y = (viewport.height - 200) / 2;
          break;
        case "mouse":
          if (this.lastMousePosition) {
            x = this.lastMousePosition.x + 10;
            y = this.lastMousePosition.y + 10;
          }
          break;
        default:
          break;
      }
      return { x, y };
    }
    /**
     * Constrain overlay to viewport
     */
    constrainToViewport() {
      if (!this.overlayElement) {
        return;
      }
      const rect = this.overlayElement.getBoundingClientRect();
      const viewport = {
        width: window.innerWidth,
        height: window.innerHeight
      };
      let x = parseInt(this.overlayElement.style.left);
      let y = parseInt(this.overlayElement.style.top);
      if (rect.right > viewport.width) {
        x = viewport.width - rect.width - 10;
      }
      if (x < 10) {
        x = 10;
      }
      if (rect.bottom > viewport.height) {
        y = viewport.height - rect.height - 10;
      }
      if (y < 10) {
        y = 10;
      }
      this.overlayElement.style.left = `${x}px`;
      this.overlayElement.style.top = `${y}px`;
    }
    /**
     * Apply overlay styles
     */
    applyOverlayStyles() {
      if (!this.overlayElement) {
        return;
      }
      const styles = {
        display: "none",
        position: "fixed",
        minWidth: "300px",
        maxWidth: "400px",
        minHeight: "100px",
        maxHeight: "80vh",
        backgroundColor: "white",
        border: "1px solid #ccc",
        borderRadius: "6px",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        padding: "12px",
        fontSize: "14px",
        fontFamily: "system-ui, -apple-system, sans-serif",
        zIndex: "2147483647",
        overflow: "auto",
        cursor: "default"
      };
      Object.assign(this.overlayElement.style, styles);
      this.applyTransparencyMode();
    }
    /**
     *  UI-005: Transparent overlay manager -  Position and transparency control
     * Apply bottom-fixed positioning for transparent overlays
     */
    applyBottomFixedPositioning() {
      if (!this.overlayElement) return;
      this.overlayElement.classList.add("hoverboard-overlay-bottom");
      this.overlayElement.style.position = "fixed";
      this.overlayElement.style.bottom = "0";
      this.overlayElement.style.left = "0";
      this.overlayElement.style.width = "100vw";
      this.overlayElement.style.maxWidth = "none";
      this.overlayElement.style.minWidth = "100vw";
      this.overlayElement.style.height = "auto";
      this.overlayElement.style.minHeight = "48px";
      this.overlayElement.style.maxHeight = "200px";
      this.overlayElement.style.borderRadius = "0";
      this.overlayElement.style.zIndex = "999999";
      debugLog3("Applied bottom-fixed positioning");
    }
    /**
     *  UI-005: Transparency manager -  Opacity and positioning control
     * Apply transparency styling based on configuration
     */
    applyTransparencyMode() {
      if (!this.overlayElement) return;
      this.overlayElement.classList.remove(
        "hoverboard-overlay-transparent",
        "hoverboard-overlay-invisible"
      );
      const normalOpacity = this.config?.overlayOpacityNormal || 0.05;
      const hoverOpacity = this.config?.overlayOpacityHover || 0.15;
      const focusOpacity = this.config?.overlayOpacityFocus || 0.25;
      const blurAmount = this.config?.overlayBlurAmount || 2;
      switch (this.transparencyMode) {
        case "nearly-transparent":
          this.overlayElement.classList.add("hoverboard-overlay-transparent");
          this.overlayElement.style.background = `rgba(255, 255, 255, ${normalOpacity})`;
          this.overlayElement.style.backdropFilter = `blur(${blurAmount}px)`;
          this.overlayElement.style.border = "1px solid rgba(255, 255, 255, 0.2)";
          this.setupTransparencyInteractions();
          debugLog3("Applied nearly-transparent mode with opacity:", normalOpacity);
          break;
        case "fully-transparent":
          this.overlayElement.classList.add("hoverboard-overlay-invisible");
          this.overlayElement.style.background = `rgba(255, 255, 255, ${normalOpacity * 0.5})`;
          this.overlayElement.style.backdropFilter = `blur(${Math.max(1, blurAmount - 1)}px)`;
          this.overlayElement.style.border = "1px solid rgba(255, 255, 255, 0.1)";
          this.setupTransparencyInteractions();
          debugLog3("Applied fully-transparent mode with opacity:", normalOpacity * 0.5);
          break;
        default:
          this.overlayElement.style.background = "white";
          this.overlayElement.style.backdropFilter = "none";
          this.overlayElement.style.border = "1px solid #ccc";
          debugLog3("Using default opaque mode");
          break;
      }
      if (this.positionMode === "bottom-fixed") {
        this.applyBottomFixedPositioning();
      }
      if (this.adaptiveVisibility && (this.transparencyMode === "nearly-transparent" || this.transparencyMode === "fully-transparent")) {
        this.setupAdaptiveVisibility();
      }
    }
    /**
     * Legacy adaptive visibility - superseded by UI-VIS-001/002
     * Setup adaptive visibility based on mouse proximity
     */
    setupAdaptiveVisibility() {
      if (this.proximityListener) {
        this.document.removeEventListener("mousemove", this.proximityListener);
      }
      this.proximityListener = (e) => {
        const distanceFromBottom = window.innerHeight - e.clientY;
        if (distanceFromBottom < 100) {
          this.overlayElement.classList.add("proximity-active");
        } else if (distanceFromBottom > 200) {
          this.overlayElement.classList.remove("proximity-active");
        }
      };
      this.document.addEventListener("mousemove", this.proximityListener);
      debugLog3("Adaptive visibility enabled");
    }
    /**
     * Legacy transparency interactions - superseded by UI-VIS-001/002
     * Setup hover and focus interactions for transparent overlays
     */
    setupTransparencyInteractions() {
      if (!this.overlayElement) return;
      const normalOpacity = this.config?.overlayOpacityNormal || 0.05;
      const hoverOpacity = this.config?.overlayOpacityHover || 0.15;
      const focusOpacity = this.config?.overlayOpacityFocus || 0.25;
      const blurAmount = this.config?.overlayBlurAmount || 2;
      const originalBackground = this.overlayElement.style.background;
      const originalBackdropFilter = this.overlayElement.style.backdropFilter;
      this.overlayElement.addEventListener("mouseenter", () => {
        if (this.transparencyMode === "nearly-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${hoverOpacity})`;
        } else if (this.transparencyMode === "fully-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${hoverOpacity * 0.5})`;
        }
        debugLog3("Overlay hover - increasing visibility to:", hoverOpacity);
      });
      this.overlayElement.addEventListener("mouseleave", () => {
        if (this.transparencyMode === "nearly-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${normalOpacity})`;
        } else if (this.transparencyMode === "fully-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${normalOpacity * 0.5})`;
        }
        debugLog3("Overlay leave - resetting visibility to:", normalOpacity);
      });
      this.overlayElement.addEventListener("focusin", () => {
        if (this.transparencyMode === "nearly-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${focusOpacity})`;
        } else if (this.transparencyMode === "fully-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${focusOpacity * 0.5})`;
        }
        debugLog3("Overlay focus - enhancing visibility for accessibility to:", focusOpacity);
      });
      this.overlayElement.addEventListener("focusout", () => {
        if (this.transparencyMode === "nearly-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${normalOpacity})`;
        } else if (this.transparencyMode === "fully-transparent") {
          this.overlayElement.style.background = `rgba(255, 255, 255, ${normalOpacity * 0.5})`;
        }
        debugLog3("Overlay blur - resetting focus visibility to:", normalOpacity);
      });
    }
    /**
     * Set up overlay interactions
     */
    setupOverlayInteractions() {
      if (!this.overlayElement) {
        return;
      }
      this.overlayElement.addEventListener("mouseenter", () => {
        this.isInsideOverlay = true;
      });
      this.overlayElement.addEventListener("mouseleave", () => {
        this.isInsideOverlay = false;
      });
      this.overlayElement.addEventListener("click", (e) => {
        e.stopPropagation();
      });
      if (this.config.overlayDraggable) {
        this.makeDraggable();
      }
    }
    /**
     * Make overlay draggable
     */
    makeDraggable() {
      if (!this.overlayElement) {
        return;
      }
      let isDragging = false;
      const dragOffset = { x: 0, y: 0 };
      const dragHandle = this.document.createElement("div");
      dragHandle.className = "hoverboard-drag-handle";
      dragHandle.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 20px;
      cursor: move;
      background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
      border-bottom: 1px solid #ddd;
      border-radius: 6px 6px 0 0;
    `;
      this.overlayElement.style.position = "relative";
      this.overlayElement.style.paddingTop = "32px";
      this.overlayElement.insertBefore(dragHandle, this.overlayElement.firstChild);
      dragHandle.addEventListener("mousedown", (e) => {
        isDragging = true;
        const overlayRect = this.overlayElement.getBoundingClientRect();
        dragOffset.x = e.clientX - overlayRect.left;
        dragOffset.y = e.clientY - overlayRect.top;
        e.preventDefault();
      });
      this.document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;
        this.overlayElement.style.left = `${x}px`;
        this.overlayElement.style.top = `${y}px`;
        this.constrainToViewport();
      });
      this.document.addEventListener("mouseup", () => {
        isDragging = false;
      });
    }
    /**
     * Add show animation
     */
    addShowAnimation() {
      if (!this.overlayElement) {
        return;
      }
      if (this.config.overlayAnimations) {
        this.overlayElement.style.opacity = "0";
        this.overlayElement.style.transform = "scale(0.9) translateY(-10px)";
        this.overlayElement.style.transition = "opacity 0.2s ease, transform 0.2s ease";
        requestAnimationFrame(() => {
          this.overlayElement.style.opacity = "1";
          this.overlayElement.style.transform = "scale(1) translateY(0)";
        });
      } else {
        this.overlayElement.style.opacity = "1";
        this.overlayElement.style.transform = "scale(1) translateY(0)";
      }
    }
    /**
     * Add hide animation
     */
    addHideAnimation(callback) {
      if (!this.overlayElement || !this.config.overlayAnimations) {
        callback();
        return;
      }
      this.overlayElement.style.transition = "opacity 0.15s ease, transform 0.15s ease";
      this.overlayElement.style.opacity = "0";
      this.overlayElement.style.transform = "scale(0.9) translateY(-10px)";
      setTimeout(callback, 150);
    }
    /**
     * Inject CSS styles
     */
    injectCSS() {
      const styleId = "hoverboard-overlay-styles";
      const existingStyle = this.document.getElementById(styleId);
      if (existingStyle) {
        existingStyle.remove();
      }
      const style = this.document.createElement("style");
      style.id = styleId;
      let cssContent = this.getOverlayCSS();
      if (this.visibilityControls) {
        cssContent += "\n" + this.visibilityControls.getControlsCSS();
      }
      style.textContent = cssContent;
      this.document.head.appendChild(style);
      debugLog3("CSS injected", { hasVisibilityControls: !!this.visibilityControls });
    }
    /**
     * [TAB-SEARCH-UI] Add tab search section to overlay
     */
    addTabSearchSection(mainContainer) {
      const searchContainer = this.document.createElement("div");
      searchContainer.className = "tab-search-container";
      searchContainer.style.cssText = `
      margin-bottom: 8px;
      padding: 4px;
      border-radius: 4px;
    `;
      const searchLabel = this.document.createElement("span");
      searchLabel.className = "label-primary tiny";
      searchLabel.textContent = "Search Tabs:";
      searchLabel.style.cssText = "padding: 0.2em 0.5em; margin-right: 4px;";
      searchContainer.appendChild(searchLabel);
      const searchInput = this.document.createElement("input");
      searchInput.className = "tab-search-input";
      searchInput.placeholder = "Enter tab title...";
      searchInput.style.cssText = `
      margin: 2px;
      padding: 2px 4px;
      font-size: 12px;
      width: 120px;
    `;
      searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const searchText = searchInput.value.trim();
          if (searchText) {
            this.handleTabSearch(searchText);
          }
        }
      });
      searchContainer.appendChild(searchInput);
      mainContainer.appendChild(searchContainer);
    }
    /**
     * [TAB-SEARCH-UI] Handle tab search from overlay
     */
    async handleTabSearch(searchText) {
      try {
        const response = await safariEnhancements.runtime.sendMessage({
          type: "searchTabs",
          data: { searchText }
        });
        if (response.success) {
          this.showMessage(`Found ${response.matchCount} tabs - navigating to "${response.tabTitle}"`, "success");
        } else {
          this.showMessage(response.message || "No matching tabs found", "error");
        }
      } catch (error48) {
        console.error("[TAB-SEARCH-UI] Tab search error:", error48);
        this.showMessage("Failed to search tabs", "error");
      }
    }
    /**
     * Get overlay CSS styles
     */
    getOverlayCSS() {
      return `
      /* Base overlay styling with theme-aware defaults */
      .hoverboard-overlay {
        position: fixed !important;
        z-index: 9998 !important;
        background: rgba(255, 255, 255, 0.95);
        border: 2px solid #90ee90;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        min-width: 300px;
        max-width: 400px;
        max-height: 80vh;
        font-family: 'Futura PT', system-ui, -apple-system, sans-serif;
        font-size: 14px;
        color: #333;
        font-weight: 600;
        padding: 0;
        margin: 0;
        overflow-y: auto;
        cursor: pointer;
        backdrop-filter: none;
        width: auto;
        height: auto;
        min-height: auto;
        opacity: 0;
        transform: scale(0.9) translateY(-10px);

        /* Default theme variables and transition timing */
        --theme-opacity: 0.9;
        --theme-text-opacity: 1.0;
        --theme-border-opacity: 0.8;
        --theme-transition: all 0.2s ease-in-out;
      }

      /* \u{1F3A8} Theme Variables - Light-on-Dark Theme (Dark Theme) */
      .hoverboard-theme-light-on-dark {
        /* Primary text colors */
        --theme-text-primary: #ffffff;
        --theme-text-secondary: #e0e0e0;
        --theme-text-muted: #b0b0b0;

        /* Special text colors for light backgrounds in dark theme */
        --theme-text-on-light: #333333;
        --theme-text-secondary-on-light: #666666;

        /* Background colors */
        --theme-background-primary: #2c3e50;
        --theme-background-secondary: #34495e;
        --theme-background-tertiary: #455a64;

        /* Interactive element colors - Dark backgrounds for light-on-dark */
        --theme-button-bg: #34495e;
        --theme-button-hover: #455a64;
        --theme-button-active: #546e7a;

        /* Input styling - Dark backgrounds for light-on-dark */
        --theme-input-bg: #34495e;
        --theme-input-border: #455a64;
        --theme-input-focus: #74b9ff;

        /* Status and semantic colors - optimized for dark backgrounds */
        --theme-success: #2ecc71;
        --theme-warning: #f1c40f;
        --theme-danger: #e74c3c;
        --theme-info: #74b9ff;

        /* Tag-specific styling - softer colors for dark theme */
        --theme-tag-bg: rgba(46, 204, 113, 0.15);
        --theme-tag-text: #7bed9f;
        --theme-tag-border: rgba(46, 204, 113, 0.3);

        /* Borders and separators */
        --theme-border: rgba(255, 255, 255, 0.2);
        --theme-separator: rgba(255, 255, 255, 0.1);

        /* RGB values for dynamic transparency - Dark theme uses dark RGB */
        --theme-bg-rgb: 44, 62, 80;
      }

      /* \u{1F3A8} Theme Variables - Dark-on-Light Theme (Light Theme) */
      .hoverboard-theme-dark-on-light {
        /* Primary text colors */
        --theme-text-primary: #333333;
        --theme-text-secondary: #666666;
        --theme-text-muted: #999999;

        /* Text colors for consistency (same as primary in light theme) */
        --theme-text-on-light: #333333;
        --theme-text-secondary-on-light: #666666;

        /* Background colors */
        --theme-background-primary: #ffffff;
        --theme-background-secondary: #f8f9fa;
        --theme-background-tertiary: #e9ecef;

        /* Interactive element colors */
        --theme-button-bg: rgba(0, 0, 0, 0.05);
        --theme-button-hover: rgba(0, 0, 0, 0.1);
        --theme-button-active: rgba(0, 0, 0, 0.15);

        /* Input styling */
        --theme-input-bg: rgba(255, 255, 255, 0.8);
        --theme-input-border: rgba(0, 0, 0, 0.2);
        --theme-input-focus: rgba(0, 100, 200, 0.3);

        /* Status and semantic colors */
        --theme-success: #28a745;
        --theme-warning: #ffc107;
        --theme-danger: #dc3545;
        --theme-info: #17a2b8;

        /* Tag-specific styling */
        --theme-tag-bg: rgba(40, 167, 69, 0.1);
        --theme-tag-text: #28a745;
        --theme-tag-border: rgba(40, 167, 69, 0.3);

        /* Borders and separators */
        --theme-border: rgba(0, 0, 0, 0.1);
        --theme-separator: rgba(0, 0, 0, 0.05);

        /* RGB values for dynamic transparency */
        --theme-bg-rgb: 255, 255, 255;
      }

      /* \u{1F527} Transparency Mode Integration */
      .hoverboard-overlay.transparency-mode {
        background: rgba(var(--theme-bg-rgb), var(--theme-opacity)) !important;
        backdrop-filter: blur(2px);
      }

      /* Enhanced contrast for low opacity scenarios */
      .hoverboard-overlay.transparency-mode[data-opacity-level="low"] {
        --theme-text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
      }

      .hoverboard-overlay.transparency-mode[data-opacity-level="medium"] {
        --theme-text-shadow: 0 0 1px rgba(0, 0, 0, 0.5);
      }

      .hoverboard-overlay.transparency-mode * {
        text-shadow: var(--theme-text-shadow, none);
      }

      .hoverboard-overlay * {
        box-sizing: border-box;
      }

      /* \u{1F3A8} Theme-Aware Element Styling */

      /* Container elements */
      .hoverboard-overlay .scrollmenu,
      .hoverboard-overlay .tags-container {
        background: var(--theme-background-secondary);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        transition: var(--theme-transition);
        overflow-x: auto;
        white-space: nowrap;
      }

      .hoverboard-overlay .page-info {
        background: var(--theme-background-tertiary);
        color: var(--theme-text-secondary);
        border-top: 1px solid var(--theme-separator);
      }

      /* Text elements */
      .hoverboard-overlay .tiny {
        font-size: ${this.config.fontSizeLabels || 12}px;
        display: inline-block;
        color: var(--theme-text-secondary);
      }

      .hoverboard-overlay .label-primary {
        color: var(--theme-text-primary);
        font-weight: 600;
      }

      .hoverboard-overlay .label-secondary {
        color: var(--theme-text-secondary);
        font-weight: 500;
      }

      .hoverboard-overlay .text-muted {
        color: var(--theme-text-muted);
      }

      /* Tag elements */
      .hoverboard-overlay .tag-element,
      .hoverboard-overlay .iconTagDeleteInactive {
        background: var(--theme-tag-bg);
        color: var(--theme-tag-text);
        border: 1px solid var(--theme-tag-border);
        transition: var(--theme-transition);
        padding: 0.2em 0.5em;
        margin: 2px;
        border-radius: 3px;
        cursor: pointer;
        display: inline-block;
        font-size: ${this.config.fontSizeTags || 12}px;
      }

      /* Suggested tags - smaller font size */
      .hoverboard-overlay .suggested-container .tag-element {
        font-size: ${this.config.fontSizeSuggestedTags || 10}px;
      }

      .hoverboard-overlay .tag-element:hover,
      .hoverboard-overlay .iconTagDeleteInactive:hover {
        background: var(--theme-button-hover);
        transform: translateY(-1px);
        border-color: var(--theme-input-focus);
      }

      /* Input elements */
      .hoverboard-overlay .tag-input {
        background: var(--theme-input-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-input-border);
        transition: var(--theme-transition);
        outline: none;
        border-radius: 3px;
        padding: 2px 4px;
        font-size: ${this.config.fontSizeInputs || 14}px;
      }

      .hoverboard-overlay .tag-input:focus {
        border-color: var(--theme-input-focus);
        box-shadow: 0 0 0 2px rgba(var(--theme-input-focus), 0.2);
      }

      .hoverboard-overlay .tag-input::placeholder {
        color: var(--theme-text-muted);
      }

      .hoverboard-container {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .hoverboard-section {
        border-bottom: 1px solid #eee;
        padding-bottom: 12px;
      }

      .hoverboard-section:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }

      .section-header {
        font-weight: 600;
        font-size: 14px;
        color: #2c3e50;
        margin-bottom: 8px;
      }

      .tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 12px;
      }

      /* Button elements */
      .hoverboard-overlay .action-button {
        background: var(--theme-button-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        transition: var(--theme-transition);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .hoverboard-overlay .action-button:hover {
        background: var(--theme-button-hover);
        border-color: var(--theme-input-focus);
      }

      .hoverboard-overlay .action-button.active {
        background: var(--theme-button-active);
        border-color: var(--theme-info);
      }

      /* [OVERLAY-REFRESH-UI-001] Refresh button styling */
      .hoverboard-overlay .refresh-button {
        background: var(--theme-button-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        border-radius: 4px;
        padding: 4px 6px;
        cursor: pointer;
        font-size: 14px;
        transition: var(--theme-transition);
        position: absolute;
        top: 8px;
        left: 8px;
        z-index: 1;
      }

      .hoverboard-overlay .refresh-button:hover {
        background: var(--theme-button-hover);
        border-color: var(--theme-input-focus);
        transform: scale(1.05);
      }

      .hoverboard-overlay .refresh-button:active {
        background: var(--theme-button-active);
        transform: scale(0.95);
      }

      .hoverboard-overlay .refresh-button:focus {
        outline: 2px solid var(--theme-input-focus);
        outline-offset: 2px;
      }

      /* Close button - uses danger color */
      .hoverboard-overlay .close-button {
        background: var(--theme-danger);
        color: white;
        border: none;
        transition: var(--theme-transition);
        padding: 0.2em 0.5em;
        border-radius: 3px;
        cursor: pointer;
        font-weight: 900;
      }

      .hoverboard-overlay .close-button:hover {
        background: color-mix(in srgb, var(--theme-danger) 80%, black);
        transform: scale(1.05);
      }

      /* State-specific button styling */
      .hoverboard-overlay .action-button.private-active {
        background: color-mix(in srgb, var(--theme-warning) 20%, var(--theme-button-bg));
        border-color: var(--theme-warning);
      }

      .hoverboard-overlay .action-button.read-later-active {
        background: color-mix(in srgb, var(--theme-info) 20%, var(--theme-button-bg));
        border-color: var(--theme-info);
      }

      /* \u{1F3A8} Light-on-Dark Theme Comprehensive Overrides - ALL interactive elements get dark backgrounds */

      /* Main overlay container - Override inline styles with highest specificity */
      .hoverboard-overlay.hoverboard-theme-light-on-dark,
      #hoverboard-overlay.hoverboard-theme-light-on-dark,
      .hoverboard-theme-light-on-dark.hoverboard-overlay.solid-background {
        background: var(--theme-background-primary) !important;
        border: 2px solid var(--theme-border) !important;
        color: var(--theme-text-primary) !important;
      }

      /* Main overlay container in transparency mode - Override inline styles */
      .hoverboard-overlay.hoverboard-theme-light-on-dark.transparency-mode,
      .hoverboard-overlay.hoverboard-theme-light-on-dark.hoverboard-overlay-transparent,
      #hoverboard-overlay.hoverboard-theme-light-on-dark.hoverboard-overlay-transparent {
        background: rgba(var(--theme-bg-rgb), var(--theme-opacity)) !important;
        backdrop-filter: blur(2px) !important;
        border: 2px solid var(--theme-border) !important;
      }

      /* All buttons */
      .hoverboard-theme-light-on-dark button,
      .hoverboard-theme-light-on-dark .action-button,
      .hoverboard-theme-light-on-dark .add-tag-button,
      .hoverboard-theme-light-on-dark .refresh-button {
        color: var(--theme-text-primary) !important;
        background: var(--theme-button-bg) !important;
        border: 1px solid var(--theme-input-border) !important;
      }

      .hoverboard-theme-light-on-dark button:hover,
      .hoverboard-theme-light-on-dark .action-button:hover,
      .hoverboard-theme-light-on-dark .add-tag-button:hover,
      .hoverboard-theme-light-on-dark .refresh-button:hover {
        background: var(--theme-button-hover) !important;
      }

      /* All text inputs */
      .hoverboard-theme-light-on-dark input,
      .hoverboard-theme-light-on-dark .tag-input,
      .hoverboard-theme-light-on-dark .add-tag-input {
        color: var(--theme-text-primary) !important;
        background: var(--theme-input-bg) !important;
        border: 1px solid var(--theme-input-border) !important;
      }

      .hoverboard-theme-light-on-dark input:focus,
      .hoverboard-theme-light-on-dark .tag-input:focus,
      .hoverboard-theme-light-on-dark .add-tag-input:focus {
        border-color: var(--theme-input-focus) !important;
        box-shadow: 0 0 0 2px rgba(116, 185, 255, 0.2) !important;
      }

      .hoverboard-theme-light-on-dark input::placeholder,
      .hoverboard-theme-light-on-dark .tag-input::placeholder,
      .hoverboard-theme-light-on-dark .add-tag-input::placeholder {
        color: var(--theme-text-muted) !important;
      }

      /* All labels */
      .hoverboard-theme-light-on-dark .label-primary {
        color: var(--theme-text-primary) !important;
        background: var(--theme-background-secondary);
        padding: 0.2em 0.5em;
        border-radius: 3px;
      }

      .hoverboard-theme-light-on-dark .label-secondary {
        color: var(--theme-text-secondary) !important;
        background: var(--theme-background-tertiary);
        padding: 0.2em 0.5em;
        border-radius: 3px;
      }

      /* Special button states */
      .hoverboard-theme-light-on-dark .action-button.private-active {
        background: color-mix(in srgb, var(--theme-warning) 30%, var(--theme-button-bg)) !important;
        color: var(--theme-text-primary) !important;
      }

      .hoverboard-theme-light-on-dark .action-button.read-later-active {
        background: color-mix(in srgb, var(--theme-info) 30%, var(--theme-button-bg)) !important;
        color: var(--theme-text-primary) !important;
      }

      /* Close button override */
      .hoverboard-theme-light-on-dark .close-button {
        background: var(--theme-danger) !important;
        color: white !important;
      }

      .add-tag-container {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      /* Form elements */
      .hoverboard-overlay .add-tag-input {
        background: var(--theme-input-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-input-border);
        transition: var(--theme-transition);
        padding: 6px 8px;
        border-radius: 4px;
        font-size: 13px;
        width: 140px;
        outline: none;
      }

      .hoverboard-overlay .add-tag-input:focus {
        border-color: var(--theme-input-focus);
        box-shadow: 0 0 0 2px rgba(var(--theme-input-focus), 0.2);
      }

      .hoverboard-overlay .add-tag-input::placeholder {
        color: var(--theme-text-muted);
      }

      .hoverboard-overlay .add-tag-button {
        background: var(--theme-success);
        color: white;
        border: 1px solid var(--theme-success);
        transition: var(--theme-transition);
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
      }

      .hoverboard-overlay .add-tag-button:hover {
        background: color-mix(in srgb, var(--theme-success) 80%, black);
        border-color: color-mix(in srgb, var(--theme-success) 80%, black);
      }

      .actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      @media (max-width: 480px) {
        .hoverboard-overlay {
          min-width: 280px;
          max-width: 90vw;
          font-size: 13px;
        }

        .tags-container {
          gap: 4px;
        }

        .actions {
          gap: 6px;
        }
      }

      /* \u2B50 UI-005: Transparent overlay - \u{1F3A8} Enhanced transparency system */
      .hoverboard-overlay-transparent {
        background: rgba(255, 255, 255, 0.1) !important;
        backdrop-filter: blur(2px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #000000;
        text-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
        transition: background-color 0.2s ease-in-out;
      }

      /* [OVERLAY-REFRESH-THEME-001] Refresh button theme-aware styling */
      .hoverboard-overlay .refresh-button {
        position: absolute;
        top: 8px;
        left: 8px;
        background: var(--theme-button-bg);
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        border-radius: 4px;
        padding: 4px 6px;
        cursor: pointer;
        font-size: 14px;
        z-index: 1;
        transition: var(--theme-transition);
        min-width: 24px;
        min-height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .hoverboard-overlay .refresh-button:hover {
        background: var(--theme-button-hover);
        border-color: var(--theme-input-focus);
        transform: scale(1.05);
      }

      .hoverboard-overlay .refresh-button:active {
        background: var(--theme-button-active);
        transform: scale(0.95);
      }

      .hoverboard-overlay .refresh-button:focus {
        outline: 2px solid var(--theme-input-focus);
        outline-offset: 2px;
      }

      /* [OVERLAY-REFRESH-THEME-001] Loading state for refresh button */
      .hoverboard-overlay .refresh-button.loading {
        opacity: 0.7;
        pointer-events: none;
      }

      .hoverboard-overlay .refresh-button.loading::after {
        content: '';
        position: absolute;
        width: 12px;
        height: 12px;
        border: 2px solid transparent;
        border-top: 2px solid var(--theme-text-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .hoverboard-overlay-invisible {
        background: transparent !important;
        backdrop-filter: blur(1px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #333333;
        transition: background-color 0.2s ease-in-out;
      }

      /* \u{1F53A} UI-005: Transparent overlay positioning - \u{1F3A8} Bottom-fixed transparency */
      .hoverboard-overlay-bottom {
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: auto !important;
        min-height: 48px;
        max-height: 200px;
        max-width: none !important;
        min-width: 100vw !important;
        border-radius: 0 !important;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        border-left: none;
        border-right: none;
        border-bottom: none;
        animation: hoverboard-slide-up 0.3s ease-out;
        padding: 8px 16px !important; /* Add horizontal padding for content spacing */
        box-sizing: border-box;
      }

      /* Layout adjustments for bottom-fixed overlays */
      .hoverboard-overlay-bottom .hoverboard-container {
        max-width: 100%;
        overflow: hidden;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .hoverboard-overlay-bottom .hoverboard-section {
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
        flex: 1;
        min-width: 200px;
      }

      .hoverboard-overlay-bottom .section-header {
        font-size: 12px;
        margin-bottom: 4px;
        white-space: nowrap;
      }

      .hoverboard-overlay-bottom .add-tag-container {
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 6px;
      }

      .hoverboard-overlay-bottom .add-tag-input {
        flex: 1;
        min-width: 120px;
        max-width: 200px;
      }

      .hoverboard-overlay-bottom .add-tag-button {
        flex-shrink: 0;
      }

      .hoverboard-overlay-bottom .actions {
        justify-content: flex-end;
        gap: 12px;
        flex-shrink: 0;
      }

      .hoverboard-overlay-bottom .tags-container {
        justify-content: flex-start;
        max-width: 100%;
        overflow-x: auto;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
      }

      .hoverboard-overlay-bottom .tags-container::-webkit-scrollbar {
        display: none; /* Chrome/Safari */
      }

      /* Responsive adjustments for bottom-fixed */
      @media (max-width: 768px) {
        .hoverboard-overlay-bottom .hoverboard-container {
          flex-direction: column;
          gap: 8px;
        }

        .hoverboard-overlay-bottom .hoverboard-section {
          min-width: unset;
          width: 100%;
        }

        .hoverboard-overlay-bottom .add-tag-container {
          flex-direction: row;
          justify-content: space-between;
        }

        .hoverboard-overlay-bottom .add-tag-input {
          max-width: 200px;
        }

        .hoverboard-overlay-bottom .actions {
          gap: 8px;
          justify-content: center;
        }
      }

      /* Hover state - Increased visibility on interaction */
      .hoverboard-overlay-transparent:hover,
      .hoverboard-overlay-invisible:hover {
        background: rgba(255, 255, 255, 0.25) !important;
      }

      /* Focus state - Enhanced visibility for accessibility */
      .hoverboard-overlay-transparent:focus-within,
      .hoverboard-overlay-invisible:focus-within {
        background: rgba(255, 255, 255, 0.4) !important;
      }

      /* \u{1F536} UI-005: Adaptive visibility - \u{1F3AF} Context-aware transparency */
      .hoverboard-overlay-transparent.proximity-active,
      .hoverboard-overlay-invisible.proximity-active {
        background: rgba(255, 255, 255, 0.2) !important;
      }

      /* Slide-up animation for bottom-fixed overlays */
      @keyframes hoverboard-slide-up {
        from {
          transform: translateY(100%);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* [IMMUTABLE-REQ-TAG-004] - Slide-in animation for messages */
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    `;
    }
    /**
     * Update mouse position for positioning
     */
    updateMousePosition(x, y) {
      this.lastMousePosition = { x, y };
    }
    /**
     * Apply visibility settings from VisibilityControls component
     * UI-VIS-001: Callback for VisibilityControls component
     * Enhanced with comprehensive theme integration
     */
    applyVisibilitySettings(settings) {
      debugLog3("Applying comprehensive visibility settings", settings);
      if (this.overlayElement) {
        this.overlayElement.classList.remove(
          "hoverboard-theme-light-on-dark",
          "hoverboard-theme-dark-on-light",
          "transparency-mode",
          "solid-background"
        );
        this.overlayElement.classList.add(`hoverboard-theme-${settings.textTheme}`);
        if (settings.transparencyEnabled) {
          this.overlayElement.classList.add("transparency-mode");
          const opacity = settings.backgroundOpacity / 100;
          let opacityLevel = "high";
          if (opacity < 0.4) opacityLevel = "low";
          else if (opacity < 0.7) opacityLevel = "medium";
          this.overlayElement.setAttribute("data-opacity-level", opacityLevel);
          this.overlayElement.style.setProperty("--theme-opacity", opacity);
          if (settings.textTheme === "light-on-dark") {
            this.overlayElement.style.background = `rgba(44, 62, 80, ${opacity})`;
          } else {
            this.overlayElement.style.background = `rgba(255, 255, 255, ${opacity})`;
          }
          this.overlayElement.style.backdropFilter = "blur(2px)";
          debugLog3(`Applied transparency: ${settings.textTheme} with ${settings.backgroundOpacity}% opacity (${opacityLevel} level)`);
        } else {
          this.overlayElement.classList.add("solid-background");
          this.overlayElement.removeAttribute("data-opacity-level");
          this.overlayElement.style.removeProperty("--theme-opacity");
          this.overlayElement.style.background = "";
          this.overlayElement.style.backdropFilter = "none";
          debugLog3(`Applied solid theme: ${settings.textTheme}`);
        }
        this.overlayElement.offsetHeight;
      }
    }
    /**
     * Update configuration
     */
    updateConfig(newConfig) {
      this.config = { ...this.config, ...newConfig };
      if (newConfig.overlayTransparencyMode !== void 0) {
        this.transparencyMode = newConfig.overlayTransparencyMode;
      }
      if (newConfig.overlayPositionMode !== void 0) {
        this.positionMode = newConfig.overlayPositionMode;
      }
      if (newConfig.overlayAdaptiveVisibility !== void 0) {
        this.adaptiveVisibility = newConfig.overlayAdaptiveVisibility;
      }
      debugLog3("Configuration updated", {
        transparencyMode: this.transparencyMode,
        positionMode: this.positionMode,
        adaptiveVisibility: this.adaptiveVisibility,
        newConfig
      });
    }
    /**
     * [IMMUTABLE-REQ-TAG-001] - Validate tag input
     * @param {string} tag - Tag to validate
     * @returns {boolean} Whether tag is valid
     */
    isValidTag(tag) {
      if (!tag || typeof tag !== "string") {
        return false;
      }
      const trimmedTag = tag.trim();
      if (trimmedTag.length === 0 || trimmedTag.length > 50) {
        return false;
      }
      const invalidChars = /[<>]/g;
      if (invalidChars.test(trimmedTag)) {
        return false;
      }
      const safeChars = /^[\w\s.#+-]+$/;
      if (!safeChars.test(trimmedTag)) {
        return false;
      }
      return true;
    }
    /**
     * Cleanup resources
     */
    destroy() {
      this.removeOverlay();
      if (this.proximityListener) {
        this.document.removeEventListener("mousemove", this.proximityListener);
        this.proximityListener = null;
      }
      if (this.visibilityControls) {
        this.visibilityControls.destroy();
        this.visibilityControls = null;
      }
      const styleElement = this.document.getElementById("hoverboard-overlay-styles");
      if (styleElement) {
        styleElement.remove();
      }
    }
  };

  // src/features/content/dom-utils.js
  var DOMUtils = class {
    /**
     * Wait for DOM to be ready
     * @returns {Promise} Promise that resolves when DOM is ready
     */
    waitForDOM() {
      return new Promise((resolve) => {
        if (document.readyState === "complete" || document.readyState === "interactive") {
          resolve();
        } else {
          document.addEventListener("DOMContentLoaded", resolve);
        }
      });
    }
    /**
     * Query selector with optional context
     * @param {string} selector - CSS selector
     * @param {Element} context - Context element (default: document)
     * @returns {Element|null} First matching element
     */
    $(selector, context = document) {
      return context.querySelector(selector);
    }
    /**
     * Query selector all with optional context
     * @param {string} selector - CSS selector
     * @param {Element} context - Context element (default: document)
     * @returns {NodeList} All matching elements
     */
    $$(selector, context = document) {
      return context.querySelectorAll(selector);
    }
    /**
     * Create element with attributes and properties
     * @param {string} tagName - HTML tag name
     * @param {Object} attributes - Element attributes
     * @param {Object} properties - Element properties
     * @returns {Element} Created element
     */
    createElement(tagName, attributes = {}, properties = {}) {
      const element = document.createElement(tagName);
      Object.entries(attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });
      Object.entries(properties).forEach(([key, value]) => {
        element[key] = value;
      });
      return element;
    }
    /**
     * Add event listener with optional delegation
     * @param {Element|string} target - Target element or selector
     * @param {string} event - Event type
     * @param {Function} handler - Event handler
     * @param {string} delegateSelector - Delegate selector for event delegation
     * @returns {Function} Cleanup function
     */
    on(target, event, handler, delegateSelector = null) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return () => {
      };
      if (delegateSelector) {
        const delegatedHandler = (e) => {
          const delegatedTarget = e.target.closest(delegateSelector);
          if (delegatedTarget && element.contains(delegatedTarget)) {
            handler.call(delegatedTarget, e);
          }
        };
        element.addEventListener(event, delegatedHandler);
        return () => element.removeEventListener(event, delegatedHandler);
      } else {
        element.addEventListener(event, handler);
        return () => element.removeEventListener(event, handler);
      }
    }
    /**
     * Remove element from DOM
     * @param {Element|string} target - Target element or selector
     */
    remove(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }
    /**
     * Append child element
     * @param {Element|string} parent - Parent element or selector
     * @param {Element} child - Child element to append
     */
    append(parent, child) {
      const parentElement = typeof parent === "string" ? this.$(parent) : parent;
      if (parentElement && child) {
        parentElement.appendChild(child);
      }
    }
    /**
     * Prepend child element
     * @param {Element|string} parent - Parent element or selector
     * @param {Element} child - Child element to prepend
     */
    prepend(parent, child) {
      const parentElement = typeof parent === "string" ? this.$(parent) : parent;
      if (parentElement && child) {
        parentElement.insertBefore(child, parentElement.firstChild);
      }
    }
    /**
     * Set or get element attributes
     * @param {Element|string} target - Target element or selector
     * @param {string|Object} attr - Attribute name or object of attributes
     * @param {string} value - Attribute value (if attr is string)
     * @returns {string|void} Attribute value if getting, void if setting
     */
    attr(target, attr, value = null) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return;
      if (typeof attr === "object") {
        Object.entries(attr).forEach(([key, val]) => {
          element.setAttribute(key, val);
        });
      } else if (value !== null) {
        element.setAttribute(attr, value);
      } else {
        return element.getAttribute(attr);
      }
    }
    /**
     * Add CSS class to element
     * @param {Element|string} target - Target element or selector
     * @param {string} className - Class name to add
     */
    addClass(target, className) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.classList.add(className);
      }
    }
    /**
     * Remove CSS class from element
     * @param {Element|string} target - Target element or selector
     * @param {string} className - Class name to remove
     */
    removeClass(target, className) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.classList.remove(className);
      }
    }
    /**
     * Toggle CSS class on element
     * @param {Element|string} target - Target element or selector
     * @param {string} className - Class name to toggle
     * @returns {boolean} Whether class is now present
     */
    toggleClass(target, className) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        return element.classList.toggle(className);
      }
      return false;
    }
    /**
     * Check if element has CSS class
     * @param {Element|string} target - Target element or selector
     * @param {string} className - Class name to check
     * @returns {boolean} Whether element has class
     */
    hasClass(target, className) {
      const element = typeof target === "string" ? this.$(target) : target;
      return element ? element.classList.contains(className) : false;
    }
    /**
     * Set or get element styles
     * @param {Element|string} target - Target element or selector
     * @param {string|Object} prop - Style property or object of styles
     * @param {string} value - Style value (if prop is string)
     * @returns {string|void} Style value if getting, void if setting
     */
    css(target, prop, value = null) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return;
      if (typeof prop === "object") {
        Object.entries(prop).forEach(([key, val]) => {
          element.style[key] = val;
        });
      } else if (value !== null) {
        element.style[prop] = value;
      } else {
        return window.getComputedStyle(element)[prop];
      }
    }
    /**
     * Show element
     * @param {Element|string} target - Target element or selector
     */
    show(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.style.display = "";
      }
    }
    /**
     * Hide element
     * @param {Element|string} target - Target element or selector
     */
    hide(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.style.display = "none";
      }
    }
    /**
     * Toggle element visibility
     * @param {Element|string} target - Target element or selector
     * @returns {boolean} Whether element is now visible
     */
    toggle(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        const isHidden = element.style.display === "none" || window.getComputedStyle(element).display === "none";
        if (isHidden) {
          this.show(element);
          return true;
        } else {
          this.hide(element);
          return false;
        }
      }
      return false;
    }
    /**
     * Get element text content
     * @param {Element|string} target - Target element or selector
     * @returns {string} Text content
     */
    text(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      return element ? element.textContent : "";
    }
    /**
     * Set element text content
     * @param {Element|string} target - Target element or selector
     * @param {string} text - Text to set
     */
    setText(target, text) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.textContent = text;
      }
    }
    /**
     * Get or set element HTML
     * @param {Element|string} target - Target element or selector
     * @param {string} html - HTML to set (optional)
     * @returns {string|void} HTML content if getting, void if setting
     */
    html(target, html = null) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return;
      if (html !== null) {
        element.innerHTML = html;
      } else {
        return element.innerHTML;
      }
    }
    /**
     * Check if element exists and is visible
     * @param {Element|string} target - Target element or selector
     * @returns {boolean} Whether element exists and is visible
     */
    isVisible(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return false;
      const style = window.getComputedStyle(element);
      return style.display !== "none" && style.visibility !== "hidden" && style.opacity !== "0";
    }
    /**
     * Get element position relative to viewport
     * @param {Element|string} target - Target element or selector
     * @returns {Object} Position object with top, left, right, bottom
     */
    getPosition(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return { top: 0, left: 0, right: 0, bottom: 0 };
      return element.getBoundingClientRect();
    }
    /**
     * Smooth scroll to element
     * @param {Element|string} target - Target element or selector
     * @param {Object} options - Scroll options
     */
    scrollTo(target, options = {}) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.scrollIntoView({
          behavior: "smooth",
          block: "start",
          inline: "nearest",
          ...options
        });
      }
    }
    /**
     * Debounce function calls
     * @param {Function} func - Function to debounce
     * @param {number} delay - Delay in milliseconds
     * @returns {Function} Debounced function
     */
    debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
      };
    }
    /**
     * Throttle function calls
     * @param {Function} func - Function to throttle
     * @param {number} delay - Delay in milliseconds
     * @returns {Function} Throttled function
     */
    throttle(func, delay) {
      let lastCall = 0;
      return function(...args) {
        const now = Date.now();
        if (now - lastCall >= delay) {
          lastCall = now;
          func.apply(this, args);
        }
      };
    }
    /**
     * Check if element is in viewport
     * @param {Element|string} target - Target element or selector
     * @param {number} threshold - Threshold percentage (0-1)
     * @returns {boolean} Whether element is in viewport
     */
    isInViewport(target, threshold = 0) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (!element) return false;
      const rect = element.getBoundingClientRect();
      const windowHeight = window.innerHeight || document.documentElement.clientHeight;
      const windowWidth = window.innerWidth || document.documentElement.clientWidth;
      const vertInView = rect.top <= windowHeight * (1 - threshold) && rect.top + rect.height >= windowHeight * threshold;
      const horInView = rect.left <= windowWidth * (1 - threshold) && rect.left + rect.width >= windowWidth * threshold;
      return vertInView && horInView;
    }
    /**
     * Add tooltip to element
     * @param {Element|string} target - Target element or selector
     * @param {string} text - Tooltip text
     * @param {boolean} wide - Whether tooltip should be wide
     */
    addTooltip(target, text, wide = false) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.setAttribute("title", text);
        element.setAttribute("data-tooltip", wide ? "wide" : "normal");
        this.addClass(element, "has-tooltip");
      }
    }
    /**
     * Remove tooltip from element
     * @param {Element|string} target - Target element or selector
     */
    removeTooltip(target) {
      const element = typeof target === "string" ? this.$(target) : target;
      if (element) {
        element.removeAttribute("title");
        element.removeAttribute("data-tooltip");
        this.removeClass(element, "has-tooltip");
      }
    }
  };

  // src/core/message-handler.js
  init_pinboard_service();

  // src/features/storage/local-bookmark-service.js
  init_tag_service();
  init_utils();

  // src/core/message-handler.js
  init_tag_service();
  init_config_manager();
  init_utils();

  // src/shared/message-schemas.js
  init_zod();
  var messageEnvelopeSchema = external_exports.object({
    type: external_exports.string(),
    data: external_exports.record(external_exports.string(), external_exports.unknown()).optional()
  });
  var optionalUrlSchema = external_exports.string().optional().nullable();
  var requiredUrlSchema = external_exports.string().min(1);
  var getCurrentBookmarkDataSchema = external_exports.object({
    url: optionalUrlSchema
  }).passthrough().optional();
  var getTagsForUrlDataSchema = external_exports.object({
    url: requiredUrlSchema
  }).strict();
  var saveBookmarkDataSchema = external_exports.object({
    url: requiredUrlSchema,
    tags: external_exports.union([external_exports.array(external_exports.string()), external_exports.string()]).optional(),
    description: external_exports.string().optional(),
    toread: external_exports.union([external_exports.boolean(), external_exports.number(), external_exports.enum(["yes", "no"])]).optional(),
    shared: external_exports.union([external_exports.boolean(), external_exports.number(), external_exports.enum(["yes", "no"])]).optional(),
    title: external_exports.string().optional()
  }).passthrough();
  var deleteBookmarkDataSchema = external_exports.object({
    url: requiredUrlSchema
  }).strict();
  var saveTagDataSchema = external_exports.object({
    url: requiredUrlSchema,
    value: external_exports.string().min(1)
  }).strict();
  var deleteTagDataSchema = external_exports.object({
    url: requiredUrlSchema,
    value: external_exports.string().min(1)
  }).strict();

  // src/core/message-handler.js
  var MESSAGE_TYPES = {
    // Data retrieval
    GET_CURRENT_BOOKMARK: "getCurrentBookmark",
    GET_TAGS_FOR_URL: "getTagsForUrl",
    // [IMPL-URL_TAGS_DISPLAY] Centralized tag storage for tests and UI
    GET_RECENT_BOOKMARKS: "getRecentBookmarks",
    GET_LOCAL_BOOKMARKS_FOR_INDEX: "getLocalBookmarksForIndex",
    // [REQ-LOCAL_BOOKMARKS_INDEX] [ARCH-LOCAL_BOOKMARKS_INDEX] [IMPL-LOCAL_BOOKMARKS_INDEX]
    GET_AGGREGATED_BOOKMARKS_FOR_INDEX: "getAggregatedBookmarksForIndex",
    // [ARCH-STORAGE_INDEX_AND_ROUTER] local + file with storage column
    GET_OPTIONS: "getOptions",
    GET_TAB_ID: "getTabId",
    // Bookmark operations
    SAVE_BOOKMARK: "saveBookmark",
    DELETE_BOOKMARK: "deleteBookmark",
    SAVE_TAG: "saveTag",
    DELETE_TAG: "deleteTag",
    // [ARCH-LOCAL_STORAGE_PROVIDER] Storage mode switch (handled by service worker)
    SWITCH_STORAGE_MODE: "switchStorageMode",
    // [REQ-PER_BOOKMARK_STORAGE_BACKEND] [IMPL-BOOKMARK_ROUTER] Per-bookmark storage (move UI)
    GET_STORAGE_BACKEND_FOR_URL: "getStorageBackendForUrl",
    MOVE_BOOKMARK_TO_STORAGE: "moveBookmarkToStorage",
    // UI operations
    TOGGLE_HOVER: "toggleHover",
    HIDE_OVERLAY: "hideOverlay",
    REFRESH_DATA: "refreshData",
    REFRESH_HOVER: "refreshHover",
    BOOKMARK_UPDATED: "bookmarkUpdated",
    // [TOGGLE-SYNC-MESSAGE-001] - New message type
    TAG_UPDATED: "TAG_UPDATED",
    // [TAG-SYNC-MESSAGE-001] - New message type for tag synchronization
    // Site management
    INHIBIT_URL: "inhibitUrl",
    // Search operations
    SEARCH_TITLE: "searchTitle",
    SEARCH_TITLE_TEXT: "searchTitleText",
    // [IMMUTABLE-REQ-TAG-002] Tab search operations
    SEARCH_TABS: "searchTabs",
    GET_SEARCH_HISTORY: "getSearchHistory",
    CLEAR_SEARCH_STATE: "clearSearchState",
    // [IMMUTABLE-REQ-TAG-003] Recent tags operations
    ADD_TAG_TO_RECENT: "addTagToRecent",
    GET_USER_RECENT_TAGS: "getUserRecentTags",
    GET_SHARED_MEMORY_STATUS: "getSharedMemoryStatus",
    // Content script lifecycle
    CONTENT_SCRIPT_READY: "contentScriptReady",
    // Overlay configuration
    UPDATE_OVERLAY_CONFIG: "updateOverlayConfig",
    GET_OVERLAY_CONFIG: "getOverlayConfig",
    // Development/debug
    DEV_COMMAND: "devCommand",
    ECHO: "echo",
    // [REQ-AI_TAGGING_POPUP] [ARCH-AI_TAGGING_FLOW] AI tagging
    GET_PAGE_CONTENT: "GET_PAGE_CONTENT",
    GET_AI_TAGS: "GET_AI_TAGS",
    GET_SESSION_TAGS: "getSessionTags",
    RECORD_SESSION_TAGS: "recordSessionTags",
    // [REQ-SIDE_PANEL_TAGS_TREE] [ARCH-SIDE_PANEL_TAGS_TREE] [IMPL-SIDE_PANEL_TAGS_TREE] Message type for opening side panel. Implements contract: popup sends this type; SW handles in onMessage and calls chrome.sidePanel.open({ windowId }).
    OPEN_SIDE_PANEL: "OPEN_SIDE_PANEL"
  };

  // src/features/ai/readability-extract.js
  var import_readability = __toESM(require_readability(), 1);
  var DEFAULT_MAX_LENGTH = 16e3;
  function extractPageContent(document2, options = {}) {
    const maxLength = options.maxLength ?? DEFAULT_MAX_LENGTH;
    if (!document2 || typeof document2.cloneNode !== "function") {
      return { title: "", textContent: "" };
    }
    let title = "";
    let textContent = "";
    try {
      const clone2 = document2.cloneNode(true);
      const reader = new import_readability.Readability(clone2);
      const article = reader.parse();
      if (article) {
        title = article.title && String(article.title).trim() || document2.title && String(document2.title).trim() || "";
        textContent = article.textContent && String(article.textContent).trim() || "";
      } else {
        title = document2.title && String(document2.title).trim() || "";
        const body = document2.body;
        textContent = body && body.innerText && String(body.innerText).trim() ? String(body.innerText).trim() : "";
      }
    } catch {
      title = document2.title && String(document2.title).trim() || "";
      const body = document2.body;
      textContent = body && body.innerText ? String(body.innerText).trim() : "";
    }
    if (textContent.length > maxLength) {
      textContent = textContent.slice(0, maxLength);
    }
    return { title, textContent };
  }

  // src/features/content/content-main.js
  init_utils();

  // src/shared/ui-inspector.js
  var MAX_ACTIONS = 50;
  var _enabledOverride = false;
  function hasLocalStorage() {
    try {
      return typeof localStorage !== "undefined";
    } catch {
      return false;
    }
  }
  function isEnabled() {
    if (_enabledOverride) return true;
    if (hasLocalStorage() && localStorage.getItem("DEBUG_HOVERBOARD_UI")) return true;
    return false;
  }
  var _actions = [];
  function sanitize(data) {
    if (data == null) return data;
    if (typeof data !== "object") return data;
    const o = {};
    for (const [k, v] of Object.entries(data)) {
      if (k === "token" || k === "apiToken" || k.toLowerCase().includes("password")) {
        o[k] = "[REDACTED]";
      } else {
        o[k] = typeof v === "object" && v !== null && !Array.isArray(v) ? sanitize(v) : v;
      }
    }
    return o;
  }
  function recordAction(actionId, payload, surface) {
    if (!isEnabled()) return;
    _actions.push({
      actionId,
      payload: payload != null ? sanitize(typeof payload === "object" ? payload : { value: payload }) : void 0,
      surface: surface || "popup",
      ts: Date.now()
    });
    if (_actions.length > MAX_ACTIONS) _actions.shift();
  }

  // src/features/content/content-main.js
  safariEnhancements.runtime.onMessage.addListener((message, _sender, sendResponse) => {
    if (message.type !== "GET_PAGE_CONTENT") return;
    try {
      const result = extractPageContent(document);
      sendResponse({ success: true, data: result });
    } catch (e) {
      sendResponse({ success: false, error: e.message });
    }
    return true;
  });
  var HoverboardContentScript = class {
    constructor() {
      this.tabId = null;
      this.pageUrl = window.location.href;
      this.pageTitle = document.title;
      this.messageClient = new MessageClient();
      this.domUtils = new DOMUtils();
      this.overlayManager = new OverlayManager(document, {
        overlayPosition: "top-right",
        messageTimeout: 3e3,
        showRecentTags: true,
        maxRecentTags: 10,
        overlayAnimations: true,
        overlayDraggable: false,
        // Transparency settings for UI-005
        overlayTransparencyMode: "nearly-transparent",
        overlayPositionMode: "bottom-fixed",
        overlayOpacityNormal: 0.05,
        overlayOpacityHover: 0.15,
        overlayOpacityFocus: 0.25,
        overlayAdaptiveVisibility: true,
        overlayBlurAmount: 2
      });
      this.currentBookmark = null;
      this.isInitialized = false;
      this.overlayActive = false;
      this.config = null;
      this.init();
    }
    async init() {
      try {
        debugLog2("CONTENT-SCRIPT", "Initializing content script");
        await this.domUtils.waitForDOM();
        debugLog2("CONTENT-SCRIPT", "DOM ready");
        this.setupMessageListeners();
        debugLog2("CONTENT-SCRIPT", "Message listeners set up");
        await this.initializeTabId();
        debugLog2("CONTENT-SCRIPT", "Tab ID initialized:", this.tabId);
        await this.loadConfiguration();
        debugLog2("CONTENT-SCRIPT", "Options loaded:", this.config);
        this.overlayManager.config = { ...this.overlayManager.config, ...this.config };
        this.overlayManager.transparencyMode = this.config.overlayTransparencyMode || "nearly-transparent";
        this.overlayManager.positionMode = this.config.overlayPositionMode || "bottom-fixed";
        this.overlayManager.adaptiveVisibility = this.config.overlayAdaptiveVisibility || true;
        debugLog2("CONTENT-SCRIPT", "Overlay manager configured with transparency settings", {
          transparencyMode: this.overlayManager.transparencyMode,
          positionMode: this.overlayManager.positionMode,
          adaptiveVisibility: this.overlayManager.adaptiveVisibility
        });
        await this.notifyReady();
        debugLog2("CONTENT-SCRIPT", "Ready notification sent");
        await this.loadCurrentPageData();
        debugLog2("CONTENT-SCRIPT", "Current page data loaded:", this.currentBookmark);
        this.isInitialized = true;
        debugLog2("CONTENT-SCRIPT", "Content script initialization complete");
      } catch (error48) {
        console.error("Hoverboard: Failed to initialize content script:", error48);
      }
    }
    setupMessageListeners() {
      safariEnhancements.runtime.onMessage.addListener((message, sender, sendResponse) => {
        this.handleMessage(message, sender, sendResponse);
        return true;
      });
    }
    async handleMessage(message, sender, sendResponse) {
      try {
        recordAction(message.type, message.data, "content");
        switch (message.type) {
          case "TOGGLE_HOVER": {
            await this.toggleHover();
            const newState = {
              isVisible: this.overlayActive,
              hasBookmark: !!this.currentBookmark
            };
            sendResponse({ success: true, data: newState });
            break;
          }
          case "HIDE_OVERLAY":
            this.overlayManager.hide();
            sendResponse({ success: true });
            break;
          case "REFRESH_DATA":
            await this.refreshData();
            sendResponse({ success: true });
            break;
          case "REFRESH_HOVER":
            await this.refreshHover();
            sendResponse({ success: true });
            break;
          case "CLOSE_IF_TO_READ":
            this.handleCloseIfToRead(message.data);
            sendResponse({ success: true });
            break;
          case "PING":
            sendResponse({ success: true, data: "pong" });
            break;
          case "SHOW_BOOKMARK_DIALOG":
            await this.showBookmarkDialog(message.data);
            sendResponse({ success: true });
            break;
          case "TOGGLE_HOVER_OVERLAY":
            await this.toggleHoverOverlay();
            sendResponse({ success: true, data: { active: this.overlayActive } });
            break;
          case "UPDATE_CONFIG":
            this.config = { ...this.config, ...message.data };
            sendResponse({ success: true });
            break;
          case "updateOverlayTransparency":
            this.handleUpdateOverlayTransparency(message.config);
            sendResponse({ success: true });
            break;
          case "CHECK_PAGE_STATE": {
            const pageState = await this.getPageState();
            sendResponse({ success: true, data: pageState });
            break;
          }
          // [TOGGLE-SYNC-CONTENT-001] - Handle bookmark updates from external sources
          case "BOOKMARK_UPDATED":
            await this.handleBookmarkUpdated(message.data);
            sendResponse({ success: true });
            break;
          case "TAG_UPDATED":
            await this.handleTagUpdated(message.data);
            sendResponse({ success: true });
            break;
          // [POPUP-CLOSE-BEHAVIOR-ARCH-012] - Handle overlay state queries from popup
          case "GET_OVERLAY_STATE": {
            const overlayState = {
              isVisible: this.overlayActive,
              hasBookmark: !!this.currentBookmark,
              overlayElement: !!document.getElementById("hoverboard-overlay")
            };
            sendResponse({ success: true, data: overlayState });
            break;
          }
          // [IMPL-SELECTION_TO_TAG_INPUT] [ARCH-SELECTION_TO_TAG_INPUT] [REQ-SELECTION_TO_TAG_INPUT] [REQ-TAG_MANAGEMENT] Return page selection for popup tag prefill
          case "GET_PAGE_SELECTION": {
            const selection = typeof window.getSelection === "function" ? window.getSelection().toString() : "";
            sendResponse({ success: true, data: { selection } });
            break;
          }
          // [REQ-AI_TAGGING_POPUP] GET_PAGE_CONTENT is handled by the early listener above (before init) so popup gets a response without waiting for waitForDOM().
          default:
            console.warn("Unknown message type:", message.type);
            sendResponse({ success: false, error: "Unknown message type" });
        }
      } catch (error48) {
        console.error("Message handling error:", error48);
        sendResponse({ success: false, error: error48.message });
      }
    }
    async initializeTabId() {
      try {
        const response = await this.messageClient.sendMessage({
          type: MESSAGE_TYPES.GET_TAB_ID,
          data: { url: this.pageUrl }
        });
        const actualResponse = response.success ? response.data : response;
        this.tabId = actualResponse.tabId;
        console.log("Content script tab ID:", this.tabId);
      } catch (error48) {
        console.error("Failed to get tab ID:", error48);
      }
    }
    async loadConfiguration() {
      try {
        const response = await this.messageClient.sendMessage({
          type: MESSAGE_TYPES.GET_OPTIONS
        });
        const actualResponse = response.success ? response.data : response;
        if (actualResponse) {
          this.config = { ...this.getDefaultConfig(), ...actualResponse };
          console.log("\u{1F4CB} Configuration loaded:", this.config);
        } else {
          this.config = this.getDefaultConfig();
        }
      } catch (error48) {
        console.error("\u274C Failed to load configuration:", error48);
        this.config = this.getDefaultConfig();
      }
    }
    getDefaultConfig() {
      return {
        showHoverOnPageLoad: false,
        hoverShowTooltips: false,
        inhibitSitesOnPageLoad: true,
        uxAutoCloseTimeout: 0,
        //  UI-005: Transparent overlay -  Enhanced transparency system
        overlayTransparencyMode: "nearly-transparent",
        overlayPositionMode: "bottom-fixed",
        overlayOpacityNormal: 0.05,
        overlayOpacityHover: 0.15,
        overlayOpacityFocus: 0.25,
        overlayAdaptiveVisibility: true,
        overlayBlurAmount: 2
      };
    }
    async notifyReady() {
      try {
        await this.messageClient.sendMessage({
          type: MESSAGE_TYPES.CONTENT_SCRIPT_READY,
          data: {
            url: this.pageUrl,
            title: this.pageTitle,
            tabId: this.tabId
          }
        });
      } catch (error48) {
        console.error("Failed to notify ready:", error48);
      }
    }
    async loadCurrentPageData() {
      try {
        debugLog2("CONTENT-SCRIPT", "Loading current page data");
        debugLog2("CONTENT-SCRIPT", "Request data:", {
          url: this.pageUrl,
          title: this.pageTitle,
          tabId: this.tabId
        });
        const response = await this.messageClient.sendMessage({
          type: MESSAGE_TYPES.GET_CURRENT_BOOKMARK,
          data: {
            url: this.pageUrl,
            title: this.pageTitle,
            tabId: this.tabId
          }
        });
        debugLog2("CONTENT-SCRIPT", "Received response:", response);
        const actualResponse = response.success ? response.data : response;
        if (actualResponse.blocked) {
          debugLog2("CONTENT-SCRIPT", "Site is blocked from processing");
          return;
        }
        this.currentBookmark = actualResponse.data || actualResponse;
        debugLog2("CONTENT-SCRIPT", "Current bookmark set:", this.currentBookmark);
        const options = await this.getOptions();
        debugLog2("CONTENT-SCRIPT", "Options for page load:", options);
        if (options.showHoverOnPageLoad) {
          debugLog2("CONTENT-SCRIPT", "Showing hover on page load");
          await this.showHoverWithDelay(options);
        }
      } catch (error48) {
        console.error("Failed to load current page data:", error48);
        debugLog2("CONTENT-SCRIPT", "Error loading page data:", error48);
      }
    }
    async showHoverWithDelay(options) {
      const delay = options.showHoverDelay || 1e3;
      setTimeout(async () => {
        try {
          if (this.shouldShowHoverOnPageLoad(options)) {
            await this.showHover(false);
            if (options.uxAutoCloseTimeout > 0) {
              setTimeout(() => {
                this.overlayManager.hideOverlay();
              }, options.uxAutoCloseTimeout);
            }
          }
        } catch (error48) {
          console.error("Failed to show hover on page load:", error48);
        }
      }, delay);
    }
    shouldShowHoverOnPageLoad(options) {
      if (!this.currentBookmark) return false;
      const hasBookmark = this.currentBookmark.hash && this.currentBookmark.hash.length > 0;
      const hasTags = this.currentBookmark.tags && this.currentBookmark.tags.length > 0;
      if (options.showHoverOPLOnlyIfNoTags && hasTags) return false;
      if (options.showHoverOPLOnlyIfSomeTags && !hasTags) return false;
      return true;
    }
    async toggleHover() {
      if (this.overlayManager.isVisible) {
        this.overlayManager.hide();
      } else {
        await this.showHover(true);
      }
    }
    async showHover(userTriggered = false) {
      try {
        debugLog2("CONTENT-SCRIPT", "Showing hover", { userTriggered });
        if (userTriggered) {
          debugLog2("CONTENT-SCRIPT", "Refreshing bookmark data for user-triggered display");
          await this.loadCurrentPageData();
        }
        if (!this.currentBookmark) {
          debugLog2("CONTENT-SCRIPT", "No bookmark data available");
          console.warn("No bookmark data available for hover display");
          return;
        }
        debugLog2("CONTENT-SCRIPT", "Current bookmark data:", this.currentBookmark);
        this.overlayManager.show({
          bookmark: this.currentBookmark,
          pageTitle: this.pageTitle,
          pageUrl: this.pageUrl,
          tabId: this.tabId,
          userTriggered
        });
        debugLog2("CONTENT-SCRIPT", "Overlay display request sent");
      } catch (error48) {
        console.error("Failed to show hover:", error48);
        debugLog2("CONTENT-SCRIPT", "Error showing hover:", error48);
      }
    }
    async refreshData() {
      try {
        await this.loadCurrentPageData();
      } catch (error48) {
        console.error("Failed to refresh data:", error48);
      }
    }
    async refreshHover() {
      try {
        this.overlayManager.hideOverlay();
        await this.showHover(true);
      } catch (error48) {
        console.error("Failed to refresh hover:", error48);
      }
    }
    handleCloseIfToRead(data) {
      if (this.currentBookmark && this.currentBookmark.toread === "yes") {
        console.log('Closing tab - bookmark is marked "read later"');
        window.close();
      }
    }
    // Public API for other modules
    getCurrentBookmark() {
      return this.currentBookmark;
    }
    getTabId() {
      return this.tabId;
    }
    getPageInfo() {
      return {
        url: this.pageUrl,
        title: this.pageTitle,
        tabId: this.tabId
      };
    }
    isReady() {
      return this.isInitialized;
    }
    async showBookmarkDialog(data) {
      const event = { clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 };
      await this.showHoverOverlay(document.body, event);
      if (this.currentOverlay && data) {
        if (data.url) {
          this.currentOverlay.querySelector(".hoverboard-url-input").value = data.url;
        }
        if (data.title) {
          this.currentOverlay.querySelector(".hoverboard-title-input").value = data.title;
        }
        if (data.description) {
          this.currentOverlay.querySelector(".hoverboard-description-input").value = data.description;
        }
      }
    }
    async toggleHoverOverlay() {
      if (this.overlayActive) {
        this.hideHoverOverlay();
      } else {
        const event = { clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 };
        await this.showHoverOverlay(document.body, event);
      }
    }
    async showHoverOverlay(element, event) {
      try {
        console.log("\u{1F3AF} Showing hover overlay");
        const overlay = this.createOverlayElement(element, event);
        document.body.appendChild(overlay);
        this.overlayActive = true;
        this.currentOverlay = overlay;
        this.setupOverlayHandlers(overlay);
        if (this.config.uxAutoCloseTimeout > 0) {
          setTimeout(() => {
            this.hideHoverOverlay();
          }, this.config.uxAutoCloseTimeout);
        }
      } catch (error48) {
        console.error("\u274C Failed to show hover overlay:", error48);
      }
    }
    createOverlayElement(element, event) {
      const overlay = document.createElement("div");
      overlay.className = "hoverboard-overlay";
      overlay.innerHTML = `
      <div class="hoverboard-overlay-content">
        <div class="hoverboard-overlay-header">
          <span class="hoverboard-overlay-title">\u{1F4CC} Add to Pinboard</span>
          <button class="hoverboard-overlay-close">\xD7</button>
        </div>
        <div class="hoverboard-overlay-body">
          <input type="text" class="hoverboard-url-input" placeholder="URL" value="${window.location.href}">
          <input type="text" class="hoverboard-title-input" placeholder="Title" value="${document.title}">
          <textarea class="hoverboard-description-input" placeholder="Description"></textarea>
          <input type="text" class="hoverboard-tags-input" placeholder="Tags (comma separated)">
          <div class="hoverboard-overlay-actions">
            <button class="hoverboard-save-button">Save Bookmark</button>
            <label class="hoverboard-private-label">
              <input type="checkbox" class="hoverboard-private-checkbox"> Private
            </label>
          </div>
        </div>
      </div>
    `;
      overlay.style.position = "fixed";
      overlay.style.left = `${Math.min(event.clientX, window.innerWidth - 350)}px`;
      overlay.style.top = `${Math.min(event.clientY, window.innerHeight - 200)}px`;
      overlay.style.zIndex = "999999";
      return overlay;
    }
    setupOverlayHandlers(overlay) {
      const closeButton = overlay.querySelector(".hoverboard-overlay-close");
      closeButton.addEventListener("click", () => {
        this.hideHoverOverlay();
      });
      const saveButton = overlay.querySelector(".hoverboard-save-button");
      saveButton.addEventListener("click", () => {
        this.saveBookmarkFromOverlay(overlay);
      });
      document.addEventListener("click", (event) => {
        if (!overlay.contains(event.target)) {
          this.hideHoverOverlay();
        }
      }, { once: true });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          this.hideHoverOverlay();
        }
      }, { once: true });
    }
    hideHoverOverlay() {
      if (this.currentOverlay) {
        this.currentOverlay.remove();
        this.currentOverlay = null;
        this.overlayActive = false;
        console.log("\u{1F3AF} Hover overlay hidden");
      }
    }
    async saveBookmarkFromOverlay(overlay) {
      try {
        const url2 = overlay.querySelector(".hoverboard-url-input").value;
        const title = overlay.querySelector(".hoverboard-title-input").value;
        const description = overlay.querySelector(".hoverboard-description-input").value;
        const tags = overlay.querySelector(".hoverboard-tags-input").value;
        const isPrivate = overlay.querySelector(".hoverboard-private-checkbox").checked;
        const response = await safariEnhancements.runtime.sendMessage({
          type: "SAVE_BOOKMARK",
          data: { url: url2, title, description, tags, private: isPrivate }
        });
        if (response.success) {
          console.log("\u2705 Bookmark saved successfully");
          this.hideHoverOverlay();
        } else {
          console.error("\u274C Failed to save bookmark:", response.error);
        }
      } catch (error48) {
        console.error("\u274C Save bookmark failed:", error48);
      }
    }
    async getOptions() {
      try {
        const response = await this.messageClient.sendMessage({
          type: MESSAGE_TYPES.GET_OPTIONS
        });
        const actualResponse = response.success ? response.data : response;
        return actualResponse;
      } catch (error48) {
        console.error("Failed to get options:", error48);
        return {};
      }
    }
    async getPageState() {
      return {
        url: window.location.href,
        title: document.title,
        overlayActive: this.overlayActive,
        isInitialized: this.isInitialized
      };
    }
    // [TOGGLE-SYNC-CONTENT-001] - Handle bookmark updates from external sources
    async handleBookmarkUpdated(bookmarkData) {
      try {
        if (!bookmarkData || !bookmarkData.url) {
          console.warn("[TOGGLE-SYNC-CONTENT-001] Ignoring malformed bookmark update:", bookmarkData);
          return;
        }
        this.currentBookmark = bookmarkData;
        if (this.overlayManager.isVisible) {
          const updatedContent = {
            bookmark: bookmarkData,
            pageTitle: this.pageTitle,
            pageUrl: this.pageUrl
          };
          this.overlayManager.show(updatedContent);
        }
        debugLog2("CONTENT-SCRIPT", "[TOGGLE-SYNC-CONTENT-001] Bookmark updated from external source", bookmarkData);
      } catch (error48) {
        debugError("CONTENT-SCRIPT", "[TOGGLE-SYNC-CONTENT-001] Failed to handle bookmark update:", error48);
      }
    }
    // [TAG-SYNC-CONTENT-001] - Handle tag updates from popup or other sources
    async handleTagUpdated(tagUpdateData) {
      try {
        if (!tagUpdateData || !tagUpdateData.url || !Array.isArray(tagUpdateData.tags)) {
          console.warn("[TAG-SYNC-CONTENT-001] Ignoring malformed tag update:", tagUpdateData);
          return;
        }
        if (this.currentBookmark && this.currentBookmark.url === tagUpdateData.url) {
          this.currentBookmark.tags = tagUpdateData.tags;
          if (this.overlayManager.isVisible) {
            const updatedContent = {
              bookmark: this.currentBookmark,
              pageTitle: this.pageTitle,
              pageUrl: this.pageUrl
            };
            this.overlayManager.show(updatedContent);
          }
          debugLog2("CONTENT-SCRIPT", "[TAG-SYNC-CONTENT-001] Overlay updated with new tags", tagUpdateData.tags);
        }
      } catch (error48) {
        debugError("CONTENT-SCRIPT", "[TAG-SYNC-CONTENT-001] Failed to handle tag update:", error48);
      }
    }
    handleUpdateOverlayTransparency(config2) {
      try {
        console.log("Updating overlay transparency configuration:", config2);
        this.config = { ...this.config, ...config2 };
        if (this.overlayManager) {
          this.overlayManager.updateConfig(config2);
          if (this.overlayManager.isVisible) {
            this.overlayManager.applyTransparencyMode();
          }
        }
        console.log("Overlay transparency configuration updated successfully");
      } catch (error48) {
        console.error("Failed to update overlay transparency:", error48);
      }
    }
  };
  var hoverboardContentScript;
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      hoverboardContentScript = new HoverboardContentScript();
    });
  } else {
    hoverboardContentScript = new HoverboardContentScript();
  }
  window.hoverboardContentScript = hoverboardContentScript;
})();
