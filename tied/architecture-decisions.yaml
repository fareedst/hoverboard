ARCH-TIED_STRUCTURE:
  name: TIED Project Structure
  status: Active
  cross_references:
    - REQ-TIED_SETUP
  rationale:
    why: Keeps documentation close to code but organized in a dedicated namespace
    problems_solved:
      - Documentation scattered across project
      - Difficulty finding all context in one place
      - Meta-documentation mixed with source code
    benefits:
      - Clear separation of concerns
      - Standard project layout for AI agents
      - Easy discovery of all TIED documentation
      - Testable and maintainable structure
  alternatives_considered:
    - name: Root-level files
      pros:
        - Immediately visible in repository root
      cons:
        - Clutters the root directory
        - No clear organization
      rejected_reason: Creates too much clutter at project root
    - name: .github or .docs folder
      pros:
        - Common convention for documentation
      cons:
        - Too generic for methodology-specific files
        - .github is typically for GitHub workflows
      rejected_reason: tied/ is more specific to the methodology
  implementation_approach:
    summary: Create dedicated tied/ directory with YAML indexes and detail subdirectories
    details:
      - Create tied/ directory at project root
      - 'Populate with YAML index files: requirements.yaml, architecture-decisions.yaml, implementation-decisions.yaml, semantic-tokens.yaml'
      - 'Create detail subdirectories: requirements/, architecture-decisions/, implementation-decisions/'
      - 'Add guide files: semantic-tokens.md, processes.md'
  traceability:
    requirements:
      - REQ-TIED_SETUP
    implementation:
      - IMPL-TIED_FILES
    tests:
      - TestTIEDSetup_REQ_TIED_SETUP
    code_annotations:
      - IMPL-TIED_FILES
      - ARCH-TIED_STRUCTURE
      - REQ-TIED_SETUP
  related_decisions:
    depends_on:
      - REQ-TIED_SETUP
    informs:
      - IMPL-TIED_FILES
    see_also: []
  detail_file: architecture-decisions/ARCH-TIED_STRUCTURE.yaml
  metadata:
    created:
      date: 2025-12-18T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-06T00:00:00.000Z
      author: AI Agent
      reason: Restructured to v1.5.0 schema with machine-parseable fields
    last_validated:
      date: 2026-02-06T00:00:00.000Z
      validator: AI Agent
      result: pass
ARCH-MODULE_VALIDATION:
  name: Module Validation Strategy
  status: Active
  cross_references:
    - REQ-MODULE_VALIDATION
  rationale:
    why: To eliminate bugs related to code complexity by ensuring each module works correctly in isolation
    problems_solved:
      - Integration complexity causing difficult-to-debug issues
      - Bugs discovered too late in development cycle
      - Module contracts not properly validated
    benefits:
      - Bugs caught early before integration
      - Reduced integration complexity
      - Easier debugging by isolating issues
      - Enables parallel module development
      - Clear module boundaries and contracts
  alternatives_considered:
    - name: Big Bang Integration
      pros:
        - Faster initial integration
      cons:
        - Too complex to debug
        - Bugs compound during integration
        - Difficult to isolate issues
      rejected_reason: Makes debugging too difficult and bugs compound
    - name: Minimal Validation
      pros:
        - Faster development cycle
      cons:
        - Insufficient to catch complexity bugs
        - Doesn't validate contracts properly
      rejected_reason: Insufficient validation leads to integration issues
    - name: Post-Integration Validation Only
      pros:
        - All validation done at once
      cons:
        - Doesn't catch module-level bugs early
        - Increases debugging complexity
      rejected_reason: Bugs discovered too late, making fixes expensive
  implementation_approach:
    summary: Independent module validation before integration with comprehensive testing strategy
    details:
      - Identify modules and document boundaries before development
      - Define module interfaces and contracts explicitly
      - Specify validation criteria for each module
      - Unit test modules with mocked dependencies
      - Integration test with test doubles (mocks, stubs, fakes)
      - Validate contracts (input/output validation)
      - Test edge cases and error handling
      - Document validation results before integration
      - Only integrate after validation passes
  traceability:
    requirements:
      - REQ-MODULE_VALIDATION
    implementation:
      - IMPL-MODULE_VALIDATION
    tests:
      - testModuleName_IndependentValidation_REQ_MODULE_VALIDATION
    code_annotations:
      - IMPL-MODULE_VALIDATION
      - REQ-MODULE_VALIDATION
  related_decisions:
    depends_on:
      - REQ-MODULE_VALIDATION
    informs:
      - IMPL-MODULE_VALIDATION
    see_also: []
  detail_file: architecture-decisions/ARCH-MODULE_VALIDATION.yaml
  metadata:
    created:
      date: 2025-12-18T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-06T00:00:00.000Z
      author: AI Agent
      reason: Restructured to v1.5.0 schema with machine-parseable fields
    last_validated:
      date: 2026-02-06T00:00:00.000Z
      validator: AI Agent
      result: pass
ARCH-LANGUAGE_SELECTION:
  name: Language and Runtime Selection
  status: Template
  cross_references: []
  rationale:
    why: Why this language/runtime was chosen for the project
    problems_solved:
      - Problem 1 that language solves
    benefits:
      - Benefit 1 of chosen language
  alternatives_considered:
    - name: Language A
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why it was rejected
    - name: Language B
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why it was rejected
  implementation_approach:
    summary: How the selected language/runtime will be used in the project
    details:
      - Detail 1
      - Detail 2
  traceability:
    requirements:
      - REQ-*
    implementation:
      - IMPL-*
    tests:
      - testFeatureName_ARCH_LANGUAGE_SELECTION
    code_annotations:
      - ARCH-LANGUAGE_SELECTION
  related_decisions:
    depends_on: []
    informs: []
    see_also: []
  detail_file: architecture-decisions/ARCH-LANGUAGE_SELECTION.md
  metadata:
    created:
      date: YYYY-MM-DD
      author: agent/contributor
    last_updated:
      date: YYYY-MM-DD
      author: agent/contributor
      reason: Initial creation
    last_validated:
      date: YYYY-MM-DD
      validator: agent/contributor
      result: pass
ARCH-EXAMPLE_DECISION:
  name: Core Architecture Example
  status: Template
  cross_references:
    - REQ-EXAMPLE_FEATURE
  rationale:
    why: Why this architectural decision was made
    problems_solved:
      - Problem 1 that this decision solves
      - Problem 2
    benefits:
      - Benefit 1 of this decision
      - Benefit 2
  alternatives_considered:
    - name: Alternative 1
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why it was rejected
    - name: Alternative 2
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why it was rejected
  implementation_approach:
    summary: High-level description of the architectural approach
    details:
      - Key component 1
      - Key component 2
      - Integration point 1
  traceability:
    requirements:
      - REQ-EXAMPLE_FEATURE
    implementation:
      - IMPL-EXAMPLE_IMPLEMENTATION
    tests:
      - testFeatureName_ARCH_EXAMPLE_DECISION
    code_annotations:
      - ARCH-EXAMPLE_DECISION
  related_decisions:
    depends_on:
      - REQ-EXAMPLE_FEATURE
    informs:
      - IMPL-EXAMPLE_IMPLEMENTATION
    see_also: []
  detail_file: architecture-decisions/ARCH-EXAMPLE_DECISION.yaml
  metadata:
    created:
      date: YYYY-MM-DD
      author: agent/contributor
    last_updated:
      date: YYYY-MM-DD
      author: agent/contributor
      reason: Initial creation
    last_validated:
      date: YYYY-MM-DD
      validator: agent/contributor
      result: pass
ARCH-EXT_IDENTITY:
  name: Extension Identity Architecture
  status: Active
  cross_references:
    - REQ-EXTENSION_IDENTITY
  rationale:
    why: Core extension identity fundamental to user recognition
    problems_solved:
      - Brand consistency risk
      - User expectation breaks
    benefits:
      - Consistent identity
      - Clear value proposition
  alternatives_considered:
    - name: Multi-platform native apps
      pros:
        - Deep OS integration
      cons:
        - Loss of browser integration benefits
      rejected_reason: Browser extension provides better integration
    - name: Web app approach
      pros:
        - No extension store requirements
      cons:
        - Loses browser integration
      rejected_reason: Cannot inject into pages
  implementation_approach:
    summary: Browser extension with content script injection for Pinboard integration
    details:
      - Chrome/Chromium target platform
      - Content script injection for non-intrusive interaction
      - Pinboard.in bookmarking interface
  traceability:
    requirements:
      - REQ-EXTENSION_IDENTITY
    implementation:
      - IMPL-EXT_IDENTITY
    tests: []
    code_annotations:
      - ARCH-EXT_IDENTITY
  related_decisions:
    depends_on: []
    informs:
      - IMPL-EXT_IDENTITY
    see_also: []
  detail_file: architecture-decisions/ARCH-EXT_IDENTITY.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-PINBOARD_API:
  name: Pinboard API Integration Architecture
  status: Active
  cross_references:
    - REQ-PINBOARD_COMPATIBILITY
    - REQ-SMART_BOOKMARKING
  rationale:
    why: Pinboard API is core data source
    problems_solved:
      - Data access reliability
      - Rate limiting issues
    benefits:
      - Secure token auth
      - Reliable API access
  alternatives_considered:
    - name: OAuth
      pros:
        - More complex auth
      cons:
        - Pinboard uses token auth
      rejected_reason: Pinboard API standard is token-based
    - name: Caching only
      pros:
        - Reduced API calls
      cons:
        - Stale data
      rejected_reason: Real-time sync required
  implementation_approach:
    summary: Token-based auth with rate limiting, retry logic, error handling
    details:
      - 'Endpoints: /posts/get, /posts/recent, /posts/add, /posts/delete'
      - 429 status retry logic
      - 401 auth error handling
  traceability:
    requirements:
      - REQ-PINBOARD_COMPATIBILITY
      - REQ-SMART_BOOKMARKING
    implementation:
      - IMPL-PINBOARD_API
    tests: []
    code_annotations:
      - ARCH-PINBOARD_API
  related_decisions:
    depends_on: []
    informs:
      - IMPL-PINBOARD_API
    see_also: []
  detail_file: architecture-decisions/ARCH-PINBOARD_API.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-STORAGE:
  name: Storage Strategy
  status: Active
  cross_references:
    - REQ-CHROME_STORAGE_USAGE
    - REQ-CONFIG_PORTABILITY
  rationale:
    why: Cross-device sync and privacy preservation
    problems_solved:
      - Settings lost across devices
      - Privacy violations
    benefits:
      - Cross-device settings
      - Data portability
  alternatives_considered:
    - name: All local storage
      pros:
        - Simpler
      cons:
        - No cross-device sync
      rejected_reason: Users need settings sync
    - name: External storage
      pros:
        - More capacity
      cons:
        - Privacy concerns
      rejected_reason: Privacy is core value
  implementation_approach:
    summary: chrome.storage.sync for settings, local for temp data, export/import workflows
    details:
      - Sync storage for user settings
      - Local storage for temporary data
      - Export/import for config portability
  traceability:
    requirements:
      - REQ-CHROME_STORAGE_USAGE
      - REQ-CONFIG_PORTABILITY
    implementation:
      - IMPL-STORAGE
    tests: []
    code_annotations:
      - ARCH-STORAGE
  related_decisions:
    depends_on: []
    informs:
      - IMPL-STORAGE
    see_also: []
  detail_file: architecture-decisions/ARCH-STORAGE.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-TAG_SYSTEM:
  name: Tag System Architecture
  status: Active
  cross_references:
    - REQ-RECENT_TAGS_SYSTEM
    - REQ-TAG_MANAGEMENT
    - REQ-TAG_INPUT_SANITIZATION
  rationale:
    why: Recent tags improve productivity, sanitization prevents XSS
    problems_solved:
      - Slow tag entry
      - XSS vulnerabilities
    benefits:
      - Fast tag reuse
      - Secure tag handling
  alternatives_considered:
    - name: No caching
      pros:
        - Simpler
      cons:
        - Too many API calls
      rejected_reason: Performance issues
    - name: Local-only tags
      pros:
        - Faster access
      cons:
        - No cross-device sync
      rejected_reason: Users need sync
  implementation_approach:
    summary: Recent tags with 5-min TTL, sanitization, sync storage
    details:
      - 5-minute TTL caching
      - Tag suggestions algorithm
      - Strict sanitization before persistence/rendering
  traceability:
    requirements:
      - REQ-RECENT_TAGS_SYSTEM
      - REQ-TAG_MANAGEMENT
      - REQ-TAG_INPUT_SANITIZATION
    implementation:
      - IMPL-TAG_SYSTEM
    tests: []
    code_annotations:
      - ARCH-TAG_SYSTEM
  related_decisions:
    depends_on: []
    informs:
      - IMPL-TAG_SYSTEM
    see_also: []
  detail_file: architecture-decisions/ARCH-TAG_SYSTEM.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-OVERLAY:
  name: Overlay System Architecture
  status: Active
  cross_references:
    - REQ-OVERLAY_SYSTEM
    - REQ-OVERLAY_AUTO_SHOW_CONTROL
    - REQ-OVERLAY_REFRESH_ACTION
    - REQ-OVERLAY_CONTROL_LAYOUT
  rationale:
    why: Non-intrusive bookmarking interface
    problems_solved:
      - Intrusive bookmark dialogs
      - Context switching
    benefits:
      - Seamless experience
      - No page disruption
  alternatives_considered:
    - name: Modal dialogs
      pros:
        - Simpler
      cons:
        - Intrusive
      rejected_reason: Breaks flow
  implementation_approach:
    summary: Semi-transparent overlay with hover activation, auto-show controls, refresh action
    details:
      - Transparency controls
      - Hover-based activation
      - Configurable auto-show on page load
      - Refresh control for current data
      - Fixed control layout (8px, 40px spacing)
  traceability:
    requirements:
      - REQ-OVERLAY_SYSTEM
      - REQ-OVERLAY_AUTO_SHOW_CONTROL
      - REQ-OVERLAY_REFRESH_ACTION
      - REQ-OVERLAY_CONTROL_LAYOUT
    implementation:
      - IMPL-OVERLAY
    tests: []
    code_annotations:
      - ARCH-OVERLAY
  related_decisions:
    depends_on: []
    informs:
      - IMPL-OVERLAY
    see_also: []
  detail_file: architecture-decisions/ARCH-OVERLAY.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-UX_CORE:
  name: User Experience Architecture
  status: Active
  cross_references:
    - REQ-CORE_UX_PRESERVATION
    - REQ-POPUP_PERSISTENT_SESSION
  rationale:
    why: Preserve essential user workflows
    problems_solved:
      - Popup closes after actions
      - Tedious workflows
    benefits:
      - Multi-action workflows
      - Persistent popup
  alternatives_considered: []
  implementation_approach:
    summary: Popup session persistence, multi-action support
    details:
      - Popup stays open during actions
      - State updates without closing
      - Overlay visibility reflected
  traceability:
    requirements:
      - REQ-CORE_UX_PRESERVATION
      - REQ-POPUP_PERSISTENT_SESSION
    implementation:
      - IMPL-UX_CORE
    tests: []
    code_annotations:
      - ARCH-UX_CORE
  related_decisions:
    depends_on: []
    informs:
      - IMPL-UX_CORE
    see_also: []
  detail_file: architecture-decisions/ARCH-UX_CORE.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-SUGGESTED_TAGS:
  name: Suggested Tags from Page Content Architecture
  status: Active
  cross_references:
    - REQ-SUGGESTED_TAGS_FROM_CONTENT
    - REQ-SUGGESTED_TAGS_DEDUPLICATION
    - REQ-SUGGESTED_TAGS_CASE_PRESERVATION
  rationale:
    why: Intelligent suggestions speed up bookmarking
    problems_solved:
      - Manual tag entry
      - No context awareness
    benefits:
      - Faster tagging
      - Context-aware suggestions
  alternatives_considered: []
  implementation_approach:
    summary: Extract from multiple page sources including meta tags, emphasis elements, and structured content; frequency sort; case preservation
    details:
      - Extract from title, URL, meta tags, headings, emphasis elements (strong/em/mark/dfn/cite/kbd/code), definition terms, table headers, nav, breadcrumbs, images, links
      - Prioritize title attribute over textContent
      - Frequency counting and sorting
      - Case-insensitive deduplication
      - Both original and lowercase versions for capitalized words
  traceability:
    requirements:
      - REQ-SUGGESTED_TAGS_FROM_CONTENT
      - REQ-SUGGESTED_TAGS_DEDUPLICATION
      - REQ-SUGGESTED_TAGS_CASE_PRESERVATION
    implementation:
      - IMPL-SUGGESTED_TAGS
    tests: []
    code_annotations:
      - ARCH-SUGGESTED_TAGS
  related_decisions:
    depends_on: []
    informs:
      - IMPL-SUGGESTED_TAGS
    see_also:
      - ARCH-TAG_SYSTEM
  detail_file: architecture-decisions/ARCH-SUGGESTED_TAGS.yaml
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Enhanced with meta tags, emphasis elements, and structured content extraction
ARCH-MV3_MIGRATION:
  name: Manifest V3 Migration Strategy
  status: Active
  cross_references:
    - REQ-MANIFEST_V3_MIGRATION
  rationale:
    why: V3 required for Chrome Web Store, better security/performance
    problems_solved:
      - V2 deprecation
      - Future compatibility
    benefits:
      - Continued store support
      - Modern architecture
  alternatives_considered:
    - name: Stay on V2
      pros: []
      cons:
        - Will be unsupported
      rejected_reason: V2 deprecated
    - name: Complete rewrite
      pros:
        - Clean slate
      cons:
        - Too risky
      rejected_reason: Prefer incremental migration
  implementation_approach:
    summary: Replace background scripts with service worker, maintain functionality
    details:
      - Service worker for background tasks
      - V3 permissions model
      - Preserved content script injection
  traceability:
    requirements:
      - REQ-MANIFEST_V3_MIGRATION
    implementation:
      - IMPL-MV3_MIGRATION
    tests: []
    code_annotations:
      - ARCH-MV3_MIGRATION
  related_decisions:
    depends_on: []
    informs:
      - IMPL-MV3_MIGRATION
    see_also:
      - ARCH-SERVICE_WORKER
  detail_file: architecture-decisions/ARCH-MV3_MIGRATION.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-BADGE:
  name: Badge System Architecture
  status: Active
  cross_references:
    - REQ-BADGE_INDICATORS
  rationale:
    why: Visual feedback improves UX
    problems_solved:
      - Unclear bookmark status
      - No at-a-glance info
    benefits:
      - Quick status visibility
      - Tab-specific state
  alternatives_considered:
    - name: No badges
      pros: []
      cons:
        - Loses visual feedback
      rejected_reason: Important for UX
    - name: Static badges
      pros:
        - Simpler
      cons:
        - Not informative
      rejected_reason: Need dynamic state
  implementation_approach:
    summary: Dynamic badge text with color coding, tab-specific management
    details:
      - Bookmark status indicators
      - Color-coded states
      - Tab-specific badges
  traceability:
    requirements:
      - REQ-BADGE_INDICATORS
    implementation:
      - IMPL-BADGE
    tests: []
    code_annotations:
      - ARCH-BADGE
  related_decisions:
    depends_on: []
    informs:
      - IMPL-BADGE
    see_also: []
  detail_file: architecture-decisions/ARCH-BADGE.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-URL_TAGS_DISPLAY:
  name: URL Tags and Badge Single Source
  status: Active
  cross_references:
    - REQ-URL_TAGS_DISPLAY
    - REQ-BADGE_INDICATORS
    - REQ-PER_BOOKMARK_STORAGE_BACKEND
  rationale:
    why: Single logical module for 'tags for URL' and 'badge display value' so badge, popup, and overlay never diverge
    problems_solved:
      - Popup showing no tags while badge showed correct count
      - Adding a tag overwriting prior tags when popup state was stale
      - Inconsistent tags shape (string vs array) across four storage providers
      - Popup empty when no Pinboard auth although bookmark in local/file/sync
    benefits:
      - Normalization at the boundary; all consumers get tags as array and same badge value
      - Message handler and service worker use same normalization; popup re-fetches and merges on add/remove
      - getCurrentBookmark always queries router (no early return for no auth); popup and badge share same data source
      - getTagsForUrl message exposes centralized tag storage for tests and UI
  implementation_approach:
    summary: 'URL-tags-manager module on top of BookmarkRouter: normalizeBookmarkForDisplay, getBookmarkForDisplay, getTagsForUrl, getBadgeDisplayValue; MessageHandler always uses router for getCurrentBookmark; getTagsForUrl message for central access.'
    details:
      - Router and four providers own storage; URL-tags module owns display normalization and badge value derivation
      - handleGetCurrentBookmark always calls router (no short-circuit when no Pinboard auth); returns normalized bookmark; set needsAuth on result when !hasAuth
      - Popup getBookmarkData only treats as no bookmark when blocked; when needsAuth still uses returned bookmark and tags
      - GET_TAGS_FOR_URL message and handleGetTagsForUrl return tags from getTagsForUrl(bookmarkProvider, url)
      - updateBadgeForTab normalizes before BadgeManager; popup re-fetches current tags before add/remove tag and merges
  traceability:
    requirements:
      - REQ-URL_TAGS_DISPLAY
      - REQ-BADGE_INDICATORS
    implementation:
      - IMPL-URL_TAGS_DISPLAY
    tests:
      - tests/unit/url-tags-manager.test.js
    code_annotations:
      - ARCH-URL_TAGS_DISPLAY
      - IMPL-URL_TAGS_DISPLAY
  related_decisions:
    depends_on: []
    informs:
      - IMPL-URL_TAGS_DISPLAY
    see_also:
      - ARCH-STORAGE_INDEX_AND_ROUTER
      - ARCH-BADGE
  detail_file: architecture-decisions/ARCH-URL_TAGS_DISPLAY.yaml
  metadata:
    created:
      date: '2026-02-17'
      author: AI Agent
    last_updated:
      date: '2026-02-17'
      author: AI Agent
      reason: 'Fixes: getCurrentBookmark always from router; getTagsForUrl message; popup use bookmark when needsAuth'
ARCH-CROSS_BROWSER:
  name: Cross-Browser Compatibility Architecture
  status: Active
  cross_references:
    - REQ-EXTENSION_IDENTITY
    - REQ-SAFARI_ADAPTATION
  rationale:
    why: Expand user base, provide Safari support
    problems_solved:
      - Platform-specific code duplication
      - Safari quirks
    benefits:
      - Broader reach
      - Unified codebase
  alternatives_considered:
    - name: Platform-specific code
      pros: []
      cons:
        - Too much duplication
      rejected_reason: Maintenance burden
    - name: Chrome-only
      pros:
        - Simpler
      cons:
        - Limited audience
      rejected_reason: Users want Safari support
  implementation_approach:
    summary: Unified browser API shim with platform detection and Safari adaptations
    details:
      - Platform detection utilities
      - Promise-based message passing
      - Storage API abstraction
      - Safari-specific optimizations
  traceability:
    requirements:
      - REQ-EXTENSION_IDENTITY
      - REQ-SAFARI_ADAPTATION
    implementation:
      - IMPL-CROSS_BROWSER
    tests: []
    code_annotations:
      - ARCH-CROSS_BROWSER
  related_decisions:
    depends_on: []
    informs:
      - IMPL-CROSS_BROWSER
    see_also:
      - ARCH-SAFARI_ADAPTATION
  detail_file: architecture-decisions/ARCH-CROSS_BROWSER.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-SERVICE_WORKER:
  name: Service Worker Architecture
  status: Active
  cross_references:
    - REQ-MANIFEST_V3_MIGRATION
  rationale:
    why: V3 requirement, modern async patterns
    problems_solved:
      - Background script deprecation
      - V3 compliance
    benefits:
      - Modern architecture
      - Better performance
  alternatives_considered:
    - name: Background scripts
      pros: []
      cons:
        - V3 doesn't support
      rejected_reason: Not V3 compatible
  implementation_approach:
    summary: Service worker with lifecycle management, message routing, async patterns
    details:
      - Install/activate/update events
      - Message routing
      - Extension context integration
  traceability:
    requirements:
      - REQ-MANIFEST_V3_MIGRATION
    implementation:
      - IMPL-SERVICE_WORKER
    tests: []
    code_annotations:
      - ARCH-SERVICE_WORKER
  related_decisions:
    depends_on: []
    informs:
      - IMPL-SERVICE_WORKER
    see_also:
      - ARCH-MV3_MIGRATION
  detail_file: architecture-decisions/ARCH-SERVICE_WORKER.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-MESSAGE_HANDLING:
  name: Message Handling Architecture
  status: Active
  cross_references:
    - REQ-SMART_BOOKMARKING
    - REQ-BOOKMARK_STATE_SYNCHRONIZATION
  rationale:
    why: Centralized communication across extension contexts
    problems_solved:
      - Complex context communication
      - Inconsistent messaging
    benefits:
      - Simplified routing
      - Reliable communication
  alternatives_considered:
    - name: Direct function calls
      pros: []
      cons:
        - Doesn't work across contexts
      rejected_reason: Extension contexts are isolated
    - name: Event-based only
      pros:
        - Decoupled
      cons:
        - No request/response
      rejected_reason: Need synchronous responses
  implementation_approach:
    summary: Centralized routing with standardized message format, async handling, BOOKMARK_UPDATED broadcasts
    details:
      - Standardized message types
      - Request/response pattern
      - Error handling and retry
      - BOOKMARK_UPDATED synchronization
  traceability:
    requirements:
      - REQ-SMART_BOOKMARKING
      - REQ-BOOKMARK_STATE_SYNCHRONIZATION
    implementation:
      - IMPL-MESSAGE_HANDLING
    tests: []
    code_annotations:
      - ARCH-MESSAGE_HANDLING
  related_decisions:
    depends_on: []
    informs:
      - IMPL-MESSAGE_HANDLING
    see_also: []
  detail_file: architecture-decisions/ARCH-MESSAGE_HANDLING.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-THEME:
  name: Theme System Architecture
  status: Active
  cross_references:
    - REQ-DARK_THEME
  rationale:
    why: Dark theme is modern UI expectation
    problems_solved:
      - Eye strain
      - No theme choice
    benefits:
      - User comfort
      - Modern appearance
  alternatives_considered: []
  implementation_approach:
    summary: Dark theme default with toggle, persisted preference
    details:
      - Dark theme default
      - Theme toggle
      - Preference persistence
  traceability:
    requirements:
      - REQ-DARK_THEME
    implementation:
      - IMPL-THEME
    tests: []
    code_annotations:
      - ARCH-THEME
  related_decisions:
    depends_on: []
    informs:
      - IMPL-THEME
    see_also: []
  detail_file: architecture-decisions/ARCH-THEME.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-POPUP_SESSION:
  name: Popup Session Persistence Architecture
  status: Active
  cross_references:
    - REQ-POPUP_PERSISTENT_SESSION
  rationale:
    why: Multi-action workflows without popup reopening
    problems_solved:
      - Popup closes after each action
      - Workflow interruption
    benefits:
      - Chained operations
      - Better UX
  alternatives_considered:
    - name: Auto-close after actions
      pros: []
      cons:
        - Interrupts workflows
      rejected_reason: Contradicts test expectations
    - name: Direct DOM manipulation
      pros: []
      cons:
        - Duplicated logic
      rejected_reason: Inconsistent error handling
  implementation_approach:
    summary: Route actions through PopupController, update state without closing
    details:
      - PopupController handlers await async work
      - State manager updates
      - UIManager updates without close
      - Overlay toggle with GET_OVERLAY_STATE fallback
  traceability:
    requirements:
      - REQ-POPUP_PERSISTENT_SESSION
    implementation:
      - IMPL-POPUP_SESSION
    tests:
      - Popup close behavior tests
    code_annotations:
      - ARCH-POPUP_SESSION
  related_decisions:
    depends_on: []
    informs:
      - IMPL-POPUP_SESSION
    see_also:
      - ARCH-UX_CORE
      - ARCH-MESSAGE_HANDLING
  detail_file: architecture-decisions/ARCH-POPUP_SESSION.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-BOOKMARK_STATE_SYNC:
  name: Bookmark State Synchronization Architecture
  status: Active
  cross_references:
    - REQ-BOOKMARK_STATE_SYNCHRONIZATION
  rationale:
    why: Prevent desynchronized states across UI surfaces
    problems_solved:
      - Conflicting bookmark states
      - Race conditions
    benefits:
      - Consistent state
      - Observable contract
  alternatives_considered:
    - name: Polling Pinboard
      pros: []
      cons:
        - High latency
        - Rate limits
      rejected_reason: Too slow
    - name: Separate local stores
      pros: []
      cons:
        - Race conditions
      rejected_reason: Inconsistent UX
  implementation_approach:
    summary: BOOKMARK_UPDATED broadcast pattern with normalized payloads
    details:
      - Overlay persists via saveBookmark
      - Broadcast BOOKMARK_UPDATED
      - Popup listens and refreshes
      - Badge updates from payload
  traceability:
    requirements:
      - REQ-BOOKMARK_STATE_SYNCHRONIZATION
    implementation:
      - IMPL-BOOKMARK_STATE_SYNC
    tests:
      - Toggle synchronization tests
    code_annotations:
      - ARCH-BOOKMARK_STATE_SYNC
  related_decisions:
    depends_on: []
    informs:
      - IMPL-BOOKMARK_STATE_SYNC
    see_also:
      - ARCH-MESSAGE_HANDLING
      - ARCH-OVERLAY
      - ARCH-BADGE
  detail_file: architecture-decisions/ARCH-BOOKMARK_STATE_SYNC.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-OVERLAY_CONTROLS:
  name: Overlay Control Layout Architecture
  status: Active
  cross_references:
    - REQ-OVERLAY_CONTROL_LAYOUT
    - REQ-OVERLAY_REFRESH_ACTION
  rationale:
    why: Predictable, accessible control placement
    problems_solved:
      - Control overlaps
      - Accessibility issues
    benefits:
      - Consistent layout
      - Full accessibility
  alternatives_considered:
    - name: Dynamic positioning
      pros: []
      cons:
        - Risk of overlaps
      rejected_reason: Complex pages cause issues
    - name: CSS-only
      pros: []
      cons:
        - Host styles override
      rejected_reason: Need JS enforcement
  implementation_approach:
    summary: Fixed absolute positioning with inline styles, theme variables, accessibility metadata
    details:
      - 'Close at top: 8px; left: 8px'
      - 'Refresh at top: 8px; left: 40px'
      - 32px spacing, 24px min touch targets
      - Theme CSS variables
      - Full ARIA metadata
  traceability:
    requirements:
      - REQ-OVERLAY_CONTROL_LAYOUT
      - REQ-OVERLAY_REFRESH_ACTION
    implementation:
      - IMPL-OVERLAY_CONTROLS
    tests:
      - Overlay close button positioning tests
      - Overlay refresh button tests
    code_annotations:
      - ARCH-OVERLAY_CONTROLS
  related_decisions:
    depends_on: []
    informs:
      - IMPL-OVERLAY_CONTROLS
    see_also:
      - ARCH-OVERLAY
  detail_file: architecture-decisions/ARCH-OVERLAY_CONTROLS.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-OVERLAY_TESTABILITY:
  name: Overlay Test Harness Architecture
  status: Active
  cross_references:
    - REQ-OVERLAY_SYSTEM
    - REQ-OVERLAY_CONTROL_LAYOUT
  rationale:
    why: Deterministic overlay verification without real DOM
    problems_solved:
      - Stale test registries
      - False negatives
    benefits:
      - Lightweight tests
      - Deterministic discovery
  alternatives_considered:
    - name: setAttribute-only registration
      pros: []
      cons:
        - Misses direct assignments
      rejected_reason: Code uses className/id directly
    - name: jsdom
      pros:
        - Full DOM
      cons:
        - Heavy, non-deterministic
      rejected_reason: Tests need to be lightweight
  implementation_approach:
    summary: Mock DOM with automatic element registration on className/id changes
    details:
      - Auto-register on property assignments
      - classList/attribute hooks
      - Lightweight verification
  traceability:
    requirements:
      - REQ-OVERLAY_SYSTEM
      - REQ-OVERLAY_CONTROL_LAYOUT
    implementation:
      - IMPL-OVERLAY_TEST_HARNESS
    tests:
      - All overlay tests
    code_annotations:
      - ARCH-OVERLAY_TESTABILITY
  related_decisions:
    depends_on: []
    informs:
      - IMPL-OVERLAY_TEST_HARNESS
    see_also:
      - ARCH-OVERLAY
      - ARCH-OVERLAY_CONTROLS
  detail_file: architecture-decisions/ARCH-OVERLAY_TESTABILITY.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-UI_TESTABILITY:
  name: UI Testability and Inspection Architecture
  status: Active
  cross_references:
    - REQ-UI_INSPECTION
    - IMPL-UI_ACTION_CONTRACT
    - IMPL-UI_INSPECTOR
  rationale:
    why: Single source of truth for message types and action IDs; optional inspector for testing and debugging
    problems_solved:
      - Tests and E2E cannot reliably assert on message flow and UI actions
      - No shared contract between popup, content script, and service worker for inspection
    benefits:
      - Inspector records messages and actions when enabled (gated by flag)
      - Contract module used by tests and inspector
  implementation_approach:
    summary: ui-action-contract.js re-exports MESSAGE_TYPES and defines POPUP_ACTION_IDS/OVERLAY_ACTION_IDS; ui-inspector.js provides ring buffers and is wired in SW, popup, content
    details:
      - Service worker records each message after handleMessage; popup/content recordAction at start of handlers
      - Inspector enabled via localStorage DEBUG_HOVERBOARD_UI or setEnabled in SW (from chrome.storage.local)
  traceability:
    requirements:
      - REQ-UI_INSPECTION
    implementation:
      - IMPL-UI_ACTION_CONTRACT
      - IMPL-UI_INSPECTOR
  detail_file: architecture-decisions/ARCH-UI_TESTABILITY.yaml
  metadata:
    created: "2026-02-17"
    last_updated: "2026-02-17"
    author: AI Agent
ARCH-EXTENSION_BUNDLED_ENTRY_POINTS:
  name: Extension Bundled Entry Points
  status: Active
  cross_references:
    - REQ-EXTENSION_BUNDLED_ENTRY_POINTS
    - IMPL-POPUP_BUNDLE
  rationale:
    why: Browsers do not resolve bare module specifiers; all extension entry points must be self-contained bundles
    problems_solved:
      - Popup loading unbundled code (e.g. TagService â†’ PinboardService) with bare 'fast-xml-parser' import
    benefits:
      - build:sw, build:options, build:content, build:popup produce bundles; copy step skips entry files
  implementation_approach:
    summary: Build script runs four bundle steps; copyDir skips service-worker.js, options.js, content-main.js, popup.js
  traceability:
    requirements:
      - REQ-EXTENSION_BUNDLED_ENTRY_POINTS
    implementation:
      - IMPL-POPUP_BUNDLE
  detail_file: architecture-decisions/ARCH-EXTENSION_BUNDLED_ENTRY_POINTS.yaml
  metadata:
    created: "2026-02-17"
    last_updated: "2026-02-17"
    author: AI Agent
ARCH-SAFARI_ADAPTATION:
  name: Safari Adaptive Architecture
  status: Active
  cross_references:
    - REQ-SAFARI_ADAPTATION
  rationale:
    why: Safari requires explicit adaptations for stability
    problems_solved:
      - Safari memory limits
      - Messaging quirks
      - Performance issues
    benefits:
      - Stable Safari experience
      - Cross-browser identity
  alternatives_considered:
    - name: Treat Safari like Chrome
      pros: []
      cons:
        - Known instability
      rejected_reason: Safari needs adaptations
    - name: Separate Safari codebase
      pros:
        - Independent optimization
      cons:
        - Duplicated logic
      rejected_reason: High maintenance cost
  implementation_approach:
    summary: Safari-specific config, optimizations, error handler with degraded mode
    details:
      - Safari config (timeouts, retries, opacity)
      - Animation/memory optimizations
      - Categorized error handler
      - Bounded recovery, degraded mode
      - Performance monitoring
  traceability:
    requirements:
      - REQ-SAFARI_ADAPTATION
    implementation:
      - IMPL-SAFARI_ADAPTATION
    tests:
      - Safari unit test suites
    code_annotations:
      - ARCH-SAFARI_ADAPTATION
  related_decisions:
    depends_on: []
    informs:
      - IMPL-SAFARI_ADAPTATION
    see_also:
      - ARCH-CROSS_BROWSER
      - ARCH-OVERLAY
      - ARCH-MESSAGE_HANDLING
  detail_file: architecture-decisions/ARCH-SAFARI_ADAPTATION.md
  metadata:
    created:
      date: 2025-07-14T00:00:00.000Z
      author: AI Agent
    last_updated:
      date: 2026-02-13T00:00:00.000Z
      author: AI Agent
      reason: Migrated from STDD to TIED format
ARCH-ERROR_HANDLING:
  name: Error Handling Strategy
  status: Template
  cross_references:
    - REQ-ERROR_HANDLING
  rationale:
    why: Why this error handling approach was chosen
    problems_solved:
      - Problem 1 with error handling
    benefits:
      - Benefit 1 of this approach
  alternatives_considered:
    - name: Exceptions
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why rejected or why chosen
    - name: Error codes
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why rejected or why chosen
    - name: Result types
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why rejected or why chosen
  implementation_approach:
    summary: How errors will be handled throughout the application
    details:
      - Error propagation strategy
      - Error logging approach
      - User-facing error messages
  traceability:
    requirements:
      - REQ-ERROR_HANDLING
    implementation:
      - IMPL-ERROR_HANDLING
    tests:
      - testErrorHandling_ARCH_ERROR_HANDLING
    code_annotations:
      - ARCH-ERROR_HANDLING
  related_decisions:
    depends_on:
      - REQ-ERROR_HANDLING
    informs:
      - IMPL-ERROR_HANDLING
    see_also: []
  detail_file: architecture-decisions/ARCH-ERROR_HANDLING.md
  metadata:
    created:
      date: YYYY-MM-DD
      author: agent/contributor
    last_updated:
      date: YYYY-MM-DD
      author: agent/contributor
      reason: Initial creation
    last_validated:
      date: YYYY-MM-DD
      validator: agent/contributor
      result: pass
ARCH-TESTING_STRATEGY:
  name: Testing Strategy
  status: Template
  cross_references: []
  rationale:
    why: Why this testing strategy was chosen
    problems_solved:
      - Problem 1 with testing
    benefits:
      - Benefit 1 of this strategy
  alternatives_considered:
    - name: Test Approach 1
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why rejected or why chosen
    - name: Test Approach 2
      pros:
        - Pro 1
      cons:
        - Con 1
      rejected_reason: Why rejected or why chosen
  implementation_approach:
    summary: Overall testing strategy for the project
    details:
      - Unit testing approach
      - Integration testing approach
      - End-to-end testing approach
      - Test coverage goals
  traceability:
    requirements:
      - REQ-*
    implementation:
      - IMPL-TESTING
    tests:
      - All test files follow this strategy
    code_annotations:
      - ARCH-TESTING_STRATEGY
  related_decisions:
    depends_on: []
    informs:
      - IMPL-TESTING
    see_also: []
  detail_file: architecture-decisions/ARCH-TESTING_STRATEGY.md
  metadata:
    created:
      date: YYYY-MM-DD
      author: agent/contributor
    last_updated:
      date: YYYY-MM-DD
      author: agent/contributor
      reason: Initial creation
    last_validated:
      date: YYYY-MM-DD
      validator: agent/contributor
      result: pass
ARCH-LOCAL_STORAGE_PROVIDER:
  name: Local Storage Bookmark Provider (Strategy Pattern)
  status: Active
  cross_references:
    - REQ-STORAGE_MODE_DEFAULT
    - ARCH-STORAGE
    - ARCH-PINBOARD_API
  rationale:
    why: Allow extension to work without external API; user choice between Pinboard (cloud) and local-only bookmarks
    problems_solved:
      - Single point of dependency on Pinboard API
      - No offline-only option
    benefits:
      - Default is local (preferable for most users; no account or API required)
      - User can choose local-only storage (chrome.storage.local) or Pinboard (cloud)
      - Same UI and message contract; provider swapped by config
      - Runtime switch without extension reload (SWITCH_STORAGE_MODE)
  alternatives_considered:
    - name: Hybrid per-bookmark local/remote
      pros:
        - Per-bookmark control
      cons:
        - More complex UI and state
      rejected_reason: Plan specified full mode switch only
    - name: Fallback only when offline
      pros:
        - Automatic
      cons:
        - Two sources of truth; sync complexity
      rejected_reason: Plan specified explicit mode switch
  implementation_approach:
    summary: 'Strategy pattern: MessageHandler delegates to bookmarkProvider; provider chosen from config (storageMode: pinboard | local).'
    details:
      - Default storageMode is 'local' (REQ-STORAGE_MODE_DEFAULT)
      - 'ConfigManager: storageMode in settings, getStorageMode/setStorageMode'
      - LocalBookmarkService implements same contract as PinboardService, backed by chrome.storage.local
      - Service worker resolves provider from config (lazy init); handles SWITCH_STORAGE_MODE to swap at runtime
      - 'Options page: Storage Mode radios; auth section disabled when local'
  traceability:
    requirements:
      - REQ-STORAGE_MODE_DEFAULT
    implementation:
      - IMPL-LOCAL_BOOKMARK_SERVICE
    tests: []
    code_annotations:
      - ARCH-LOCAL_STORAGE_PROVIDER
  related_decisions:
    depends_on:
      - ARCH-STORAGE
      - ARCH-PINBOARD_API
    informs:
      - IMPL-LOCAL_BOOKMARK_SERVICE
    see_also:
      - ARCH-MESSAGE_HANDLING
  detail_file: architecture-decisions/ARCH-LOCAL_STORAGE_PROVIDER.yaml
  metadata:
    created:
      date: '2026-02-13'
      author: AI Agent
    last_updated:
      date: '2026-02-13'
      author: AI Agent
      reason: Local storage mode implementation per plan
    last_validated:
      date: '2026-02-13'
      validator: AI Agent
      result: pass
ARCH-SYNC_STORAGE_PROVIDER:
  name: Sync Storage Bookmark Provider (Fourth Backend)
  status: Active
  cross_references:
    - REQ-STORAGE_MODE_DEFAULT
    - REQ-PER_BOOKMARK_STORAGE_BACKEND
    - ARCH-STORAGE_INDEX_AND_ROUTER
  rationale:
    why: Offer bookmarks synced across Chrome profile devices without external API; same provider contract as local/file
    problems_solved:
      - No built-in sync option besides Pinboard
    benefits:
      - Sync across devices signed into same Chrome profile
      - Quota ~100 KB; documented so users can choose
  implementation_approach:
    summary: SyncBookmarkService mirrors LocalBookmarkService using chrome.storage.sync and key hoverboard_sync_bookmarks; VALID_BACKENDS and BookmarkRouter extended with sync.
  traceability:
    requirements:
      - REQ-STORAGE_MODE_DEFAULT
      - REQ-PER_BOOKMARK_STORAGE_BACKEND
    implementation:
      - IMPL-SYNC_BOOKMARK_SERVICE
  detail_file: null
  metadata:
    created:
      date: '2026-02-15'
    last_updated:
      date: '2026-02-15'
ARCH-LOCAL_BOOKMARKS_INDEX:
  name: Local Bookmarks Index Architecture
  status: Active
  cross_references:
    - REQ-LOCAL_BOOKMARKS_INDEX
    - ARCH-STORAGE_INDEX_AND_ROUTER
  rationale:
    why: Provide a dedicated page for browsing and searching local and file-stored bookmarks (non-Pinboard)
    problems_solved:
      - No single view of all non-Pinboard bookmarks (local + file)
      - Users cannot search/filter/sort local and file bookmarks in one place
    benefits:
      - Full index of local and file bookmarks with Storage column (Local | File), search, filter, sort, and launch
      - Primary data from getAggregatedBookmarksForIndex (BookmarkRouter); fallback getLocalBookmarksForIndex (LocalBookmarkService only)
      - Client-side search/filter/sort for responsiveness
  alternatives_considered:
    - name: Use current provider (Pinboard or local)
      pros:
        - Single code path
      cons:
        - Index would show Pinboard data when in Pinboard mode; plan requires non-Pinboard index
      rejected_reason: Requirement is local + file index only (no Pinboard)
    - name: Server-side or background search/filter
      pros: []
      cons:
        - More messages; client has full list for sort/filter anyway
      rejected_reason: Client-side is simpler and sufficient
  implementation_approach:
    summary: Dedicated extension HTML page; data from getAggregatedBookmarksForIndex (local + file with storage field), fallback getLocalBookmarksForIndex; table includes Storage column; client-side search/filter/sort; URL column as link
    details:
      - Single extension page (e.g. bookmarks-table.html) with table, search input, filter controls, Storage column (Local | File)
      - Message getAggregatedBookmarksForIndex calls bookmarkProvider.getAllBookmarksForIndex() (BookmarkRouter aggregates local + file); fallback getLocalBookmarksForIndex uses LocalBookmarkService only
      - Page receives full bookmark array with storage field; implements search (title/URL/tags/extended), filters (tag, toread, shared), sortable columns including Storage (default time desc)
      - URL column renders as <a target=_blank> for launch
      - Empty state when no local or file bookmarks
  traceability:
    requirements:
      - REQ-LOCAL_BOOKMARKS_INDEX
    implementation:
      - IMPL-LOCAL_BOOKMARKS_INDEX
    tests: []
    code_annotations:
      - ARCH-LOCAL_BOOKMARKS_INDEX
  related_decisions:
    depends_on:
      - REQ-LOCAL_BOOKMARKS_INDEX
    informs:
      - IMPL-LOCAL_BOOKMARKS_INDEX
    see_also:
      - ARCH-LOCAL_STORAGE_PROVIDER
      - ARCH-MESSAGE_HANDLING
  detail_file: architecture-decisions/ARCH-LOCAL_BOOKMARKS_INDEX.yaml
  metadata:
    created:
      date: '2026-02-13'
      author: AI Agent
    last_updated:
      date: '2026-02-14'
      author: AI Agent
      reason: Index shows local + file with Storage column; getAggregatedBookmarksForIndex
ARCH-LOCAL_BOOKMARKS_INDEX_EXPORT:
  name: Local Bookmarks Index Export Architecture
  status: Active
  cross_references:
    - REQ-LOCAL_BOOKMARKS_INDEX_EXPORT
  rationale:
    why: Allow backup and portability of index data without adding backend complexity
    problems_solved:
      - Users cannot export index data
    benefits:
      - Client-side only; uses existing allBookmarks and filteredBookmarks
      - No new message or backend; download via Blob and anchor
  alternatives_considered:
    - name: Backend export message
      pros:
        - Could stream large datasets
      cons:
        - Data already on page; unnecessary round-trip
      rejected_reason: Client has full data; client-side is sufficient
  implementation_approach:
    summary: Export implemented entirely on index page; data from allBookmarks (all) or filteredBookmarks (displayed); serialize to CSV including Storage column; trigger download via Blob + temporary anchor with download attribute
    details:
      - No new background message; use in-memory arrays already on page (local + file bookmarks with storage field)
      - 'CSV: columns Title, URL, Tags, Time, Storage (Local | File), Shared, To read, Notes; quoted fields, escaped quotes'
      - 'Optional JSON: full bookmark objects'
      - Filename e.g. hoverboard-bookmarks-{all|displayed}-{ISO date}.csv
  traceability:
    requirements:
      - REQ-LOCAL_BOOKMARKS_INDEX_EXPORT
    implementation:
      - IMPL-LOCAL_BOOKMARKS_INDEX_EXPORT
    tests: []
    code_annotations:
      - ARCH-LOCAL_BOOKMARKS_INDEX_EXPORT
  related_decisions:
    depends_on: []
    informs:
      - IMPL-LOCAL_BOOKMARKS_INDEX_EXPORT
    see_also:
      - ARCH-LOCAL_BOOKMARKS_INDEX
  detail_file: architecture-decisions/ARCH-LOCAL_BOOKMARKS_INDEX_EXPORT.yaml
  metadata:
    created:
      date: '2026-02-13'
      author: AI Agent
    last_updated:
      date: '2026-02-14'
      author: AI Agent
      reason: Implementation complete
ARCH-FILE_BOOKMARK_PROVIDER:
  name: File-Based Bookmark Provider
  status: Active
  cross_references:
    - REQ-FILE_BOOKMARK_STORAGE
    - ARCH-LOCAL_STORAGE_PROVIDER
  rationale:
    why: 'Add third storage backend: file-based, single directory, one file, cloud-sync friendly'
    problems_solved:
      - No way to store bookmarks in a cloud-synced folder
      - Cannot share bookmark file with ad-hoc groups
    benefits:
      - Same provider contract as PinboardService/LocalBookmarkService
      - File I/O in offscreen or options context (MV3 service worker cannot use File System Access)
      - Directory handle stored in IndexedDB; single JSON file in chosen directory
  alternatives_considered:
    - name: Multiple files per bookmark
      pros:
        - Merge-friendly for sync
      cons:
        - More complex; single file is sufficient for many users
      rejected_reason: Plan specifies single file in single directory
  implementation_approach:
    summary: FileBookmarkService implements provider contract; file I/O behind adapter (readBookmarksFile, writeBookmarksFile); real adapter uses File System Access in document context.
    details:
      - 'File format: { version: 1, bookmarks: { url: bookmark } }'
      - Adapter abstraction allows unit tests with in-memory mock
      - 'Real adapter: directory handle + getFileHandle + createWritable/read; used from offscreen or options'
  traceability:
    requirements:
      - REQ-FILE_BOOKMARK_STORAGE
    implementation:
      - IMPL-FILE_BOOKMARK_SERVICE
    tests:
      - file-bookmark-service.test.js
    code_annotations:
      - ARCH-FILE_BOOKMARK_PROVIDER
  related_decisions:
    depends_on:
      - ARCH-LOCAL_STORAGE_PROVIDER
    informs:
      - IMPL-FILE_BOOKMARK_SERVICE
    see_also:
      - ARCH-STORAGE
  detail_file: architecture-decisions/ARCH-FILE_BOOKMARK_PROVIDER.yaml
  metadata:
    created:
      date: '2026-02-14'
      author: AI Agent
    last_updated:
      date: '2026-02-14'
      author: AI Agent
      reason: File-based storage per plan
ARCH-STORAGE_INDEX_AND_ROUTER:
  name: Storage Index and Bookmark Router
  status: Active
  cross_references:
    - REQ-PER_BOOKMARK_STORAGE_BACKEND
    - REQ-STORAGE_MODE_DEFAULT
    - REQ-MOVE_BOOKMARK_STORAGE_UI
    - ARCH-LOCAL_STORAGE_PROVIDER
    - ARCH-FILE_BOOKMARK_PROVIDER
  rationale:
    why: Per-URL storage backend and router so bookmarks can live in pinboard, local, or file; default for new bookmarks from config; popup can send preferred backend so save follows highlight
    problems_solved:
      - Single global provider prevents mixing backends
      - Need to route operations by URL to correct backend
      - Save not following popup-highlighted storage on create/update
    benefits:
      - Storage index (chrome.storage.local) maps URL -> pinboard|local|file|sync
      - BookmarkRouter delegates get/save/delete to correct provider; when popup sends preferredBackend, router uses it so save follows the highlight (REQ-STORAGE_MODE_DEFAULT, REQ-MOVE_BOOKMARK_STORAGE_UI)
      - getRecentBookmarks aggregates all four
      - Default storage mode for new bookmarks (config); migration seeds index from existing local bookmarks
      - URL-tags/badge module on top of router provides display normalization and single source for tag list and badge value
  implementation_approach:
    summary: StorageIndex module; BookmarkRouter holds four providers (pinboard, local, file, sync) and index; MessageHandler uses router as bookmarkProvider (duck-typed). Popup sends preferredBackend on save so save follows highlight. URL-tags-manager normalizes for display.
    details:
      - 'Index key: hoverboard_storage_index; getIndex, setBackendForUrl, getBackendForUrl, removeUrl'
      - 'Router: saveBookmark uses valid data.preferredBackend when provided, else getBackendForUrl(url) or defaultStorageMode'
      - 'getRecentBookmarks: fetch from all four, merge, sort by time, slice'
      - ConfigManager getStorageMode/setStorageMode allow pinboard|local|file|sync; invalid/missing fallback to 'local'
  traceability:
    requirements:
      - REQ-PER_BOOKMARK_STORAGE_BACKEND
    implementation:
      - IMPL-STORAGE_INDEX
      - IMPL-BOOKMARK_ROUTER
    tests:
      - storage-index.test.js
      - bookmark-router.test.js
    code_annotations:
      - ARCH-STORAGE_INDEX_AND_ROUTER
  related_decisions:
    depends_on:
      - ARCH-LOCAL_STORAGE_PROVIDER
      - ARCH-FILE_BOOKMARK_PROVIDER
    informs:
      - IMPL-STORAGE_INDEX
      - IMPL-BOOKMARK_ROUTER
    see_also:
      - ARCH-MOVE_BOOKMARK_UI
  detail_file: architecture-decisions/ARCH-STORAGE_INDEX_AND_ROUTER.yaml
  metadata:
    created:
      date: '2026-02-14'
      author: AI Agent
    last_updated:
      date: '2026-02-14'
      author: AI Agent
      reason: Per-bookmark storage and router per plan
ARCH-MOVE_BOOKMARK_UI:
  name: Move Bookmark Storage UI
  status: Active
  cross_references:
    - REQ-MOVE_BOOKMARK_STORAGE_UI
    - ARCH-STORAGE_INDEX_AND_ROUTER
  rationale:
    why: Let user move current bookmark to another storage backend from popup
    problems_solved:
      - No way to change storage after saving
    benefits:
      - Popup shows current storage and dropdown/buttons to move to Pinboard, Local, or File
      - Move = copy to target + delete from source + update index (router)
  implementation_approach:
    summary: 'Popup: getStorageBackendForUrl on load; select or buttons for storage; on change call moveBookmarkToStorage.'
    details:
      - MessageHandler already has getStorageBackendForUrl and moveBookmarkToStorage handlers
      - 'When not bookmarked: show default storage or disable'
  traceability:
    requirements:
      - REQ-MOVE_BOOKMARK_STORAGE_UI
    implementation:
      - IMPL-MOVE_BOOKMARK_UI
    code_annotations:
      - ARCH-MOVE_BOOKMARK_UI
  related_decisions:
    depends_on:
      - ARCH-STORAGE_INDEX_AND_ROUTER
    informs:
      - IMPL-MOVE_BOOKMARK_UI
    see_also: []
  detail_file: architecture-decisions/ARCH-MOVE_BOOKMARK_UI.yaml
  metadata:
    created:
      date: '2026-02-14'
      author: AI Agent
    last_updated:
      date: '2026-02-14'
      author: AI Agent
      reason: Move bookmark UI per plan
ARCH-NATIVE_HOST:
  name: Native Host Architecture
  status: Active
  cross_references:
    - REQ-NATIVE_HOST_WRAPPER
  rationale:
    why: Chrome does not pass extension path to native host; host must load only from its own install directory
    problems_solved:
      - Cannot run code from extension folder at runtime
    benefits:
      - Thin wrapper + helper installed to fixed path by installer; wrapper delegates to helper in same dir
  implementation_approach:
    summary: Go wrapper (stdio protocol, install-dir resolution), helper script/binary in same dir, installer scripts per OS
    details:
      - 'Wrapper: 4-byte length + JSON; pingâ†’pong; else invoke helper in same dir'
      - 'Installer: copy to ~/.hoverboard or %LOCALAPPDATA%\Hoverboard; write manifest and (Windows) registry'
  traceability:
    requirements:
      - REQ-NATIVE_HOST_WRAPPER
    implementation:
      - IMPL-NATIVE_HOST_WRAPPER
      - IMPL-NATIVE_HOST_INSTALLER
    code_annotations:
      - ARCH-NATIVE_HOST
  related_decisions:
    depends_on: []
    informs:
      - IMPL-NATIVE_HOST_WRAPPER
      - IMPL-NATIVE_HOST_INSTALLER
    see_also: []
  detail_file: architecture-decisions/ARCH-NATIVE_HOST.yaml
  metadata:
    created:
      date: '2026-02-14'
      author: AI Agent
    last_updated:
      date: '2026-02-14'
      author: AI Agent
      reason: Native host wrapper and installer per plan
ARCH-CODE_QUALITY:
  name: Code Quality Tooling (ESLint and Security Audit)
  status: Active
  cross_references:
    - REQ-CODE_QUALITY
  rationale:
    why: Use ESLint 9 flat config with Standard preset for linting; run security audit at high severity so builds do not fail on unfixable moderate transitive deps
    problems_solved:
      - Legacy eslintrc and .eslintignore no longer supported in ESLint 9
      - Moderate vulnerabilities in ESLint compat stack (e.g. ajv) block build if audit-level=moderate
    benefits:
      - Single flat config file (eslint.config.mjs); ignores in config
      - Build passes while high/critical audit findings still fail validate
  alternatives_considered:
    - name: Keep ESLint 8 and eslintrc
      pros:
        - No migration
      cons:
        - ESLint 8 deprecated; flat config is default in v9
      rejected_reason: ESLint 9 and flat config are the supported path
    - name: npm audit fix --force to clear moderate
      pros:
        - Zero audit findings
      cons:
        - Downgrades ESLint to 4.x and breaks flat config
      rejected_reason: Unacceptable; would undo migration
  implementation_approach:
    summary: ESLint 9 with eslint.config.mjs (Standard via FlatCompat); Node engines >= 18.18.0; security:check with --audit-level=high
    details:
      - 'eslint.config.mjs: globalIgnores, fixupConfigRules(compat.extends(''standard'')), languageOptions and rule overrides for src/**/*.js'
      - package.json engines.node >= 18.18.0
      - package.json security:check script uses npm audit --audit-level=high
  traceability:
    requirements:
      - REQ-CODE_QUALITY
    implementation:
      - IMPL-CODE_STYLE
    tests:
      - npm run lint; npm run validate
    code_annotations:
      - IMPL-CODE_STYLE
  related_decisions:
    depends_on:
      - REQ-CODE_QUALITY
    informs:
      - IMPL-CODE_STYLE
    see_also: []
  detail_file: architecture-decisions/ARCH-CODE_QUALITY.yaml
  metadata:
    created:
      date: '2025-02-17'
      author: agent
    last_updated:
      date: '2025-02-17'
      author: agent
      reason: ESLint 9 flat config migration and security check level
    last_validated:
      date: '2025-02-17'
      validator: agent
      result: pass
ARCH-SHARED_UTILITIES:
  name: Shared Utilities Module
  status: Active
  cross_references:
    - REQ-SHARED_UTILITIES
  rationale:
    why: Single shared module for URL, text, array/object, time, DOM utilities
    problems_solved: []
    benefits:
      - Consistent behavior and single place to test
  implementation_approach:
    summary: src/shared/utils.js exports urlUtils, stringUtils, arrayUtils, objectUtils, timeUtils, domUtils
    details: []
  traceability:
    requirements:
      - REQ-SHARED_UTILITIES
    implementation:
      - IMPL-URL_UTILITIES
      - IMPL-TEXT_UTILITIES
      - IMPL-ARRAY_OBJECT_UTILITIES
      - IMPL-TIME_ASYNC_UTILITIES
      - IMPL-DOM_UTILITIES
    code_annotations:
      - ARCH-SHARED_UTILITIES
  related_decisions:
    depends_on:
      - REQ-SHARED_UTILITIES
    informs:
      - IMPL-URL_UTILITIES
      - IMPL-TEXT_UTILITIES
      - IMPL-ARRAY_OBJECT_UTILITIES
      - IMPL-TIME_ASYNC_UTILITIES
      - IMPL-DOM_UTILITIES
    see_also: []
  detail_file: architecture-decisions/ARCH-SHARED_UTILITIES.yaml
  metadata:
    created:
      date: "2026-02-17"
      author: AI Agent
    last_updated:
      date: "2026-02-17"
      author: AI Agent
      reason: Numbered token reinterpretation
ARCH-STRUCTURED_LOGGING:
  name: Structured Logging
  status: Active
  cross_references:
    - REQ-STRUCTURED_LOGGING
  rationale:
    why: Context-based logging with level filtering; environment-aware; legacy compatibility
    problems_solved: []
    benefits:
      - Clear log attribution and level control
  implementation_approach:
    summary: src/shared/logger.js Logger class, createLogger, legacy log() and noisy
    details: []
  traceability:
    requirements:
      - REQ-STRUCTURED_LOGGING
    implementation:
      - IMPL-LOGGER_CONTEXT_LEVELS
      - IMPL-LOG_LEVEL_CONFIG
      - IMPL-LOGGER_LEGACY
    code_annotations:
      - ARCH-STRUCTURED_LOGGING
  related_decisions:
    depends_on:
      - REQ-STRUCTURED_LOGGING
    informs:
      - IMPL-LOGGER_CONTEXT_LEVELS
      - IMPL-LOG_LEVEL_CONFIG
      - IMPL-LOGGER_LEGACY
    see_also: []
  detail_file: architecture-decisions/ARCH-STRUCTURED_LOGGING.yaml
  metadata:
    created:
      date: "2026-02-17"
      author: AI Agent
    last_updated:
      date: "2026-02-17"
      author: AI Agent
      reason: Numbered token reinterpretation
