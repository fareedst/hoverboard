IMPL-MODULE_VALIDATION:
  name: Module Validation Implementation
  status: Active
  cross_references:
    - ARCH-MODULE_VALIDATION
    - REQ-MODULE_VALIDATION
  rationale:
    why: |-
      Implements [REQ-MODULE_VALIDATION] requirement for independent module validation
      Realizes [ARCH-MODULE_VALIDATION] architecture decision
      Ensures modules are validated independently before integration to eliminate complexity-related bugs
      Catches bugs early in the development cycle, before integration issues compound
      Makes debugging easier by isolating issues to specific modules
    problems_solved: []
    benefits: []
  implementation_approach:
    summary: Independent module validation before integration to eliminate complexity-related bugs.
    details: []
  code_locations:
    files: []
    functions: []
  traceability:
    architecture:
      - ARCH-MODULE_VALIDATION
    requirements:
      - REQ-MODULE_VALIDATION
    tests: []
    code_annotations:
      - IMPL-MODULE_VALIDATION
      - ARCH-MODULE_VALIDATION
      - REQ-MODULE_VALIDATION
  related_decisions:
    depends_on: []
    supersedes: []
    see_also:
      - ARCH-MODULE_VALIDATION
      - REQ-MODULE_VALIDATION
  detail_file: implementation-decisions/IMPL-MODULE_VALIDATION.yaml
  metadata:
    created:
      date: '2026-02-18'
      author: MCP converter
    last_updated:
      date: '2026-02-18'
      author: MCP converter
      reason: Converted from monolithic
    last_validated:
      date: '2026-02-18'
      validator: MCP converter
      result: pass
  created: '2025-12-18'
  cross-references: '[ARCH-MODULE_VALIDATION] [REQ-MODULE_VALIDATION]'
  decision: Independent module validation before integration to eliminate complexity-related bugs.
  files:
    - '`*_module_test.[ext]` - Module validation test files'
    - '`*_validation_test.[ext]` - Module validation test files (alternate pattern)'
    - '`*_integration_test.[ext]` - Integration test files'
  functions: |-
    - `testModuleName_IndependentValidation_REQ_MODULE_VALIDATION()` - Module validation test function pattern

    _Note: In `implementation-decisions.yaml`, code locations are stored as structured YAML with files and functions lists for programmatic querying._
  integration_phase: |-
    6. **Integrate Validated Modules** (ONLY after validation passes):

    ```[your-language]
    // Example: Integration after module validation
    // [REQ-MODULE_VALIDATION] Only integrate after module validation passes
    // [IMPL-MODULE_VALIDATION] [ARCH-MODULE_VALIDATION] [REQ-MODULE_VALIDATION]
    function integrateModules(validatedModule1, validatedModule2) {
        // Integration code that combines validated modules
    }
    ```

    7. **Integration Testing**:
       - Test combined behavior of validated modules
       - Verify integration points work correctly
       - Test end-to-end scenarios with validated modules
  last_updated: '2025-12-18'
  module_development_phase: |-
    2. **Develop Module Independently**:
       - Implement module according to defined interface
       - Use dependency injection or interfaces for dependencies
       - Keep module isolated from other modules during development
  module_identification_phase: |-
    1. **Before Development**: Identify logical modules and document:
       - Module boundaries and responsibilities
       - Module interfaces and contracts
       - Module dependencies
       - Module validation criteria
  module_validation_phase: |-
    3. **Validate Module Independently** (BEFORE integration):

    ```[your-language]
    // Example: Module validation test structure
    function testModuleName_IndependentValidation() {
        // Setup: Create module with mocked dependencies
        mockDependency = createMockDependency()
        module = createModule(mockDependency)
        
        // Test: Unit tests with mocked dependencies
        test("contract validation", function() {
            result = module.process(input)
            assert result equals expectedOutput
        })
        
        // Test: Edge cases
        test("edge cases", function() {
            // Test boundary conditions
        })
        
        // Test: Error handling
        test("error handling", function() {
            // Test error scenarios
        })
    }
    ```

    4. **Validation Requirements**:
       - **Unit Tests**: Comprehensive unit tests with all dependencies mocked
       - **Contract Tests**: Validate input/output contracts
       - **Edge Case Tests**: Test boundary conditions and edge cases
       - **Error Handling Tests**: Test error scenarios and error propagation
       - **Integration Tests with Test Doubles**: Test module with mocks/stubs/fakes for dependencies

    5. **Document Validation Results**:
       - Document which validation tests passed
       - Document any known limitations or assumptions
       - Mark module as "validated" only after all validation criteria pass
  separate_tasks: Module development, module validation, and integration must be separate tasks
  task_dependencies: Integration tasks depend on module validation tasks
  task_priorities: Module validation is typically P0 or P1 priority
  token_coverage_`[proc-token_audit]`: |-
    Files/functions that must carry the `[IMPL-*] [ARCH-*] [REQ-*]` annotations:
    - [ ] Module implementation files with `[IMPL-MODULE_VALIDATION]` comments
    - [ ] Integration code with `[IMPL-MODULE_VALIDATION] [ARCH-MODULE_VALIDATION] [REQ-MODULE_VALIDATION]`

    Tests that must reference the matching `[REQ-*]`:
    - [ ] `testModuleName_IndependentValidation_REQ_MODULE_VALIDATION` - Module validation tests
    - [ ] `testIntegration_REQ_MODULE_VALIDATION` - Integration tests
  validation_evidence_`[proc-token_validation]`: |-
    | Date | Commit | Validation Result | Notes |
    |------|--------|-------------------|-------|
    | YYYY-MM-DD | `abc1234` | âœ… Pass | Initial validation |

    Latest `./scripts/validate_tokens.sh` output summary:
    ```
    (paste relevant output here when validation is run)
    ```
