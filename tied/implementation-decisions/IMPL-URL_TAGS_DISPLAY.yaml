IMPL-URL_TAGS_DISPLAY:
  name: URL Tags and Badge Display Module
  status: Active
  cross_references:
    - ARCH-URL_TAGS_DISPLAY
    - REQ-URL_TAGS_DISPLAY
    - REQ-BADGE_INDICATORS
    - REQ-PER_BOOKMARK_STORAGE_BACKEND
  rationale:
    why: Single source for tags-for-URL and badge display value; normalization at boundary so badge, popup, overlay use same contract.
    problems_solved:
      - Popup showing no tags when badge correct; adding tag losing prior tags
      - Tags string vs array inconsistency across providers
      - Popup empty when no Pinboard auth although bookmark in local/file/sync
    benefits:
      - normalizeBookmarkForDisplay, getBookmarkForDisplay, getTagsForUrl, getBadgeDisplayValue in one module
      - Message handler and service worker use it; popup re-fetches and merges when adding/removing tag
      - getTagsForUrl message centralizes tag storage for tests and UI
  implementation_approach:
    summary: url-tags-manager.js; handleGetCurrentBookmark always uses router (no early return for no auth), normalizes, sets needsAuth when !hasAuth; GET_TAGS_FOR_URL message and handleGetTagsForUrl; popup getBookmarkData only null when blocked.
    details:
      - 'normalizeBookmarkForDisplay(bookmark): tags always array, required fields defaulted'
      - 'getBookmarkForDisplay(provider, url, title): async, returns normalized bookmark'
      - 'getTagsForUrl(provider, url): async, returns tags array'
      - 'getBadgeDisplayValue(bookmark, config): text, tagCount, isPrivate, isToRead, isBookmarked, title'
      - 'handleGetCurrentBookmark: use getBookmarkForDisplay(bookmarkProvider, targetUrl, data?.title); set normalized.needsAuth when !hasAuth'
      - 'handleSaveBookmark: previous tags from getTagsForUrl(bookmarkProvider, data.url)'
      - 'GET_TAGS_FOR_URL and handleGetTagsForUrl(data): return { tags } from getTagsForUrl(bookmarkProvider, data.url)'
      - 'BookmarkRouter _hasTags/_isEmptyBookmark use normalizeBookmarkForDisplay'
      - 'PopupController getBookmarkData: resolve(null) only when blocked; when needsAuth still return bookmark with tags'
      - 'PopupController: re-fetch before add/remove tag; validateBookmarkData normalizes tags to array'
  code_locations:
    files:
      - path: src/features/storage/url-tags-manager.js
        description: normalizeBookmarkForDisplay, getBookmarkForDisplay, getTagsForUrl, getBadgeDisplayValue
      - path: src/core/message-handler.js
        description: handleGetCurrentBookmark from router; handleGetTagsForUrl
      - path: src/core/service-worker.js
        description: updateBadgeForTab normalizes bookmark then BadgeManager.updateBadge
      - path: src/core/badge-manager.js
        description: calculateBadgeData uses getBadgeDisplayValue
      - path: src/ui/popup/PopupController.js
        description: getBookmarkData only null when blocked; re-fetch on add/remove tag
      - path: src/features/storage/bookmark-router.js
        description: _hasTags and _isEmptyBookmark use normalizeBookmarkForDisplay
    functions: []
  traceability:
    architecture:
      - ARCH-URL_TAGS_DISPLAY
    requirements:
      - REQ-URL_TAGS_DISPLAY
      - REQ-BADGE_INDICATORS
    tests:
      - tests/unit/url-tags-manager.test.js
      - tests/unit/popup-live-data.test.js
      - tests/unit/message-handler-url-tags.test.js
      - tests/unit/bookmark-router.test.js
      - tests/unit/tag-storage.test.js
    code_annotations:
      - IMPL-URL_TAGS_DISPLAY
  related_decisions:
    depends_on: []
    supersedes: []
    see_also:
      - IMPL-BOOKMARK_ROUTER
      - IMPL-BADGE_REFRESH
    composed_with:
      - IMPL-BOOKMARK_ROUTER
      - IMPL-BADGE_REFRESH
      - IMPL-MESSAGE_HANDLING
  essence_pseudocode: |
    # [IMPL-URL_TAGS_DISPLAY] [ARCH-URL_TAGS_DISPLAY] [REQ-URL_TAGS_DISPLAY] [REQ-BADGE_INDICATORS] [REQ-PER_BOOKMARK_STORAGE_BACKEND]
    # normalizeBookmarkForDisplay, getBookmarkForDisplay, getTagsForUrl, getBadgeDisplayValue; handler and popup use router and re-fetch.
    # Contract: bookmark or provider+url; normalized bookmark, tags, or badge value.
    INPUT: bookmark (raw from provider), provider + url + title (for getBookmarkForDisplay), provider + url (for getTagsForUrl)
    OUTPUT: normalized bookmark (tags array), tags array, badge display value (text, tagCount, flags)
    DATA: single module url-tags-manager; used by message-handler, service-worker, badge-manager, popup, bookmark-router

    # Tags as array; required defaults; null -> empty shape.
    normalizeBookmarkForDisplay(bookmark):
      IF bookmark null: RETURN null or empty shape
      tags = bookmark.tags IF array ELSE (bookmark.tags split by spaces or [])
      RETURN { ...bookmark, tags, ...requiredDefaults }

    # Get raw from provider and normalize; caller sets needsAuth.
    getBookmarkForDisplay(provider, url, title):
      raw = await provider.getBookmarkForUrl(url)
      RETURN normalizeBookmarkForDisplay(raw); caller sets needsAuth when !hasAuth

    # Get bookmark for url and return tags array.
    getTagsForUrl(provider, url):
      bookmark = await getBookmarkForDisplay(provider, url, null)
      RETURN bookmark?.tags ?? []

    # Normalize and return text, tagCount, isPrivate, isToRead, isBookmarked, title.
    getBadgeDisplayValue(bookmark, config):
      normalized = normalizeBookmarkForDisplay(bookmark)
      RETURN { text, tagCount, isPrivate, isToRead, isBookmarked, title }

    # Handler uses getBookmarkForDisplay and getTagsForUrl; popup null only when blocked and re-fetches; router uses normalizeBookmarkForDisplay.
    Message handler: handleGetCurrentBookmark always via getBookmarkForDisplay(router); handleGetTagsForUrl returns getTagsForUrl. Popup: getBookmarkData null only when blocked; re-fetch tags before add/remove. Router: _hasTags/_isEmptyBookmark use normalizeBookmarkForDisplay.
  detail_file: implementation-decisions/IMPL-URL_TAGS_DISPLAY.yaml
  metadata:
    created:
      date: '2026-02-18'
      author: MCP converter
    last_updated:
      date: '2026-02-20'
      author: AI Agent
      reason: Canonical YAML rewrite; add essence_pseudocode and composed_with; remove extraneous keys
    last_validated:
      date: '2026-02-18'
      validator: MCP converter
      result: pass
