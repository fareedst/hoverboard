IMPL-SUGGESTED_TAGS:
  name: Suggested Tags Implementation
  status: Active
  cross_references:
    - ARCH-SUGGESTED_TAGS
    - REQ-SUGGESTED_TAGS_FROM_CONTENT
    - REQ-SUGGESTED_TAGS_DEDUPLICATION
    - REQ-SUGGESTED_TAGS_CASE_PRESERVATION
  rationale:
    why: Two extraction paths â€” TagService for overlay (content script), inlined script injection for popup (page context). Both use multi-source extraction, frequency ranking, case preservation, deduplication; limits and sanitization differ slightly.
    problems_solved: []
    benefits: []
  implementation_approach:
    summary: Extract from title, URL, meta, headings, emphasis elements, definition terms, table headers, nav, breadcrumbs, images, links (per-source limits). Tokenize, filter noise, frequency sort, case preservation, sanitize, deduplicate, apply limit. Overlay path uses TagService; popup path uses executeScript with inlined same algorithm.
    details: []
  code_locations:
    files:
      - path: src/features/tagging/tag-service.js
        description: extractSuggestedTagsFromContent (overlay path)
      - path: src/features/content/overlay-manager.js
        description: Suggested section display
      - path: src/ui/popup/PopupController.js
        description: loadSuggestedTags inlined extraction
      - path: src/ui/popup/UIManager.js
        description: updateSuggestedTags
      - path: safari/src/features/tagging/tag-service.js
        description: Safari mirror extraction
      - path: safari/src/features/content/overlay-manager.js
        description: Safari mirror overlay
    functions:
      - name: extractSuggestedTagsFromContent
        file: src/features/tagging/tag-service.js
        description: Primary extraction for overlay; limit default; includes meta, emphasis, structured content
      - name: loadSuggestedTags
        file: src/ui/popup/PopupController.js
        description: Popup extraction via executeScript; inlined function duplicates algorithm
  traceability:
    architecture:
      - ARCH-SUGGESTED_TAGS
    requirements:
      - REQ-SUGGESTED_TAGS_FROM_CONTENT
      - REQ-SUGGESTED_TAGS_DEDUPLICATION
      - REQ-SUGGESTED_TAGS_CASE_PRESERVATION
    tests:
      - tests/unit/popup-suggested-tags.test.js
    code_annotations:
      - IMPL-SUGGESTED_TAGS
      - ARCH-SUGGESTED_TAGS
      - REQ-SUGGESTED_TAGS_FROM_CONTENT
      - REQ-SUGGESTED_TAGS_DEDUPLICATION
      - REQ-SUGGESTED_TAGS_CASE_PRESERVATION
  related_decisions:
    depends_on: []
    supersedes: []
    see_also:
      - ARCH-SUGGESTED_TAGS
      - REQ-SUGGESTED_TAGS_FROM_CONTENT
      - REQ-SUGGESTED_TAGS_DEDUPLICATION
      - REQ-SUGGESTED_TAGS_CASE_PRESERVATION
    composed_with:
      - IMPL-SELECTION_TO_TAG_INPUT
  essence_pseudocode: |
    INPUT: document, url, limit (per-path defaults differ)
    OUTPUT: list of suggested tag strings (frequency-ordered, case-preserved, deduplicated)
    DATA: sources = title, URL segments, meta keywords/description, headings, emphasis elements (strong/b/em/...), definition terms, table headers/captions, nav links, breadcrumbs, images alt, main links (each with per-source cap); noise word set; delimiter regex for tokenize

    extractSuggestedTags(document, url, limit):
      allTexts = []
      allTexts.push( title, urlSegments, metaKeywords, metaDescription, headings, emphasisElements, definitionTerms, tableHeaders, navLinks, breadcrumbs, imageAlts, mainLinks )  // each source capped
      text = join allTexts with space
      words = tokenize(text)  // split on delimiter regex (whitespace, punctuation, brackets, quotes)
      filtered = filter words: NOT noise AND length >= 2 AND NOT pure number
      wordFrequency = count by lowercase key; originalCaseMap = first-seen case per lowercase
      sorted = sort by frequency descending, then alphabetically by lowercase
      tagsWithVersions = []
      FOR each (lowerWord, count) in sorted:
        originalCase = originalCaseMap[lowerWord]
        tagsWithVersions.push(originalCase)
        IF originalCase !== lowerWord THEN tagsWithVersions.push(lowerWord)
      sanitized = map sanitize over tagsWithVersions, filter non-empty
      unique = deduplicate exact strings
      RETURN unique.slice(0, limit or limit*2 for case variants)

    overlay path: call TagService.extractSuggestedTagsFromContent(document, url, limit)
    popup path: chrome.scripting.executeScript with inlined function implementing same algorithm; skip if URL not http(s); filter result vs currentPin.tags (case-insensitive) before display
  detail_file: implementation-decisions/IMPL-SUGGESTED_TAGS.yaml
  metadata:
    created:
      date: '2026-02-18'
      author: MCP converter
    last_updated:
      date: '2026-02-20'
      author: AI Agent
      reason: Canonical YAML rewrite; add essence_pseudocode and composed_with; remove extraneous keys
    last_validated:
      date: '2026-02-18'
      validator: MCP converter
      result: pass
